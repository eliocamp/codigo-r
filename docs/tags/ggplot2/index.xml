<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ggplot2 on C√≥digo R</title>
    <link>https://eliocamp.github.io/codigo-r/tags/ggplot2/</link>
    <description>Recent content in Ggplot2 on C√≥digo R</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <lastBuildDate>Tue, 18 Sep 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://eliocamp.github.io/codigo-r/tags/ggplot2/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Multiple color (and fill) scales with ggplot2</title>
      <link>https://eliocamp.github.io/codigo-r/2018/09/multiple-color-fill-scales-ggplot2/</link>
      <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://eliocamp.github.io/codigo-r/2018/09/multiple-color-fill-scales-ggplot2/</guid>
      <description>

&lt;p&gt;(&lt;a href=&#34;https://eliocamp.github.io/codigo-r/2018/09/multiples-escalas-colores-ggplot2/&#34;&gt;Versi√≥n en espa√±ol&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;tl;dr: The functionality shown in this post is now on the &lt;a href=&#34;https://github.com/eliocamp/ggnewscale&#34;&gt;&lt;code&gt;ggnewscale&lt;/code&gt;&lt;/a&gt; package! üì¶. You can find the original code &lt;a href=&#34;https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32&#34;&gt;in this gist&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A somewhat common annoyance for some &lt;code&gt;ggplot2&lt;/code&gt; users is the lack of support for multiple colour and fill scales. Perusing StackOverflow you can find many questions relating to this issue:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/search?q=ggplot2+two+color+scales&#34;&gt;&lt;img src=&#34;../../images/ggplo2_twoscales_so_small.jpg&#34; alt=&#34;preguntas stack overflow&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, this deluge of questions is met with a shortage of conclusive answers, most of them being some variation of &amp;ldquo;you can&amp;rsquo;t, but here&amp;rsquo;s how to hack it or visualise the data differently&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Recently I came up with a way of tricking &lt;code&gt;ggplot2&lt;/code&gt; into displaying multiple scales. It relies on &lt;a href=&#34;https://github.com/tidyverse/ggplot2/pull/2555&#34;&gt;a recent addition&lt;/a&gt; by Claus Wilke that allows the usage of &amp;ldquo;non standard aesthetics&amp;rdquo; &amp;ndash;&lt;code&gt;scale_color_continuous(aesthetics = &amp;quot;fill&amp;quot;)&lt;/code&gt; sets a &lt;code&gt;fill&lt;/code&gt; scale&amp;ndash; and the use of &lt;code&gt;ggplot_add()&lt;/code&gt; that I learnt thanks to &lt;a href=&#34;https://yutani.rbind.io/post/2017-11-07-ggplot-add&#34;&gt;this post&lt;/a&gt; by Hiroaki Yutani.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s be serious for a moment and acknowledge that using multiple color scales is not for the faint of heart. There&amp;rsquo;s a very real risk of ending up with a plot with is at best confusing and at worst, misleading. But that doesn&amp;rsquo;t mean there are not situations that call for this kind of plot. Using very different scales allows you to condense more information in a single plot, letting you visualise more relationships between variables. In the Atmospheric Sciences, for example, plotting temperature and pressure in contour lines with different color scales is a common practice.&lt;/p&gt;

&lt;p&gt;But &lt;em&gt;res non verba&lt;/em&gt;; this is how it looks like in action (with an example taken from &lt;a href=&#34;https://stackoverflow.com/questions/16129876/ggplot2-multiple-scales-legends-per-aesthetic-revisited&#34;&gt;this&lt;/a&gt; StackOverlow question)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
   geom_tile(aes(fill  =score1)) +
   scale_fill_gradient2(&amp;quot;Score 1&amp;quot;, limits = c(0, 4), 
                        low = &amp;quot;#762A83&amp;quot;, mid = &amp;quot;white&amp;quot;, high = &amp;quot;#1B7837&amp;quot;) +
   
   new_scale(&amp;quot;fill&amp;quot;) +
   
   geom_tile(aes(fill = score2), data = subset(pd, score2 != 0)) +
   scale_fill_gradient2(&amp;quot;Score 2&amp;quot;, limits = c(0, 3), 
                        low = &amp;quot;#1B7837&amp;quot;, mid = &amp;quot;white&amp;quot;, high = &amp;quot;#762A83&amp;quot;) +
   
   geom_text(data=pd, aes(label = letters, color = factor(change))) +
   scale_color_manual(&amp;quot;Change&amp;quot;, values = c(&amp;quot;black&amp;quot;, &amp;quot;#F2A11F&amp;quot;), 
                      labels = c(&amp;quot;None&amp;quot;, &amp;quot;Some&amp;quot;)) +
   coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-09-18-multiple-color-and-fill-scales-with-ggplot2_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;

&lt;p&gt;The code is a bit too long and tedious to show in this article, but you can find it on &lt;a href=&#34;https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32&#34;&gt;this gist&lt;/a&gt;. Here are the important bits.&lt;/p&gt;

&lt;p&gt;First, the &lt;code&gt;new_scale()&lt;/code&gt; function does nothing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;new_scale &amp;lt;- function(new_aes) {
   structure(ggplot2::standardise_aes_names(new_aes), class = &amp;quot;new_aes&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It merely returns an object of class &lt;code&gt;new_aes&lt;/code&gt; with a character vector with the &amp;ldquo;new&amp;rdquo; scales. All the magic is in the &lt;code&gt;+&lt;/code&gt; operator. &lt;code&gt;ggplot2&lt;/code&gt; objects are &amp;ldquo;summed&amp;rdquo; with &lt;code&gt;ggplot_add()&lt;/code&gt; function which allows to define the &amp;ldquo;add&amp;rdquo; operation for any arbitrary object to a ggplot. For the case of &lt;code&gt;new_aes&lt;/code&gt; object, this is what happens:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot_add.new_aes &amp;lt;- function(object, plot, object_name) {
   plot$layers &amp;lt;- lapply(plot$layers, bump_aes, new_aes = object)
   plot$scales$scales &amp;lt;- lapply(plot$scales$scales, bump_aes, new_aes = object)
   plot$labels &amp;lt;- bump_aes(plot$labels, new_aes = object)
   plot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It modifies each layer, scale and label and renames the relevant aesthetic to something other than &amp;ldquo;fill&amp;rdquo; or &amp;ldquo;colour&amp;rdquo;. There&amp;rsquo;s also a bit of minimally invasive surgery to geoms so that they don&amp;rsquo;t reject the newly grafted aesthetic. Is somewhat ad-hoc, to be honest, and probably not very robuts, but it works!&lt;/p&gt;

&lt;p&gt;There are many other ways to implement this and I went through &lt;a href=&#34;https://twitter.com/d_olivaw/status/1040722632675610626&#34;&gt;some iterations&lt;/a&gt;. The current implementation is friendly and consistent with the main &lt;code&gt;ggplot2&lt;/code&gt; &amp;ldquo;adding&amp;rdquo; idea, but it has some limitations and annoyances that prevent me from being 100% on board with it. I would love to get some feedback from the community ü§û!&lt;/p&gt;

&lt;h2 id=&#34;a-more-real-ish-example&#34;&gt;A more real-ish example&lt;/h2&gt;

&lt;p&gt;Why is any of this useful to me, you say? As I wrote before, being able to plot temperature and pressure in the same map with two different scales is very neat.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(metR)
library(magrittr)
time &amp;lt;- as.POSIXct(&amp;quot;1998-01-01&amp;quot;)
# Temperature and sea level pressure for January 1st 1998
atmos &amp;lt;- ReadNetCDF(&amp;quot;~/DATOS/NCEP Reanalysis/air.mon.mean.nc&amp;quot;, 
                    subset = list(level = 850, 
                                  time = time)) %&amp;gt;% 
   .[, slp:= ReadNetCDF(&amp;quot;~/DATOS/NCEP Reanalysis/slp.mon.mean.nc&amp;quot;, 
                        subset = list(time = time), out = &amp;quot;vector&amp;quot;)] %&amp;gt;% 
   .[, lon := ConvertLongitude(lon)]

ggplot(atmos, aes(lon, lat)) +
   geom_world() +
   geom_contour(aes(z = slp, color = ..level..), binwidth = 4) +
   scale_color_viridis_c(&amp;quot;Sea level pressure&amp;quot;) +
   
   new_scale_color() +   # same as `new_scale(&amp;quot;color&amp;quot;)`
   
   geom_contour(aes(z = air, color = ..level..), binwidth = 4) +
   scale_color_distiller(&amp;quot;Air Temperature&amp;quot;, palette = &amp;quot;Spectral&amp;quot;)  +
   
   scale_x_longitude(limits = c(-150, 0)) +
   scale_y_latitude(ticks = 15) +
   ggalt::coord_proj(&amp;quot;+proj=moll +lon_0=-75&amp;quot;, 
                     ylim = c(-60, 0), xlim = c(-150, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-09-18-multiple-color-and-fill-scales-with-ggplot2_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Visualising the relationship between pressure and temperature is very important for the analysis of the growth of atmospheric perturbations.&lt;/p&gt;

&lt;p&gt;Of course, with great power comes great responsibility üï∏. Mixing multiple scales for the same aesthetic should be done sparingly and only if absolutely necessary. First always ask yourself if the same information cannot be shown in a better way.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ggplot2&lt;/code&gt; doesn&amp;rsquo;t cease to amaze me. Is not only a very powerful package to construct any kind of complex plots in a stupidly simple way, but it&amp;rsquo;s also exceptionally extensible by allowing this kind of deep user customisation. ¬°Long live the &lt;code&gt;ggplo2&lt;/code&gt; ‚úä!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>M√∫ltiples escalas de colores en ggplot2</title>
      <link>https://eliocamp.github.io/codigo-r/2018/09/multiples-escalas-colores-ggplot2/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://eliocamp.github.io/codigo-r/2018/09/multiples-escalas-colores-ggplot2/</guid>
      <description>

&lt;p&gt;tl;dr: Esta funcionalidad est√° ahora en el paquete &lt;a href=&#34;https://github.com/eliocamp/ggnewscale&#34;&gt;&lt;code&gt;ggnewscale&lt;/code&gt;&lt;/a&gt;! üì¶
En &lt;a href=&#34;https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32&#34;&gt;este gist&lt;/a&gt; est√° la versi√≥n origial del c√≥digo.&lt;/p&gt;

&lt;p&gt;Un dolor importante para algunos usuarios de &lt;code&gt;ggplot2&lt;/code&gt; es la imposibilidad de usar m√°s de una escala para cada tipo de par√°metro est√©tico. Una b√∫squeda en StackOverflow da como resultado m√∫ltiples preguntas:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/search?q=ggplot2+two+color+scales&#34;&gt;&lt;img src=&#34;../../images/ggplo2_twoscales_so_small.jpg&#34; alt=&#34;preguntas stack overflow&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pero ninguna respuesta tiene una soluci√≥n realmente satisfactoria; la mayor√≠a son del tipo &amp;ldquo;no se puede, pero esta es otra forma de graficar tus datos&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Tener varias escalas distintas para el mismo par√°metro est√©tico tiene riesgos, pero tambi√©n beneficios. Cuando las escalas son bien distintas, permiten condensar m√°s informaci√≥n en un mismo gr√°fico, facilitando la visualizaci√≥n de interacciones entre distintas variables. En ciencias de la atm√≥sfera, por ejemplo, es muy habitual graficar temperatura y presi√≥n con l√≠neas de contorno usando distintas escalas de colores.&lt;/p&gt;

&lt;p&gt;Recientemente, gracias a &lt;a href=&#34;https://github.com/tidyverse/ggplot2/pull/2555&#34;&gt;un aporte&lt;/a&gt; de Claus Wilke, &lt;code&gt;ggplot2&lt;/code&gt; permite usar &amp;ldquo;par√°metros est√©ticos no est√°ndar&amp;rdquo;. Por ejemplo, se puede hacer &lt;code&gt;scale_color_continuous(aesthetics = &amp;quot;fill&amp;quot;)&lt;/code&gt; para especificar la escala del &lt;code&gt;fill&lt;/code&gt;. Esto, junto con el uso de &lt;code&gt;ggplot_add()&lt;/code&gt; para &amp;ldquo;sumarle&amp;rdquo; cualquier elemento a un objecto de ggplot2 (gracias a Hiroaki Yutani por &lt;a href=&#34;https://yutani.rbind.io/post/2017-11-07-ggplot-add&#34;&gt;su post&lt;/a&gt;!), permite hacer algunas triqui√±uelas para agregar m√∫ltiples escalas de color (o fill, o lo que sea).&lt;/p&gt;

&lt;p&gt;D√©jenme ilustrar con un ejemplo sacado de &lt;a href=&#34;https://stackoverflow.com/questions/16129876/ggplot2-multiple-scales-legends-per-aesthetic-revisited&#34;&gt;esta pregunta&lt;/a&gt; de StackOverflow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
   geom_tile(aes(fill  =score1)) +
   scale_fill_gradient2(&amp;quot;Score 1&amp;quot;, limits = c(0, 4), 
                        low = &amp;quot;#762A83&amp;quot;, mid = &amp;quot;white&amp;quot;, high = &amp;quot;#1B7837&amp;quot;) +
   
   new_scale(&amp;quot;fill&amp;quot;) +
   
   geom_tile(aes(fill = score2), data = subset(pd, score2 != 0)) +
   scale_fill_gradient2(&amp;quot;Score 2&amp;quot;, limits = c(0, 3), 
                        low = &amp;quot;#1B7837&amp;quot;, mid = &amp;quot;white&amp;quot;, high = &amp;quot;#762A83&amp;quot;) +
   
   geom_text(data=pd, aes(label = letters, color = factor(change))) +
   scale_color_manual(&amp;quot;Change&amp;quot;, values = c(&amp;quot;black&amp;quot;, &amp;quot;#F2A11F&amp;quot;), 
                      labels = c(&amp;quot;None&amp;quot;, &amp;quot;Some&amp;quot;)) +
     coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-09-17-multiples-escalas-de-colores-en-ggplot2_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;c√≥mo-funciona&#34;&gt;C√≥mo funciona&lt;/h2&gt;

&lt;p&gt;El c√≥digo es un tanto largo y tedioso para ponerlo en un art√≠culo (pueden encontrarlo en &lt;a href=&#34;https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32&#34;&gt;este gist&lt;/a&gt;) as√≠ que ac√° voy a hablar de la parte m√°s importante.&lt;/p&gt;

&lt;p&gt;Primero, la funci√≥n &lt;code&gt;new_scale()&lt;/code&gt; no hace nada. S√≥lo crea un objeto de clase &lt;code&gt;new_aes&lt;/code&gt; que no es m√°s que un vector de texto con las escalas &amp;ldquo;nuevas&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;new_scale &amp;lt;- function(new_aes) {
  structure(ggplot2::standardise_aes_names(new_aes), class = &amp;quot;new_aes&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La magia est√° en el &lt;code&gt;+&lt;/code&gt;. Al sumar objectos de ggplot, se usa la funci√≥n gen√©rica &lt;code&gt;ggplot_add()&lt;/code&gt;. Este es el m√©todo para los objectos de clase &lt;code&gt;new_aes&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot_add.new_aes &amp;lt;- function(object, plot, object_name) {
  plot$layers &amp;lt;- lapply(plot$layers, bump_aes, new_aes = object)
  plot$scales$scales &amp;lt;- lapply(plot$scales$scales, bump_aes, new_aes = object)
  plot$labels &amp;lt;- bump_aes(plot$labels, new_aes = object)
  plot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lo que hace es agarrar cada capa, escala y etiqueta y cambiarle el nombre de los par√°metros est√©ticos; efectivamente les agrega la palabra &amp;ldquo;_new&amp;rdquo; de manera que el &amp;ldquo;color&amp;rdquo; pasa a ser &amp;ldquo;color_new&amp;rdquo;. Hay que hacer un poco de cirug√≠a interna m√≠nimamente invasiva (la laparoscop√≠a de la programaci√≥n) para que los geoms no se vuelvan locos al recibir un data frame con una columna llamada &amp;ldquo;color_new&amp;rdquo; en vez de &amp;ldquo;color&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Hay varias formas de hacer lo mismo y podr√°n ver que el proyecto pas√≥ por &lt;a href=&#34;https://twitter.com/d_olivaw/status/1040722632675610626&#34;&gt;varias iteraciones&lt;/a&gt;. Todav√≠a no estoy 100% de que esta forma sea totalmente amigable y ser√≠a genial recibir un poco de feedback de la comunidad ü§û.&lt;/p&gt;

&lt;h2 id=&#34;ejemplo-real&#34;&gt;Ejemplo real&lt;/h2&gt;

&lt;p&gt;¬øPara qu√© sirve todo esto en definitiva? Bueno, como dec√≠a antes, una posibilidad es la de graficar temperatura y presi√≥n en un mismo mapa usando dos escalas distintas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(metR)
library(magrittr)
time &amp;lt;- &amp;quot;1998-01-01&amp;quot;
# Temperatura y presi√≥n a nivel del mar para el 1¬∞ de enero de 1998
atmos &amp;lt;- ReadNetCDF(&amp;quot;~/DATOS/NCEP Reanalysis/air.mon.mean.nc&amp;quot;, 
                          subset = list(level = 850, 
                                        time = time)) %&amp;gt;% 
   .[, slp:= ReadNetCDF(&amp;quot;~/DATOS/NCEP Reanalysis/slp.mon.mean.nc&amp;quot;, 
                  subset = list(time = time), out = &amp;quot;vector&amp;quot;)] %&amp;gt;% 
   .[, lon := ConvertLongitude(lon)]

ggplot(atmos, aes(lon, lat)) +
   geom_world() +
   geom_contour(aes(z = slp, color = ..level..), binwidth = 4) +
   scale_color_viridis_c(&amp;quot;Presi√≥n a nivel del mar&amp;quot;) +
   
   new_scale_color() +   # lo mismo que `new_scale(&amp;quot;color&amp;quot;)`
   
   geom_contour(aes(z = air, color = ..level..), binwidth = 4) +
   scale_color_distiller(&amp;quot;Temperatura del aire&amp;quot;, palette = &amp;quot;Spectral&amp;quot;)  +
   
   scale_x_longitude(limits = c(-150, 0)) +
   scale_y_latitude(ticks = 15) +
   ggalt::coord_proj(&amp;quot;+proj=moll +lon_0=-75&amp;quot;, 
                     ylim = c(-60, 0), xlim = c(-150, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-09-17-multiples-escalas-de-colores-en-ggplot2_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Observar la relaci√≥n entre la presi√≥n y la temperatura permite analizar procesos del crecimiento de las perturbaciones de la atm√≥sfera.&lt;/p&gt;

&lt;p&gt;Por supuesto, un gran poder conlleva una gran responsabilidad üï∏. Mezclar muchas escalas no es para cualquiera y debe ser usado bien y s√≥lo si es absolutamente necesario. Siempre conviene pensar si no hay una mejor manera de mostrar lo mismo.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ggplot2&lt;/code&gt; nunca deja de maravillarme. No s√≥lo es un paquete poderos√≠simo para hacer toda clase gr√°ficos de una manera est√∫pidamente simple y amigable, sino que es excepcionalmente extensible permitiendo este tipo de modificaci√≥n por parte de los usuarios. ¬°Larga vida a &lt;code&gt;ggplot2&lt;/code&gt; ‚úä!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wrapping around ggplot2 with ggperiodic</title>
      <link>https://eliocamp.github.io/codigo-r/2018/08/periodic-data-ggplot2-ggperiodic/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://eliocamp.github.io/codigo-r/2018/08/periodic-data-ggplot2-ggperiodic/</guid>
      <description>

&lt;p&gt;As an atmospheric scientists, a lot of my research consists on plotting and looking at global fields of atmospheric variables like pressure, temperature and the like. Since our planet is a sphere (well, &lt;a href=&#34;https://chem.tufts.edu/answersinscience/relativityofwrong.htm&#34;&gt;almost&lt;/a&gt;), it is unbound and so longitude is a &lt;em&gt;periodic&lt;/em&gt; dimension. That is, to the right of 180¬∞E you go back to 180¬∞W. But ggplot2 and other plotting systems, for the most part, assume linear dimensions.&lt;/p&gt;

&lt;p&gt;To show why this is a problem, let us plot a fairly basic scalar field defined in a regular grid with 2.5¬∞ of resolution for the southern hemisphere.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data, aes(lon, lat)) +
   geom_contour_fill(aes(z = gh)) +
   map.SH +
   scale_fill_viridis_c(&amp;quot;Geopotential\nHeight&amp;quot;) +
   coord_polar()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-08-21-wrapping-around-ggplot2_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Did you spot it? The field is defined between 0¬∞ and 357.5¬∞. Because 360¬∞ is the same as 0¬∞, you would be double counting if you had a value at both extremes. But since ggplot2 only &amp;lsquo;sees&amp;rsquo; the data you feed to it, it fails to plot the implied data between 357.5¬∞ and 360¬∞.&lt;/p&gt;

&lt;h2 id=&#34;defining-the-problem&#34;&gt;Defining the problem&lt;/h2&gt;

&lt;p&gt;The scope of the problem as I see it is much broader than global maps of atmospheric data.&lt;/p&gt;

&lt;p&gt;We have a periodic function defined at regular &lt;em&gt;or irregular&lt;/em&gt; locations inside one period. Since this finite number of locations actually define the infinite domain of the function, when we plot we want to &lt;em&gt;wrap&lt;/em&gt; these locations around any arbitrary domain we need. This should be fast and automatic.&lt;/p&gt;

&lt;p&gt;This translates, I think, to having two distinct domains. On the one hand there&amp;rsquo;s the &lt;em&gt;period&lt;/em&gt; defined by the sampled data, and on the other there&amp;rsquo;s the &lt;em&gt;range&lt;/em&gt; we want to &lt;em&gt;wrap&lt;/em&gt; this data around. The first is a property of the &lt;em&gt;data&lt;/em&gt;, the second one is a property of the &lt;em&gt;visualisation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Somewhere on the plotting process, then, &lt;code&gt;ggplot2&lt;/code&gt; must repeat the data so that it wraps it around the desired range.&lt;/p&gt;

&lt;h2 id=&#34;solving-the-problem&#34;&gt;Solving the problem&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/eliocamp/ggperiodic&#34;&gt;ggperiodic&lt;/a&gt; package embodies these ideas. First, we define the period of each of the periodic variables on our data. In this case, &lt;code&gt;lon&lt;/code&gt; is periodic between 0¬∞ and 306¬∞&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggperiodic)
data &amp;lt;- periodic(data, lon = c(0, 360))
head(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##     lon lat level       gh       time
## 1:  0.0 -30   200 12333.66 2017-01-01
## 2:  2.5 -30   200 12333.17 2017-01-01
## 3:  5.0 -30   200 12335.23 2017-01-01
## 4:  7.5 -30   200 12339.44 2017-01-01
## 5: 10.0 -30   200 12344.92 2017-01-01
## 6: 12.5 -30   200 12351.60 2017-01-01
## lon = [0; 360]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;data&lt;/code&gt; is of a new class of &amp;ldquo;periodic_df&amp;rdquo;, but so far the actual content of &lt;code&gt;data&lt;/code&gt; has remain unchanged. The magic comes on the second step üåü. Now we can &lt;code&gt;wrap&lt;/code&gt; the data in any arbitrary range. For example, lets change longitude to be between -180¬∞ and 180¬∞&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;data180 &amp;lt;- wrap(data, lon = c(-180, 180))
head(data180)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##       lon lat level       gh       time
## 1: -180.0 -30   200 12311.90 2017-01-01
## 2: -177.5 -30   200 12310.48 2017-01-01
## 3: -175.0 -30   200 12311.84 2017-01-01
## 4: -172.5 -30   200 12316.52 2017-01-01
## 5: -170.0 -30   200 12324.02 2017-01-01
## 6: -167.5 -30   200 12333.00 2017-01-01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You &lt;em&gt;could&lt;/em&gt; do this manually every time you what to plot your data, but there&amp;rsquo;s a better way. When ggplot2 gets a &lt;code&gt;data&lt;/code&gt; argument, it doesn&amp;rsquo;t just pass it along. First, it feeds it to a function called &lt;code&gt;fortify()&lt;/code&gt;. ggperiodic implements &lt;code&gt;fortify.periodic_df()&lt;/code&gt; so that the wrapping can be performed automatically at plotting time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data, aes(lon, lat)) +
   geom_contour_fill(aes(z = gh)) +
   map.SH +
   scale_fill_viridis_c(&amp;quot;Geopotential\nHeight&amp;quot;) +
   coord_polar()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-08-21-wrapping-around-ggplot2_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is completely automatic ü§ñ, robust to transformations and very friendly to the user. By default the data is wrapped around the same range as the period, but that can be changed using the same syntax as with &lt;code&gt;wrap()&lt;/code&gt;. For example, it could be useful to show three whole periods so that any 360¬∞ range could be seen with no interruptions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data, aes(lon, lat), lon = c(0, 360)*3) +
   geom_contour_fill(aes(z = gh)) +
   scale_fill_viridis_c(&amp;quot;Geopotential\nHeight&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-08-21-wrapping-around-ggplot2_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Since ggplot2 also uses &lt;code&gt;fortify()&lt;/code&gt; for data passed to geoms, it also works there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot() +
   geom_contour_fill(data = data, aes(lon, lat, z = gh), lon = c(-180, 180)) +
   map.SH2 +
   scale_fill_viridis_c(&amp;quot;Geopotential\nHeight&amp;quot;) +
   coord_polar()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning: Ignoring unknown parameters: lon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-08-21-wrapping-around-ggplot2_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this case works well but there are some limitations related to the somewhat ugly hack I had to use to pass the extra parameters to &lt;code&gt;fortify.periodic_df()&lt;/code&gt;. If used on a layer, the name of the periodic dimension must not be the same as any possible aesthetic or any other arguments passed to the geom, i.e. having &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;binwidth&lt;/code&gt; as the periodic dimension is verboten. Also there&amp;rsquo;s an annoying warning üò§.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve tried to make the periodic information &lt;em&gt;sticky&lt;/em&gt; (thanks to the &lt;a href=&#34;https://github.com/decisionpatterns/sticky&#34;&gt;sticky&lt;/a&gt; üì¶) across data manipulations, but I&amp;rsquo;ve still haven&amp;rsquo;t tested thoroughly. And since I mostly use data.table, I&amp;rsquo;m not familiar enough with dplyr to do know the whole range of possible transformations. &lt;a href=&#34;https://github.com/eliocamp/ggperiodic/issues&#34;&gt;Issues&lt;/a&gt; are welcome!&lt;/p&gt;

&lt;p&gt;In any case, if or when you get tired of all this nonsense, you can just remove all periodicity information and go on with your life.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;data &amp;lt;- unperiodic(data)
head(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##     lon lat level       gh       time
## 1:  0.0 -30   200 12333.66 2017-01-01
## 2:  2.5 -30   200 12333.17 2017-01-01
## 3:  5.0 -30   200 12335.23 2017-01-01
## 4:  7.5 -30   200 12339.44 2017-01-01
## 5: 10.0 -30   200 12344.92 2017-01-01
## 6: 12.5 -30   200 12351.60 2017-01-01
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Tu propio smooth en geom_smooth()</title>
      <link>https://eliocamp.github.io/codigo-r/2018/06/tu-propio-geom-smooth/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://eliocamp.github.io/codigo-r/2018/06/tu-propio-geom-smooth/</guid>
      <description>&lt;p&gt;Algo incre√≠blemente satisfactorio de ggplot2 es la posibilidad de ajustar curvas a los datos de manera s√∫per f√°cil con &lt;code&gt;geom_smooth()&lt;/code&gt;. Para mi investigaci√≥n estaba mirando la relaci√≥n entre dos √°ngulos y me di cuenta que la recta ajustada por cuadrados m√≠nimos no estaba funcionando para ilustrar la obvia estructura que hab√≠a en los datos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)

df &amp;lt;- readRDS(&amp;quot;data/smooth_example.Rds&amp;quot;)

ggplot(df, aes(pc.angle, phase)) +
   geom_point() +
   geom_smooth(method = &amp;quot;lm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Se me ocurri√≥ que un mejor modelo podr√≠a ser usando el estimador de &lt;a href=&#34;https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator&#34;&gt;Theil-Sen&lt;/a&gt;, que es la mediana de todas las pendientes entre dos puntos distintos y est√°  implementado en el paquete mblm. El problema es que al usar esa funci√≥n como m√©todo, me dio este cr√≠ptico mensaje de error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(df, aes(pc.angle, phase)) +
   geom_point() +
   geom_smooth(method = &amp;quot;mblm::mblm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning: Computation failed in `stat_smooth()`:
## object &#39;mblm::mblm&#39; of mode &#39;function&#39; was not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ü§î&lt;/p&gt;

&lt;p&gt;Tuve que ponerme a leer el c√≥digo de ggplot2 para entender de d√≥nde ven√≠a el problema, pero gracias a eso aprend√≠ m√°s sobre c√≥mo funciona &lt;code&gt;geom_smooth()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;geom_smooth()&lt;/code&gt; acepta cualquier m√©todo para hacer el modelo, pero con dos detalles importantes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;la funci√≥n que hace el modelo debe aceptar una f√≥rmula como primer argumento y tener argumentos &lt;code&gt;data&lt;/code&gt; y &lt;code&gt;weigths&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;el objeto que devuelve la funci√≥n debe tener un m√©todo para &lt;code&gt;predictdf()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Lo primero es f√°cil de entender. Dentro de &lt;code&gt;geom_smooth()&lt;/code&gt;, ggplot2 b√°sicamente llama algo as√≠ como &lt;code&gt;lm(formula, data, weights, ...)&lt;/code&gt;. Si la funci√≥n no acepta alguno de esos argumentos, nos encontramos con un error. La funci√≥n &lt;code&gt;mblm&lt;/code&gt; no entiende el argumento &lt;code&gt;weights&lt;/code&gt;. La soluci√≥n en ese caso fue crear mi propia funci√≥n que llame a &lt;code&gt;mblm::mblm()&lt;/code&gt; descartando ese argumento (y de paso le puse un nombre m√°s inteligible).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;TheilSen &amp;lt;- function(..., weights = NULL) {
   mblm::mblm(...)
}

ggplot(df, aes(pc.angle, phase)) +
   geom_point() +
   geom_smooth(method = &amp;quot;TheilSen&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;¬°Mucho mejor! üï∫&lt;/p&gt;

&lt;p&gt;El segundo requisito en este ejemplo viene &amp;ldquo;gratis&amp;rdquo; porque &lt;code&gt;mblm()&lt;/code&gt; es compatible con los m√©todos de &lt;code&gt;predict()&lt;/code&gt; de &lt;code&gt;lm()&lt;/code&gt;, pero no siempre es as√≠. En este segundo ejemplo, quiero hacer un suavizado que se base en hacer la transformada de fourier y eliminar una determinada cantidad de frecuencias. Una funci√≥n que hace eso ser√≠a esta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# n es la proporci√≥n de frecuencias que vamos a eliminar. 
# n = 0.5 significa sacar la mitad.
FFTSmooth &amp;lt;- function(formula, data, weights, n = 0.5) {
   f &amp;lt;- fft(data$y)
   keep &amp;lt;- c(0, seq_len(floor(length(f)/2*n)))
   keep &amp;lt;- c(keep + 1, length(f) - keep[keep != 0] + 1)
   f[-keep] &amp;lt;- 0 + 0i
   Re(fft(f, inverse = T))/length(f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notar que la funci√≥n ignora por completo la formula y los pesos, pero hay que ponerlos para que funcione en &lt;code&gt;geom_smooth()&lt;/code&gt;. Esta funci√≥n sirve en el sentido de que hace un suavizado correcto de los datos (¬°siempre que est√©n definidos en intervalos de x regulares!), pero si usamos &lt;code&gt;geom_smooth(method = &amp;quot;FFTSmooth&amp;quot;)&lt;/code&gt; ggplot2 nos va a tirar un error:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Computation failed in &lt;code&gt;stat_smooth()&lt;/code&gt;: no applicable method for &amp;lsquo;predict&amp;rsquo; applied to an object of class &amp;ldquo;c(&amp;lsquo;double&amp;rsquo;, &amp;lsquo;numeric&amp;rsquo;)&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El problema es que &lt;code&gt;FTTSmooth()&lt;/code&gt; devuelve los valores suavizados, pero lo que tiene que devolver es un &amp;ldquo;modelo&amp;rdquo; que devuelva los valores suavizados al hacer &lt;code&gt;predictdf(model, xseq, se, level)&lt;/code&gt; (donde &lt;code&gt;xseq&lt;/code&gt; son los puntos de x donde se eval√∫a el modelo, &lt;code&gt;se&lt;/code&gt; es TRUE o FALSE seg√∫n si queremos un intervalo de confianza y &lt;code&gt;level&lt;/code&gt; es el nivel de confianza de dicho intervalo). Esta segunda implementaci√≥n del suavizado s√≠ funciona.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;FFTSmooth &amp;lt;- function(formula, data, weights, n = 0.5) {
   f &amp;lt;- fft(data$y)
   keep &amp;lt;- c(0, seq_len(floor(length(f)/2*n)))
   keep &amp;lt;- c(keep + 1, length(f) - keep[keep != 0] + 1)
   f[-keep] &amp;lt;- 0 + 0i
   
   model &amp;lt;- list(x = data$x, pred = Re(fft(f, inverse = T))/length(f))
   class(model) &amp;lt;- &amp;quot;my_smooth&amp;quot;
   return(model)
}

predictdf.my_smooth &amp;lt;- function(model, xseq, se, level) {
   data.frame(x = model$x, y = model$pred)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La diferencia importante en &lt;code&gt;FFTSmooth()&lt;/code&gt; es que ahora devuelve una lista con los valores de &lt;code&gt;x&lt;/code&gt; y los de &lt;code&gt;y&lt;/code&gt; suavizados pero que tiene clase &amp;ldquo;my_smooth&amp;rdquo;. Cuando ggplot2 llame &lt;code&gt;predictdf(model, ...)&lt;/code&gt;, R va a buscar la funci√≥n &lt;code&gt;predictdf.my_smooth()&lt;/code&gt; (as√≠ es b√°sicamente c√≥mo funcionan las &lt;a href=&#34;http://adv-r.had.co.nz/S3.html&#34;&gt;clases&lt;/a&gt; en R). &lt;code&gt;predictdf.my_smooth()&lt;/code&gt;, por su parte, ignora casi todos los inputs y simplemente devuelve un &lt;code&gt;data.frame&lt;/code&gt; con los valores de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; guardados en el modelo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(42)
df &amp;lt;- data.frame(x = seq(0, 360, length.out = 100))
df$y &amp;lt;- with(df, 5*cos(x*pi/180) + 3*sin(x*pi/180*3) + 1.6*rnorm(100))

ggplot(df, aes(x, y)) +
   geom_point() +
   geom_smooth(method = &amp;quot;FFTSmooth&amp;quot;, method.args = list(n = 0.2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;¬°Y listo! üç∞&lt;/p&gt;

&lt;p&gt;S√≥lo hace falta definir &lt;code&gt;predictdf.my_smooth()&lt;/code&gt; una vez. Por ejemplo, si queremos usar una Spline.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;SplineSmooth &amp;lt;- function(formula, data, weights, span = 0.5, ...) {
   pred &amp;lt;- smooth.spline(data$x, data$y, df = length(data$y)*span,...)$y
   # print(pred[1:10])
   model &amp;lt;- list(x = data$x, pred = pred)
   class(model) &amp;lt;- &amp;quot;my_smooth&amp;quot;
   model
}

ggplot(df, aes(x, y)) +
   geom_point() +
   geom_smooth(method = &amp;quot;SplineSmooth&amp;quot;, method.args = list(span = 0.1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Un resultado similar puede conseguirse de manera m√°s directa con &lt;a href=&#34;../../2018/05/como-hacer-un-stat-generico-en-ggplot2/&#34;&gt;&lt;code&gt;stat_rasa()&lt;/code&gt;&lt;/a&gt;, pero me pareci√≥ interesante urgar un poco dentro del funcionamiento de ggplot2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Arte reproducible del Subte de Buenos Aires</title>
      <link>https://eliocamp.github.io/codigo-r/2018/05/arte-reproducible-del-subte-de-buenos-aires/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://eliocamp.github.io/codigo-r/2018/05/arte-reproducible-del-subte-de-buenos-aires/</guid>
      <description>&lt;p&gt;El s√°bado pasado est√°bamos en el subte con mi novia y pasamos por la estaci√≥n √Ångel Gallardo de la L√≠nea B y notamos que ten√≠a &lt;a href=&#34;http://www.buenosaires.gob.ar/noticias/arte-urbano-en-la-estacion-angel-gallardo&#34;&gt;unas ilustraciones&lt;/a&gt; en las paredes hechas a partir de l√≠neas de distinto grosor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../images/subte.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Charlamos un poco sobre ese estilo y c√≥mo se pod√≠a replicar con &lt;code&gt;ggplot2&lt;/code&gt; usando el paquete &lt;a href=&#34;https://github.com/clauswilke/ggridges&#34;&gt;&lt;code&gt;ggridges&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lo primero que hago es leer la imagen. Este paso depende del formato (a menos que haya alguna forma de seleccionar el formato correcto autom√°ticamente, pero no conozco). La funci√≥n &lt;code&gt;readJPEG&lt;/code&gt; del paquete &lt;code&gt;jpeg&lt;/code&gt; convierte una imagen en un array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;im &amp;lt;- jpeg::readJPEG(&amp;quot;../../static/images/example.jpg&amp;quot;)
str(im)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  num [1:400, 1:400, 1:3] 1 1 1 1 1 1 1 1 1 1 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La imagen es de 400x400 y tiene 3 canales (rojo, verde y azul). Lo que voy a hacer es pasarla a escala de grises y luego transformar los datos en un data.frame para poder graficarlo con &lt;code&gt;ggplot2&lt;/code&gt;. El &amp;ldquo;algoritmo&amp;rdquo; que uso ac√° para pasar de color a grises es simplemente sumar la intensidad de cada color y luego dividir por 3. No s√© si es la manera m√°s correcta, pero funciona. Notar que al nombrar las dimensiones del array, revierto el orden de las coordenadas y con &lt;code&gt;rev&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;im &amp;lt;- apply(im, c(1, 2), sum)   # para cada valor de las primeras 2 dimensiones, suma
im &amp;lt;- im/3

ys &amp;lt;- nrow(im)
xs &amp;lt;- ncol(im)
dimnames(im) &amp;lt;- list(y = rev(seq_len(nrow(im))), x = seq_len(ncol(im)))
im &amp;lt;- reshape2::melt(im)
str(im)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## &#39;data.frame&#39;:	160000 obs. of  3 variables:
##  $ y    : int  400 399 398 397 396 395 394 393 392 391 ...
##  $ x    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ value: num  1 1 1 1 1 1 1 1 1 1 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora que tengo un lindo data.frame, puedo graficarlo. La idea es, para cada l√≠nea horizontal (es decir, cada valor de y), graficar un √°rea blanca cuya altura sea proporcional al valor de gris. Adem√°s, s√≥lo voy a graficar cada 10 l√≠neas para bajar un poco la resoluci√≥n y se note m√°s el efecto.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
library(ggridges)
plotim &amp;lt;- subset(im, y  %in% seq(1, ys, by = 10))
ggplot(plotim, aes(x, y)) +
   geom_ridgeline(aes(height = value*9, group = y), 
                  fill = &amp;quot;white&amp;quot;, color = NA) +
   theme(panel.background = element_rect(fill = &amp;quot;black&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-20-arte-reproducible-del-subte-de-buenos-aires_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Le falta pulir algunas cosas, pero va bien!&lt;/p&gt;

&lt;p&gt;La imagen del subte que quiero reproducir en realidad no usa l√≠neas rectas sino sinusoidales. No estoy seguro si eso se puede reproducir con &lt;code&gt;geom_ridgeline()&lt;/code&gt; pero a esta altura decid√≠ meterme con un geom de m√°s bajo nivel. Usando &lt;code&gt;geom_ribbon()&lt;/code&gt; puedo poner directamente cu√°l es el m√°ximo y el m√≠nimo del √°rea, entonces puedo meter un coseno con la amplitud, per√≠odo y fase que quiera. Adem√°s, como esto es Arte&lt;sup&gt;&amp;trade;&lt;/sup&gt;, conviene sacar las leyendas y los ejes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;scale &amp;lt;- 10
per  &amp;lt;- 6
phase &amp;lt;- 0.001
ampl &amp;lt;- scale/5
forecolor &amp;lt;- &amp;quot;white&amp;quot;
backcolor &amp;lt;- &amp;quot;#110C0E&amp;quot;

ggplot(subset(im, y %in% seq(1, ys, by = scale - 1)), aes(x)) +
   geom_ribbon(aes(ymin = y + ampl*cos(x/max(x)*2*pi*per - phase*y) - value*scale/2, 
                   ymax = y + ampl*cos(x/max(x)*2*pi*per - phase*y) + value*scale/2,
                   group = y), fill = forecolor) +
   scale_x_continuous(expand = c(0, 0)) +
   scale_y_continuous(expand = c(0, 0)) +
   coord_equal() +
   theme_void() +
   theme(plot.background = element_rect(fill = backcolor))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-20-arte-reproducible-del-subte-de-buenos-aires_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;S√≥lo para que sea m√°s divertido, ac√° abajo est√° el c√≥digo completo, armado en una funci√≥n y que adem√°s permite hacer un efecto medio warholiano si se usan los 3 colores en vez de una escala de grises.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Ridgefy &amp;lt;- function(file, scale = 10, ampl = 1/5, per = 6, phase = 0,
                    forecolor = &amp;quot;white&amp;quot;, backcolor = &amp;quot;black&amp;quot;, ncol = 3) {
   im &amp;lt;- jpeg::readJPEG(file)
   ys &amp;lt;- nrow(im)
   xs &amp;lt;- ncol(im)
   if (length(forecolor) == 3) {
      dimnames(im) &amp;lt;- list(y = rev(seq_len(ys)),
                           x = seq_len(xs),
                           forecolor = forecolor)
      im &amp;lt;- reshape2::melt(im)
   } else {
      im &amp;lt;- apply(im, c(1, 2), sum)
      im &amp;lt;- im/max(im)
      
      dimnames(im) &amp;lt;- list(y = rev(seq_len(ys)), 
                           x = seq_len(xs))
      im &amp;lt;- reshape2::melt(im)
      im$forecolor = forecolor
   }

   ampl &amp;lt;- scale*ampl
   
   ggplot(subset(im, y %in% seq(1, ys, by = scale - 1)), aes(x)) +
      geom_ribbon(aes(ymin = y + ampl*cos(x/max(x)*2*pi*per - phase*y) - value*scale/2, 
                      ymax = y + ampl*cos(x/max(x)*2*pi*per - phase*y) + value*scale/2,
                      group = y,
                      fill = forecolor)) +
      scale_fill_manual(values = forecolor, guide = FALSE) +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      coord_equal() +
      theme_void() +
      facet_wrap(~forecolor, ncol = ncol) +
      theme(plot.background = element_rect(fill = backcolor), 
            panel.spacing = unit(0, &amp;quot;lines&amp;quot;),
            strip.text = element_blank(),
            strip.background = element_blank())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para terminar, por qu√© no hacer una imagen bien meta y usar este estilo para transformar la imagen original que me dio la idea.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Ridgefy(&amp;quot;../../static/images/subte.jpg&amp;quot;, scale = 4, ampl = 0.1,
        forecolor = &amp;quot;#EE0000&amp;quot;, 
        backcolor = &amp;quot;#6E1414&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-20-arte-reproducible-del-subte-de-buenos-aires_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Como hacer un stat gen√©rico en ggplot2</title>
      <link>https://eliocamp.github.io/codigo-r/2018/05/como-hacer-un-stat-generico-en-ggplot2/</link>
      <pubDate>Wed, 16 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://eliocamp.github.io/codigo-r/2018/05/como-hacer-un-stat-generico-en-ggplot2/</guid>
      <description>&lt;p&gt;Hace un tiempo que ven√≠a pensando que si bien &lt;code&gt;ggplot2&lt;/code&gt; es genial y tiene un mont√≥n de geoms y stats, le faltaba la opci√≥n de extenderlo a stats y geoms creados por el usuario. Luego, aprend√≠ que &lt;code&gt;ggplot2&lt;/code&gt; tiene un excelente sistema para extenderlo y empec√© a crear mis propios stats. Pero a√∫n as√≠, hacer un &lt;code&gt;stat&lt;/code&gt; espec√≠fico cada vez que uno quiere hacer un plot en particular es demasiado complicado.&lt;/p&gt;

&lt;p&gt;Entonces se me ocurri√≥ una posible soluci√≥n. Hacer un &lt;code&gt;stat&lt;/code&gt; &lt;em&gt;gen√©rico&lt;/em&gt;; una tabula rasa que acepte una funci√≥n creada por el usuario. Nativamente &lt;code&gt;ggplot2&lt;/code&gt; viene con &lt;code&gt;stat_summary()&lt;/code&gt; que hace algo similar, pero s√≥lo acepta funciones que (como su nombre lo indica) sumaricen los datos de alguna manera. Lo que yo quer√≠a era algo totalmente gen√©rico y este es mi primer intento.&lt;/p&gt;

&lt;p&gt;Debajo, es el c√≥digo de &lt;code&gt;stat_rasa()&lt;/code&gt;, que toma los datos y una funci√≥n que devuelva un data.frame interpretable por el &lt;code&gt;geom&lt;/code&gt; elegido.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# ggproto object
StatRasa &amp;lt;- ggplot2::ggproto(&amp;quot;StatRasa&amp;quot;, ggplot2::Stat,
  compute_group = function(data, scales, fun, fun.args) {
     # Change default arguments of the function to the 
     # values in fun.args
     args &amp;lt;- formals(fun)
     for (i in seq_along(fun.args)) {
        if (names(fun.args[i]) %in% names(fun.args)) {
           args[[names(fun.args[i])]] &amp;lt;- fun.args[[i]]
        } 
     }
     formals(fun) &amp;lt;- args
     
     # Apply function to data
     fun(data)
})

# stat function used in ggplot
stat_rasa &amp;lt;- function(mapping = NULL, data = NULL,
                      geom = &amp;quot;point&amp;quot;, 
                      position = &amp;quot;identity&amp;quot;,
                      fun = NULL,
                      ...,
                      show.legend = NA,
                      inherit.aes = TRUE) {
   # Check arguments 
   if (!is.function(fun)) stop(&amp;quot;fun must be a function&amp;quot;)
   
   # Pass dotted arguments to a list
   fun.args &amp;lt;- match.call(expand.dots = FALSE)$`...`
   
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = StatRasa,
      geom = geom,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      check.aes = FALSE,
      check.param = FALSE,
      params = list(
         fun = fun, 
         fun.args = fun.args,
         na.rm = FALSE,
         ...
      )
   )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por ejemplo, si queremos r√°pidamente visualizar los datos menos sin la tendencia, podemos crear una funci√≥n relativamente simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Detrend &amp;lt;- function(data, method = &amp;quot;lm&amp;quot;, span = 0.2) {
   if (method == &amp;quot;lm&amp;quot;) {
      data$y &amp;lt;- resid(lm(y ~ x, data = data))
   } else {
      data$y &amp;lt;- resid(loess(y ~ x, span = span, data = data))
   }
   as.data.frame(data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y luego obtener los residuos en una sola l√≠nea.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
set.seed(42)
x &amp;lt;- seq(-1, 3, length.out = 30)
y &amp;lt;- x^2 + rnorm(30)*0.5
df &amp;lt;- data.frame(x = x, y = y)
ggplot(df, aes(x, y)) +
   geom_line() +
   stat_rasa(geom = &amp;quot;line&amp;quot;, fun = Detrend, method = &amp;quot;smooth&amp;quot;,
             color = &amp;quot;steelblue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Si queremos un poco m√°s de legibilidad, podemos hacer una funci√≥n con un nombre m√°s informativo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;stat_detrend &amp;lt;- function(...) {
   stat_rasa(fun = Detrend, ...)
}

ggplot(df, aes(x, y)) +
   geom_line() +
   stat_detrend(method = &amp;quot;lm&amp;quot;, color = &amp;quot;blue&amp;quot;, geom = &amp;quot;line&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Otro caso es el de calcular contornos a partir de una grilla irregular. &lt;code&gt;ggplot2::stat_contour()&lt;/code&gt; usa &lt;code&gt;grDevices::contourLines()&lt;/code&gt; para computar los contornos y requiere una grilla regular y el paquete &lt;code&gt;contoureR&lt;/code&gt; tiene una funci√≥n que acepta una grilla irregular. Para usarla sin problemas lo √∫nico que tenemos que hacer es armar una peque√±a funci√≥n y usar &lt;code&gt;geom = &amp;quot;path&amp;quot;&lt;/code&gt; en &lt;code&gt;stat_rasa()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;IrregularContour &amp;lt;- function(data, breaks = scales::fullseq, 
                             binwidth = NULL,
                             bins = 10) {
   if (is.function(breaks)) {
      # If no parameters set, use pretty bins to calculate binwidth
      if (is.null(binwidth)) {
         binwidth &amp;lt;- diff(range(data$z)) / bins
      }
      
      breaks &amp;lt;- breaks(range(data$z), binwidth)
   }
   
   cl &amp;lt;- contoureR::getContourLines(x = data$x, y = data$y, z = data$z, 
                                    levels = breaks)
   
   if (length(cl) == 0) {
      warning(&amp;quot;Not possible to generate contour data&amp;quot;, call. = FALSE)
      return(data.frame())
   }
   cl &amp;lt;- cl[, 3:7]
   colnames(cl) &amp;lt;- c(&amp;quot;piece&amp;quot;, &amp;quot;group&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;level&amp;quot;)
   return(cl)
}

stat_contour_irregular &amp;lt;- function(...) {
   stat_rasa(fun = IrregularContour, geom = &amp;quot;path&amp;quot;, ...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(42)
df &amp;lt;- data.frame(x = rnorm(500),
                 y = rnorm(500))
df$z &amp;lt;- with(df, -x*y*exp(-x^2 - y^2))

ggplot(df, aes(x, y)) +
   geom_point(aes(color = z)) +
   stat_contour_irregular(aes(z = z, color = ..level..), bins = 15) +
   scale_color_viridis_c()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Y voil√†.&lt;/p&gt;

&lt;p&gt;Quedan algunos detalles para mejorar, como por ejemplo la posibilidad de utilizar una funci√≥n para decidir los par√°metros a usar de acuerdo a los datos, pero creo que as√≠ como est√° sirve para el 80% de las aplicaciones simples. Tambi√©n deber√≠a ponerle un mejor nombre, pero nombrar cosas es muy dif√≠cil.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to make a generic stat in ggplot2</title>
      <link>https://eliocamp.github.io/codigo-r/2018/05/how-to-make-a-generic-stat-in-ggplot2/</link>
      <pubDate>Wed, 16 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://eliocamp.github.io/codigo-r/2018/05/how-to-make-a-generic-stat-in-ggplot2/</guid>
      <description>&lt;p&gt;For a while now I&amp;rsquo;ve been thinking that, yes, &lt;code&gt;ggplot2&lt;/code&gt; is awesome and offers a lot of &lt;code&gt;geoms&lt;/code&gt; and &lt;code&gt;stats&lt;/code&gt;, but it would be great if it could be extended with new user-generated &lt;code&gt;geoms&lt;/code&gt; and &lt;code&gt;stats&lt;/code&gt;. Then I learnt that &lt;code&gt;ggplot2&lt;/code&gt; actually has a pretty great extension system so I could create my own geoms I needed for my work or &lt;a href=&#34;https://twitter.com/d_olivaw/status/993669229810503680&#34;&gt;just for fun&lt;/a&gt;. But still, creating a geom from scratch is an involved process that doesn&amp;rsquo;t lend itself to simple transformations.&lt;/p&gt;

&lt;p&gt;Finally, I thought of a possible solution: create a &lt;em&gt;generic&lt;/em&gt; &lt;code&gt;stat&lt;/code&gt; &amp;ndash;a tabula rasa, if you will&amp;ndash; that can work on the data with any function. Natively &lt;code&gt;ggplot2&lt;/code&gt; offers &lt;code&gt;stat_summary()&lt;/code&gt;, but it&amp;rsquo;s only meant to be used with, well, summary statistics. What I wanted was something completely generic and this is my first try.&lt;/p&gt;

&lt;p&gt;Below is the code for &lt;code&gt;stat_rasa()&lt;/code&gt; (better name pending). It works just like any other &lt;code&gt;stat&lt;/code&gt; except that it works with any function that takes a data.frame and returns a transformed data.frame that can be interpreted by the chosen &lt;code&gt;geom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# ggproto object
StatRasa &amp;lt;- ggplot2::ggproto(&amp;quot;StatRasa&amp;quot;, ggplot2::Stat,
  compute_group = function(data, scales, fun, fun.args) {
     # Change default arguments of the function to the 
     # values in fun.args
     args &amp;lt;- formals(fun)
     for (i in seq_along(fun.args)) {
        if (names(fun.args[i]) %in% names(fun.args)) {
           args[[names(fun.args[i])]] &amp;lt;- fun.args[[i]]
        } 
     }
     formals(fun) &amp;lt;- args
     
     # Apply function to data
     fun(data)
})

# stat function used in ggplot
stat_rasa &amp;lt;- function(mapping = NULL, data = NULL,
                      geom = &amp;quot;point&amp;quot;, 
                      position = &amp;quot;identity&amp;quot;,
                      fun = NULL,
                      ...,
                      show.legend = NA,
                      inherit.aes = TRUE) {
   # Check arguments 
   if (!is.function(fun)) stop(&amp;quot;fun must be a function&amp;quot;)
   
   # Pass dotted arguments to a list
   fun.args &amp;lt;- match.call(expand.dots = FALSE)$`...`
   
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = StatRasa,
      geom = geom,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      check.aes = FALSE,
      check.param = FALSE,
      params = list(
         fun = fun, 
         fun.args = fun.args,
         na.rm = FALSE,
         ...
      )
   )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, let&amp;rsquo;s say we want to quickly glance at detrended data. We then create a very simple function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Detrend &amp;lt;- function(data, method = &amp;quot;lm&amp;quot;, span = 0.2) {
   if (method == &amp;quot;lm&amp;quot;) {
      data$y &amp;lt;- resid(lm(y ~ x, data = data))
   } else {
      data$y &amp;lt;- resid(loess(y ~ x, span = span, data = data))
   }
   as.data.frame(data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and pass it to &lt;code&gt;stat_rasa()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
set.seed(42)
x &amp;lt;- seq(-1, 3, length.out = 30)
y &amp;lt;- x^2 + rnorm(30)*0.5
df &amp;lt;- data.frame(x = x, y = y)
ggplot(df, aes(x, y)) +
   geom_line() +
   stat_rasa(geom = &amp;quot;line&amp;quot;, fun = Detrend, method = &amp;quot;smooth&amp;quot;,
             color = &amp;quot;steelblue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2.en_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can get better legibility and less typing by creating a wrapper function with a more descriptive name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;stat_detrend &amp;lt;- function(...) {
   stat_rasa(fun = Detrend, ...)
}

ggplot(df, aes(x, y)) +
   geom_line() +
   stat_detrend(method = &amp;quot;lm&amp;quot;, color = &amp;quot;blue&amp;quot;, geom = &amp;quot;line&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2.en_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Another case could be calculating contours from an irregular grid. Since &lt;code&gt;ggplot2::stat_contour()&lt;/code&gt; uses &lt;code&gt;grDevices::contourLines()&lt;/code&gt;, it needs values defined in a regular grid, but there&amp;rsquo;s a package called &lt;code&gt;contoureR&lt;/code&gt; that can compute contours from irregularly spaced observations. With &lt;code&gt;stat_rasa()&lt;/code&gt; we can integrate it with &lt;code&gt;ggplot2&lt;/code&gt; effortlessly by creating a small function and using &lt;code&gt;geom = &amp;quot;path&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;IrregularContour &amp;lt;- function(data, breaks = scales::fullseq, 
                             binwidth = NULL,
                             bins = 10) {
   if (is.function(breaks)) {
      # If no parameters set, use pretty bins to calculate binwidth
      if (is.null(binwidth)) {
         binwidth &amp;lt;- diff(range(data$z)) / bins
      }
      
      breaks &amp;lt;- breaks(range(data$z), binwidth)
   }
   
   cl &amp;lt;- contoureR::getContourLines(x = data$x, y = data$y, z = data$z, 
                                    levels = breaks)
   
   if (length(cl) == 0) {
      warning(&amp;quot;Not possible to generate contour data&amp;quot;, call. = FALSE)
      return(data.frame())
   }
   cl &amp;lt;- cl[, 3:7]
   colnames(cl) &amp;lt;- c(&amp;quot;piece&amp;quot;, &amp;quot;group&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;level&amp;quot;)
   return(cl)
}

stat_contour_irregular &amp;lt;- function(...) {
   stat_rasa(fun = IrregularContour, geom = &amp;quot;path&amp;quot;, ...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(42)
df &amp;lt;- data.frame(x = rnorm(500),
                 y = rnorm(500))
df$z &amp;lt;- with(df, -x*y*exp(-x^2 - y^2))

ggplot(df, aes(x, y)) +
   geom_point(aes(color = z)) +
   stat_contour_irregular(aes(z = z, color = ..level..), bins = 15) +
   scale_color_viridis_c()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2.en_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And voil√†.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s always things to improve. For example, the possibility of using a custom function to compute parameters that depend on the data, but I believe that as it stands covers 80% of simple applications. I should also use a better name, but naming things is hard work.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>