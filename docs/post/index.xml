<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Código R</title>
    <link>/post/</link>
    <description>Recent content in Posts on Código R</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <lastBuildDate>Tue, 25 May 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>La nueva pipa</title>
      <link>/2021/05/r-pipa-nativa/</link>
      <pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/2021/05/r-pipa-nativa/</guid>
      <description>
&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Este post quizás llega un poco tarde pero hace poco salió la versión 4.1.0 de R.
Y si la versión 4.0.0 hizo noticia con el revolucionario cambio de &lt;code&gt;stringAsFactors = FALSE&lt;/code&gt;, la gran novedad de esta siguiente versión es la implementación de una “pipa” nativa.&lt;/p&gt;
&lt;div id=&#34;la-nueva-pipa&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;La nueva pipa&lt;/h2&gt;
&lt;p&gt;La “pipa” (traducción no muy buena de “pipe” en inglés) es una de las principales distinciones del código que usa tidyverse / dplyr.
Seguro que alguna vez usaste o viste algo como&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr) 

mtcars %&amp;gt;%
   group_by(cyl) %&amp;gt;% 
   summarise(mpg = mean(mpg)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##     cyl   mpg
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     4  26.7
## 2     6  19.7
## 3     8  15.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ese &lt;code&gt;%&amp;gt;%&lt;/code&gt; es el operador que permite encadenar una función tras otra sin neceisdad de asignar variables a pasos intermedios.
Técnicamente lo que hace es evaluar la expresión de la derecha (o, más usualmente, la de abajo) usando como primer argumento, la expresión d la izquierda (arriba).
El paquete dplyr depende del paquete magrittr para hacer esa magia.
Y muchos otros paquetes también importan la pipa de magrittr.&lt;/p&gt;
&lt;p&gt;Con la versión 4.1.0, ahora es posible escribir&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars |&amp;gt;
   group_by(cyl) |&amp;gt;
   summarise(mpg = mean(mpg))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##     cyl   mpg
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     4  26.7
## 2     6  19.7
## 3     8  15.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;¿Cuál es la diferencia, aparte de un caracter menos?
(No que la cantidad de caracteres importe mucho si uno usa el atajo de RStudio Ctrl + Shitf + M. Y con la nueva versión de RStudio &lt;a href=&#34;https://web.archive.org/web/20210525152348/https://www.rstudio.com/products/rstudio/download/preview/&#34;&gt;que ahora está en preview&lt;/a&gt;, se puede elegir cuál usar.)&lt;/p&gt;
&lt;p&gt;La principal, para mí, es que se puede usar la pipa sin depender del paquete magrittr.
Quizás esto no sea algo que te quite el sueño, pero como regla general siempre está bueno que tus análisis dependan de la menor cantidad de paquetes distintos, de manera que haya menos posibilidades de que alguno cambie algo importante y se rompa todo.&lt;/p&gt;
&lt;p&gt;Para quienes usan dplyr (o quienes van por lo fácil y empiezan con &lt;code&gt;library(tidyverse)&lt;/code&gt;) usar &lt;code&gt;|&amp;gt;&lt;/code&gt; o &lt;code&gt;%&amp;gt;%&lt;/code&gt; probablemente sea indistinto.
Pero hay todo un multiverso por fuera del tidyverso.
Yo, por ejemplo, prefiero data.table a dplyr y mi sintaxis preferida combina data.table con magrittr.
Con este cambio, ya no necesito empezar cada script con &lt;code&gt;library(magrittr)&lt;/code&gt; (aunque ver [la siguiente seccion]).&lt;/p&gt;
&lt;p&gt;Pará quienes tienen una (¿insana?) obsesión con la velocidad y la eficiencia, &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;a href=&#34;https://michaelbarrowman.co.uk/post/the-new-base-pipe/&#34;&gt;parecer ser más rápida&lt;/a&gt; que &lt;code&gt;%&amp;gt;%&lt;/code&gt;.
Esto es porque magrittr hace un montón de cosas detrás de escena, mientras que la pipa nativa es solo una transformación de sintaxis.
En otras palabras,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x %&amp;gt;%
   mean()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;no es literalmente equivalente a &lt;code&gt;mean(x)&lt;/code&gt;; hay todo un inverso de procesamiento adentro de esos tres caracteres.
Mientas que&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x |&amp;gt; 
   mean()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Es interpretado por R exactamente como &lt;code&gt;mean(x)&lt;/code&gt;.
Es decir, hay cero “overhead” por usar &lt;code&gt;|&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Pero la realidad es que salvo casos especiales, la diferencia es despreciable.
En cualquier análisis de datos que valga la pena, el overhead de usar magrittr es minúsculo en comparación con el tiempo que toma hacer (¡y escribir!) el resto de los cómputos.
Mi consejo es no prestarle demasiada atención a diferencias del orden del microsegundo.&lt;/p&gt;
&lt;p&gt;Lo que sí hay que prestarle atención es a las diferencias sutiles (o no tanto) entre ambas pipas.
La más jodida de todas es que la pipa de magrittr tiene una forma de usar un “placeholder” para cuando uno no quiere que el resultado de la parte izquierda vaya al &lt;em&gt;primer&lt;/em&gt; argumento de la expresión de la derecha.
El ejemplo canónico es el modelo lineal:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
   lm(mpg ~ disp, data = .)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ disp, data = .)
## 
## Coefficients:
## (Intercept)         disp  
##    29.59985     -0.04122&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como el primer argumento de &lt;code&gt;lm()&lt;/code&gt; no es los datos, hay que usar &lt;code&gt;data = .&lt;/code&gt; para decirle a magrittr que &lt;code&gt;datos&lt;/code&gt; no tiene que ser el primer argumento de &lt;code&gt;lm()&lt;/code&gt;.
La pipa nativa por ahora &lt;strong&gt;no tiene placeholder&lt;/strong&gt;.
La forma para solucionar eso es creando una función anónima:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars |&amp;gt; 
   (function(x) lm(mpg ~ cyl, data = x))()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ cyl, data = x)
## 
## Coefficients:
## (Intercept)          cyl  
##      37.885       -2.876&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esto es bastante feito, por lo que la propuesta de R es usar otro truco de R 4.1.0: la nueva sintaxis para crear funciones.
Desde R 4.1.0 estas dos expresiones son equivalentes:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;function(x) x + 1 
\(x) x + 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La nueva sintaxis del monigote saludando ( &lt;code&gt;\(x)&lt;/code&gt;) esencialmente ahorra caracteres a la hora de crear funciones.
Por lo que combinando esto con la pipa nativa, se puede hacer&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars |&amp;gt; 
   (\(x) lm(mpg ~ disp, data = x))()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ disp, data = x)
## 
## Coefficients:
## (Intercept)         disp  
##    29.59985     -0.04122&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;que es marginalmente más legible, aunque aún todavía bastante feo.
La sintaxis alternativa, que creo que por ahora está en veremos, es esta:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Sys.setenv(`_R_USE_PIPEBIND_` = TRUE) 
mtcars |&amp;gt; 
   . =&amp;gt; lm(mpg ~ disp, data = .)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ disp, data = mtcars)
## 
## Coefficients:
## (Intercept)         disp  
##    29.59985     -0.04122&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Donde la primera línea es indispensable.)&lt;/p&gt;
&lt;p&gt;Como se ve, primero se establece dice cuál es símbolo “placeholder” (en este caso &lt;code&gt;.&lt;/code&gt;) y luego del &lt;code&gt;=&amp;gt;&lt;/code&gt;, se puede escribir el mismo código que usaría en la pipa de magrittr.
En resumen, para los casos donde se usa el &lt;code&gt;.&lt;/code&gt; de placeholder, el reemplazo de &lt;code&gt;%&amp;gt;%&lt;/code&gt; sería &lt;code&gt;|&amp;gt; . =&amp;gt;&lt;/code&gt;.
(Aunque, de nuevo, entiendo que esta sintaxis no es definitiva ni oficial.)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;y-data.table&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;¿Y data.table?&lt;/h2&gt;
&lt;p&gt;Lo cual me lleva a mi amada sintaxis de data.table + magrittr:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars &amp;lt;- data.table::as.data.table(mtcars)
mtcars %&amp;gt;% 
   .[, .(mpg = mean(mpg)), by = cyl]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    cyl      mpg
## 1:   6 19.74286
## 2:   4 26.66364
## 3:   8 15.10000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dado que el punto que está al principio de la primera línea no es nada menos que el placeholder de magrittr y que la nueva pipa no tiene placeholder, está más que claro que esta sintaxis no va a funcionar simplemente cambiando &lt;code&gt;%&amp;gt;%&lt;/code&gt; por &lt;code&gt;|&amp;gt;&lt;/code&gt;.
También hay algunas limitaciones, como que la nueva pipa no acepta “símbolos especiales” como &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt; o &lt;code&gt;*&lt;/code&gt; en la expresión derecha.&lt;/p&gt;
&lt;p&gt;En vista de lo anterior, uno pensaría que el cambio sería agregar &lt;code&gt;|&amp;gt; . =&amp;gt;&lt;/code&gt; , pero no:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars |&amp;gt; 
   . =&amp;gt; .[, .(mpg = mean(mpg)), by = cyl]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error: function &amp;#39;[&amp;#39; not supported in RHS call of a pipe&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ah, aparece la limitación de esos símbolos especiales.
¿Y ahora?&lt;/p&gt;
&lt;p&gt;El truco es que R se fija en el nombre de la función, así que lo único que hay que hacer es renombrar la función &lt;code&gt;[&lt;/code&gt; (amo que en R todo sea una función).
Por ejemplo, este código es perfectamente funcional:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;.d &amp;lt;- `[` 

mtcars |&amp;gt; 
   .d(, .(mpg = mean(mpg)), by = cyl) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    cyl      mpg
## 1:   6 19.74286
## 2:   4 26.66364
## 3:   8 15.10000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lo cual no es tan malo.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;larga-vida-a-magrittr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Larga vida a magrittr&lt;/h2&gt;
&lt;p&gt;Entonces, ¿tengo que desechar a &lt;code&gt;%&amp;gt;%&lt;/code&gt; y amar a &lt;code&gt;|&amp;gt;&lt;/code&gt;?
Y… no necesariamente.&lt;/p&gt;
&lt;p&gt;R 4.1.0 salío hace un par de semanas y es muy probable que la mayor parte de la gente no hay actualizado ni tenga planes de actualizar pronto.
En ambientes corporativos o en servidores, muchas personas que usan R probablemente ni siquiera tengan control sobre la versión que tienen y quienes lo administran sean bastante reticentes de actualizar.
Código “en producción” corriendo en versiones específicas de R en pos de estabilidad y reproducibilidad probablemente tarden años en actualizarse, si es que se actualizan.&lt;/p&gt;
&lt;p&gt;Por todo esto, si bien el reino de magrittr ya tiene los días contados, todavía está lejos de terminar.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Analizando ratings de Star Trek en IMDB</title>
      <link>/2021/03/star-trek-rakings/</link>
      <pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/2021/03/star-trek-rakings/</guid>
      <description>
&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Con mi novia estamos viendo Star Trek: The Next Generation. La primera temporada es bastante mala, pero luego remonta. Me dio curiosidad si los ratings mostraban eso. Entonces empecé a bajar los ratings de cada capítulo en IMDB. En el medio, me encontré que IMDB provee ratings promedio por demografía, así que decidí también bajar eso.&lt;/p&gt;
&lt;p&gt;Y ya que estamos, bajé también los ratings de las otras series de Star Trek.&lt;/p&gt;
&lt;div id=&#34;scrapeando-o-escrapeando-los-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Scrapeando (¿o escrapeando?) los datos&lt;/h2&gt;
&lt;p&gt;Primero, cargo las librerías. data.table para el análisis de datos, magrittr para cadenitas, rvest para scrapear y ggplot2 para visualizar los resultados. ggsci es una librería con muchas escalas de colores para ggplot2 y la cargo para usar la única escala que es razonable usar en un post como este: &lt;code&gt;scale_color_startrek()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(data.table)
library(rvest)
library(magrittr)
library(ggplot2)
library(ggsci)

theme_set(theme_minimal(14) + 
             theme(panel.grid = element_blank()))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Luego funciones para scrapear ratings. Cada serie tiene &lt;a href=&#34;https://www.imdb.com/title/tt0060028/&#34;&gt;una página&lt;/a&gt; donde se listan las temporadas. &lt;code&gt;get_series()&lt;/code&gt; detecta esos links y scrapea cada temporada con &lt;code&gt;get_season()&lt;/code&gt;&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_series_ &amp;lt;- function(id) {
   home_url &amp;lt;- paste0(&amp;quot;https://www.imdb.com/title/&amp;quot;, id)
   message(&amp;quot;Series: &amp;quot;, id)
   seasons &amp;lt;- html_session(home_url) %&amp;gt;% 
      html_nodes(&amp;quot;#title-episode-widget div:nth-child(4) a&amp;quot;) %&amp;gt;% 
      html_text() %&amp;gt;% 
      rev()
   
   data &amp;lt;- lapply(seasons, function(x) get_season(id, x))
   
   rbindlist(data)
}

get_series &amp;lt;- memoise::memoise(get_series_, 
                               cache = memoise::cache_filesystem(&amp;quot;data/star_trek/&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La &lt;a href=&#34;https://www.imdb.com/title/tt0060028/episodes?season=1&#34;&gt;página de cada temporada&lt;/a&gt; tiene una tabla con los capítulos y el rating medio de cada uno. Como también quiero los ratings en detalle, la función busca los links de cada capítulo y le scrapea los detalles con &lt;code&gt;get_details_episode()&lt;/code&gt; .&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_season_ &amp;lt;- function(id, season) {
   message(&amp;quot;Season: &amp;quot;, season)
   url &amp;lt;- paste0(&amp;quot;https://www.imdb.com/title/&amp;quot;, id, &amp;quot;/episodes?season=&amp;quot;, season)
   
   session &amp;lt;- rvest::html_session(url)
   
   titles &amp;lt;- rvest::html_nodes(session, &amp;quot;#episodes_content strong a&amp;quot;) %&amp;gt;% 
      html_attr(&amp;quot;title&amp;quot;) %&amp;gt;% 
      na.omit()
   
   stars &amp;lt;- rvest::html_nodes(session, &amp;quot;.ipl-rating-star.small .ipl-rating-star__rating&amp;quot;) %&amp;gt;% 
      html_text()
   
   if (length(stars) == 0) {
      return(NULL)
   }
   dates &amp;lt;- rvest::html_nodes(session, &amp;quot;.airdate&amp;quot;) %&amp;gt;% 
      html_text() %&amp;gt;% 
      lubridate::dmy()
   
   links &amp;lt;- html_nodes(session, &amp;quot;#episodes_content strong a&amp;quot;) %&amp;gt;% 
      html_attr(&amp;quot;href&amp;quot;) 
   
   links &amp;lt;- links[links != &amp;quot;#void&amp;quot;]
   
   ids &amp;lt;- strsplit(links, &amp;quot;/&amp;quot;) %&amp;gt;% 
      vapply(function(x) x[3], character(1))
   
   rating_details &amp;lt;- lapply(ids, get_details_episode)
   
   data &amp;lt;- data.table::data.table(date = dates, 
                                  number = seq_along(titles),
                                  title = titles,
                                  rating = as.numeric(stars), 
                                  season = season,
                                  details = rating_details
   )
}

get_season &amp;lt;- memoise::memoise(get_season_, 
                               cache = memoise::cache_filesystem(&amp;quot;data/star_trek/&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finalmente, &lt;code&gt;get_details_episode()&lt;/code&gt; entra a &lt;a href=&#34;https://www.imdb.com/title/tt0059753/ratings&#34;&gt;la página de ratings de un episodio&lt;/a&gt; y scrapea la distribución de ratings, el rating promedio por género y la cantidad de ratings por género.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_details_episode &amp;lt;- function(id) {
   url &amp;lt;- paste0(&amp;quot;https://www.imdb.com/title/&amp;quot;, id, &amp;quot;/ratings&amp;quot;)
   
   session &amp;lt;- html_session(url) 
   
   ratings &amp;lt;- session %&amp;gt;% 
      html_nodes(&amp;quot;td:nth-child(3) .leftAligned&amp;quot;) %&amp;gt;% 
      html_text() %&amp;gt;% 
      trimws() %&amp;gt;% 
      gsub(&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;, .) %&amp;gt;% 
      as.numeric()
   
   ratings_gender &amp;lt;- session %&amp;gt;% 
      html_nodes(&amp;quot;table:nth-child(11) .ratingTable:nth-child(2) .bigcell&amp;quot;) %&amp;gt;% 
      html_text() %&amp;gt;% 
      as.numeric()
   
   number_gender &amp;lt;- session %&amp;gt;% 
      html_nodes(&amp;quot;table:nth-child(11) .ratingTable:nth-child(2) a&amp;quot;) %&amp;gt;% 
      html_text() %&amp;gt;% 
      trimws() %&amp;gt;% 
      gsub(&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;, .) %&amp;gt;% 
      as.numeric()
   
   data.table::data.table(gender = list(data.table::data.table(gender = c(&amp;quot;All&amp;quot;, &amp;quot;Males&amp;quot;, &amp;quot;Females&amp;quot;),
                                                               rating = ratings_gender,
                                                               N = number_gender)),
                          ratings = list(data.table::data.table(rating = 10:1,
                                                                N = ratings))
   )
   
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finalmente, manualmente busqué los ids las distintas versiones de Star Trek.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;star_treks &amp;lt;- c(tos        = &amp;quot;tt0060028&amp;quot;,
                tng        = &amp;quot;tt0092455&amp;quot;,
                ds9        = &amp;quot;tt0106145&amp;quot;,
                voyager    = &amp;quot;tt0112178&amp;quot;,
                enterprise = &amp;quot;tt0244365&amp;quot;,
                discovery  = &amp;quot;tt5171438&amp;quot;
)

labs_st &amp;lt;- setNames(
   c(&amp;quot;The Original Series&amp;quot;, 
     &amp;quot;The Next Generation&amp;quot;,
     &amp;quot;Deep Space 9&amp;quot;,
     &amp;quot;Voyager&amp;quot;, 
     &amp;quot;Enterprise&amp;quot;,
     &amp;quot;Discovery&amp;quot;),
   names(star_treks))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y a cada una le aplico &lt;code&gt;get_series()&lt;/code&gt; y combino todo fila a fila con &lt;code&gt;data.table::rbindlist()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- lapply(star_treks, get_series) %&amp;gt;% 
   rbindlist(idcol = &amp;quot;version&amp;quot;) %&amp;gt;% 
   .[, episode := 1:.N, by = version] %&amp;gt;%
   .[, version := factor(version, levels = names(star_treks), ordered = TRUE)]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esta es la pinta de los datos:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    version       date number                        title rating season
## 1:     tos 1988-11-27      1                     The Cage    7.7      1
## 2:     tos 1966-09-08      2                 The Man Trap    7.3      1
## 3:     tos 1966-09-15      3                    Charlie X    7.1      1
## 4:     tos 1966-09-22      4 Where No Man Has Gone Before    7.8      1
## 5:     tos 1966-09-29      5               The Naked Time    7.9      1
## 6:     tos 1966-10-06      6             The Enemy Within    7.7      1
##              details episode
## 1: &amp;lt;data.table[1x2]&amp;gt;       1
## 2: &amp;lt;data.table[1x2]&amp;gt;       2
## 3: &amp;lt;data.table[1x2]&amp;gt;       3
## 4: &amp;lt;data.table[1x2]&amp;gt;       4
## 5: &amp;lt;data.table[1x2]&amp;gt;       5
## 6: &amp;lt;data.table[1x2]&amp;gt;       6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cada fila es un episodio, que tiene la versión de Star Trek a la que pertenece, la fecha de emisión, y otros datos. Hasta ahí simple. Se complica un poco en la columna &lt;code&gt;details&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data[1, ]$details[[1]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               gender            ratings
## 1: &amp;lt;data.table[3x3]&amp;gt; &amp;lt;data.table[10x2]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cada fila contiene una lista que contiene dos tablas, “gender” y “ratings”. La tabla “gender” tiene el rating promedio y el número de valoraciones para cada género.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data[1, ]$details[[1]]$gender[[1]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     gender rating    N
## 1:     All    7.7 5344
## 2:   Males    7.7 3390
## 3: Females    7.7  470&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La tabla “ratings” tiene el número de valoraciones para cada rating numérico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data[1, ]$details[[1]]$ratings[[1]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     rating    N
##  1:     10  991
##  2:      9  644
##  3:      8 1447
##  4:      7 1271
##  5:      6  577
##  6:      5  220
##  7:      4   73
##  8:      3   40
##  9:      2   32
## 10:      1   49&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este formato de &lt;a href=&#34;https://rstudio.com/resources/rstudioconf-2020/list-columns-in-data-table-reducing-the-cognitive-computational-burden-of-complex-data/&#34;&gt;tablas anidadas&lt;/a&gt; es complicado al principio, pero es bastante natural para ciertos datos.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;analizando-los-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Analizando los datos&lt;/h2&gt;
&lt;p&gt;Ahora que tengo todos los datos, lo primero que me interesa es la pregunta original. ¿Cómo evolucionó la recepción de The Next Generation a lo largo de las temporadas?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data[version == &amp;quot;tng&amp;quot;] %&amp;gt;% 
   ggplot(aes(episode, rating)) +
   geom_line(aes(color = season, group = 1)) +
   geom_line(data = function(x) copy(x)[, rating := mean(rating), by = season],
             aes(color = season), size = 1) +
   scale_color_startrek(guide = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2021-03-01-star-trek-ratings_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;(Notar el truquito en el segundo &lt;code&gt;geom_line()&lt;/code&gt;. El argumento &lt;code&gt;data&lt;/code&gt; de los geoms puede ser una función que se aplica al dataframe con el dato global. En este caso, reemplazo a rating por el rating medio por cada temporada.)&lt;/p&gt;
&lt;p&gt;El efecto está bastante claro. Las primeras dos temporadas fueron bastante mediocres y recién para la tercera, el programa mejora. Y la calidad se mantiene más o menos estable hasta una pequeña recaída en la última temporada. Mientras escribo esto, mi novia y yo estamos por la mitad de la 5ta temporada, así que no puedo emitir opinión sobre esa última temporada.&lt;/p&gt;
&lt;p&gt;Muy notable es el lo mal recibido que fue el último capítulo de la segunda temporada. Y con buena razón. Es un capítulo &lt;a href=&#34;https://en.wikipedia.org/wiki/Shades_of_Gray_(Star_Trek:_The_Next_Generation)&#34;&gt;hecho con clips de otros capítulos&lt;/a&gt;, porque los productores se quedaron sin plata y tuvieron que hacer el capítulo bien barato y rápido. Es increíble que los fans hayan decidido seguir viendo la serie luego de un final de temporada tan abismal.&lt;/p&gt;
&lt;p&gt;¿Cómo se compara TNG con las demás versiones de Star Trek?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data %&amp;gt;% 
   ggplot(aes(episode, rating)) +
   geom_line(aes(color = season, group = 1)) +
   geom_line(data = function(x) copy(x)[, rating := mean(rating), by = .(version, season)],
             aes(color = season), size = 1) +
   scale_color_startrek(guide = &amp;quot;none&amp;quot;) +
   facet_wrap(~version, scales = &amp;quot;free_x&amp;quot;, labeller = labeller(version = labs_st))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2021-03-01-star-trek-ratings_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Parece que es algo común que Star Trek mejore con el tiempo. Además de The Next Generation, Deep Space 9, Voyager y y Enterprise también alcanzaron su mejor momento luego de las primeras temporadas. The Original Series y Discovery son las dos excepciones. En ambas series, la recepción popular bajó mucho en la tercera temporada.&lt;/p&gt;
&lt;p&gt;¿La caída de Discovery es igual a la de The Original Series? Vi la tercera temporada de Discovery y no me pareció particularmente peor que las anteriores. Y vivir en este siglo no sólo significa que los capítulos lentísimos de TOS me resultaron un bodrio, sino que viví la reacción popular de Discovery y sé que fue víctima de la polarización extrema que domina estos tiempos. Sintomático de esto es la enorme diferencia entre la recepción de la crítica y los votos de la audiencia. En Rotten Tomatoes, la tercera temporada de Discovery es la mejor ranqueada, &lt;a href=&#34;https://www.rottentomatoes.com/tv/star_trek_discovery/s03&#34;&gt;con un 90%&lt;/a&gt;, a pesar de que los votos de la audiencia le da 46%. Lo mismo se ve en &lt;a href=&#34;https://www.metacritic.com/tv/star-trek-discovery&#34;&gt;Metacritic&lt;/a&gt;: el promedio de la crítica –7.3– es mucho mayor que el de les usuaries –3.8.&lt;/p&gt;
&lt;p&gt;En particular, se da mucho que cuando ciertas películas o series ofenden a alguna subcultura en particular, aparecen miles de trolls poniendo 1 estrella en masa. Esto se ve claramente ploteando la proporción de 1s y 10s en cada episodio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data[, details[[1]]$ratings[[1]], by = .(version, season, episode, number)] %&amp;gt;% 
   .[, .(one_star = N[rating == 1]/sum(N),
         ten_star = N[rating == 10]/sum(N)), by = .(episode, version)] %&amp;gt;% 
   melt(id.vars = c(&amp;quot;episode&amp;quot;, &amp;quot;version&amp;quot;)) %&amp;gt;% 
   ggplot(aes(episode, value)) +
   geom_line(aes(color = variable)) +
   scale_color_startrek(name = &amp;quot;Rating %&amp;quot;, labels = c(one_star = &amp;quot;One Star&amp;quot;, 
                                                      ten_star = &amp;quot;Ten Stars&amp;quot;)) +
   facet_wrap(~version, scales = &amp;quot;free_x&amp;quot;, labeller = labeller(version = labs_st))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2021-03-01-star-trek-ratings_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Salvo excepciones, ningún capítulo tiene una cantidad apreciable de unos en las series viejas. Discovery, en cambio, tiene un ~10% de malos votos, que incluso superan a los votos de 10 estrellas en últimos capítulos.&lt;/p&gt;
&lt;p&gt;Un dato interesante que tiene IMDB es la división por género. La ciencia ficción es un género bastante dominado por los hombres, ¿se ve reflejado esto en la cantidad de ratings?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data %&amp;gt;% 
   .[, details[[1]]$gender[[1]] , by = .(version, season, episode, number)] %&amp;gt;% 
   .[gender != &amp;quot;All&amp;quot;] %&amp;gt;%
   .[, .(n = sum(N)), by = .(episode, version, gender)] %&amp;gt;% 
   ggplot(aes(episode, n)) +
   geom_line(aes(color = gender)) + 
   scale_color_startrek() +
   scale_y_log10() +
   facet_wrap(~version, scales = &amp;quot;free_x&amp;quot;, labeller = labeller(version = labs_st))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2021-03-01-star-trek-ratings_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sí! definitivamente. Tuve que usar una escala logarítmica para que se distinguieran las líneas con la cantidad de calificaciones de mujeres.&lt;/p&gt;
&lt;p&gt;Es interesante cómo en todas las versiones, y para ambos géneros, se ve una tendencia de descenso en la cantidad de ratings a medida que avanza la serie. Me imagino que es un efecto de supervivencia. Muchas personas empezarán a mirar cada versión desde el principio y luego se aburrirán y dejarán de verla. Entonces es natural que haya más gente en general dispuesta a calificar los primeros capítulos.&lt;/p&gt;
&lt;p&gt;En cuanto a la distribución de género, la cantidad de calificaciones en cada episodio parece ser más o menos constante, con la obvia excepción de cuatro capítulos de Enterprise que tienen casi tantas calificaciones de mujeres como de hombres.&lt;/p&gt;
&lt;p&gt;Estos son los 10 capítulos con mayor proporción de calificaciones femeninas:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data %&amp;gt;% 
   .[, details[[1]]$gender[[1]] , by = .(version, season, episode, number)] %&amp;gt;% 
   .[gender != &amp;quot;All&amp;quot;] %&amp;gt;%
   .[, .(n = sum(N)), by = .(episode, version, gender)] %&amp;gt;% 
   dcast(episode + version ~ gender, value.var = &amp;quot;n&amp;quot;) %&amp;gt;% 
   .[, ratio := Females/Males] %&amp;gt;% 
   
   data[., on = .NATURAL] %&amp;gt;% 
   .[order(-ratio)] %&amp;gt;%
   .[1:10] %&amp;gt;% 
   .[, .(version, season, number, title, rating, ratio = scales::percent(ratio, accuracy = 0.1))] %&amp;gt;% 
   knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;version&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;season&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;number&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;title&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;rating&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;enterprise&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Home&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;83.5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;enterprise&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Shockwave, Part II&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;68.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;enterprise&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Regeneration&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;enterprise&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Broken Bow&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.9&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;51.6%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The Trouble with Tribbles&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.9&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;18.9%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;voyager&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Retrospect&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;17.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;voyager&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;25&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Resolutions&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;16.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;voyager&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Blood Fever&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;16.5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;19&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Requiem for Methuselah&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;16.5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tos&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Journey to Babel&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;16.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Nunca vi Enterprise ni conozco de qué van esos 4 capítulos aparentemente tan populares entre las mujeres, así que no sabría decir por qué tienen (relativamente) tantas calificaciones femeninas.&lt;/p&gt;
&lt;p&gt;Es difícil comparar la proporción de calificaciones de hombres y de mujeres en la figura anterior, así que mejor plotear directamente el porcentaje de calificaciones femeninas por capítulo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data %&amp;gt;% 
   .[, details[[1]]$gender[[1]] , by = .(version, season, episode, number)] %&amp;gt;% 
   .[gender != &amp;quot;All&amp;quot;] %&amp;gt;%
   .[, .(n = sum(N)), by = .(episode, version, gender)] %&amp;gt;% 
   dcast(episode + version ~ gender, value.var = &amp;quot;n&amp;quot;) %&amp;gt;% 
   .[, run := scales::rescale(episode, to = c(0, 1)), by = version] %&amp;gt;% 
   ggplot(aes(run, Females/Males)) +
   geom_line(aes(color = version)) +
   scale_y_log10() +
   scale_color_startrek( labels = labs_st) +
   coord_cartesian(ylim = c(NA, 0.2)) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2021-03-01-star-trek-ratings_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Además de los picos de Enterprise, lo más notorio es la brutal caída en la proporción de votos femeninos en la tercera temporada de Discovery, ¿qué pasó ahí? Mi hipótesis es que la horda de trolls que fue a calificar con 1 estrella por alguna ofensa percibida eran en su mayoría hombres.&lt;/p&gt;
&lt;p&gt;En general, dejando de lado esos episodios anómalos de Enterprise, The Original Series es la serie más votada por mujeres casi empatada con Voyager. Las diferencias, de todas formas, no son grandes y en la medida de que estos números sean representativos del público de Star Trek en general (importante suposición), la audiencia de esta serie es más de 80% hombres.&lt;/p&gt;
&lt;p&gt;Esto en cuanto a la cantidad, ¿hay diferencias en las calificaciones promedio entre hombres y mujeres?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data %&amp;gt;% 
   .[, details[[1]]$gender[[1]] , by = .(version, season, episode, number)] %&amp;gt;% 
   .[gender != &amp;quot;All&amp;quot;] %&amp;gt;%
   ggplot(aes(episode, rating)) +
   geom_line(aes(color = gender))  +
   scale_color_startrek() + 
   facet_wrap(~version, scales = &amp;quot;free_x&amp;quot;, labeller = labeller(version = labs_st))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2021-03-01-star-trek-ratings_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Hay, pero poca. En general, las mujeres tienden a puntuar de forma más positiva que los hombres. Esto quizás tiene que ver con que, siendo Star Trek una serie dirigida principalmente hacia los hombres, las mujeres que ven la serie y encima se toman el trabajo de ir a IMDB a calificarla, son un grupo más autoseleccionado. Los capítulos con gran proporción de calificaciones femeninas en Enterprise no parecen que hayan recibido particularmente mejor calificación por parte de las mujeres.&lt;/p&gt;
&lt;p&gt;Eso sí, Discovery sobresale de nuevo. La diferencia parece más pronunciada al principio de la serie, y terriblemente obvia hacia el final. Las mujeres calificaron, en promedio, los capítulos de la tercera temporada de Discovery con el mismo valor que las temporadas anteriores. El gran cambio se dio en las calificaciones masculinas. Esto es consistente con mi teoría de la mayoría masculina en el grupo ofendido por Discovery.&lt;/p&gt;
&lt;p&gt;Para finalmente cuantificar el “efecto troll”, voy a usar que tanto la cantidad como la calificación media de las mujeres se mantuvo más o menos constante. Asumiendo entonces que esta subpoblación mantuvo su comportamiento a lo largo de las temporadas, voy a ajustar un modelo lineal que predice la cantidad de valoraciones de hombres a partir de la cantidad de valoraciones de mujeres. Luego, al comparar la cantidad de calificaciones reales con la predicción, se puede tener una idea del número de calificaciones “extra”.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;discovery_ratings &amp;lt;- data %&amp;gt;% 
   .[, details[[1]]$gender[[1]] , by = .(version, season, episode, number)] %&amp;gt;% 
   # .[gender != &amp;quot;All&amp;quot;] %&amp;gt;%
   .[, .(n = sum(N)), by = .(episode, version, season, gender)] %&amp;gt;% 
   .[version == &amp;quot;discovery&amp;quot;] %&amp;gt;%
   dcast(version + episode + season ~ gender, value.var = &amp;quot;n&amp;quot;) 

model &amp;lt;- discovery_ratings %&amp;gt;% 
   .[episode &amp;lt;= 20] %&amp;gt;% 
   lm(Males ~ Females-1, data = .)

discovery_ratings[, predicted := predict(model, newdata = discovery_ratings)]

extra &amp;lt;- discovery_ratings %&amp;gt;% 
   .[, .(Males = sum(Males),
         Females = sum(Females),
         predicted = sum(predicted)), by = .(version, season)]

discovery_ratings %&amp;gt;% 
   ggplot(aes(Females, Males)) +
   
   geom_segment(data = ~.x[season == 3], aes(xend = Females, yend = predicted)) +
   geom_point(aes(color = season)) +
   # geom_line(aes(color = season, y = predicted)) +
   
   geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~ x-1, data = ~.x[episode &amp;lt; 20], fullrange = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2021-03-01-star-trek-ratings_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Esos puntos azules que están por encima de la recta representan las calificaciones extra por parte de hombres en la tercera temporada. En total son 5138 calificaciones, o un 25% de las calificaciones totales hechas por hombres.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Notar que uso &lt;code&gt;memoise&lt;/code&gt; para guardar los resultados en cache. Esto sirve para no molestar tanto a IMDB y hacer las cosas más rápido durante el desarrollo y testeo de la función.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Obligué a un bot a escuchar más de 1000 horas de Rammstein y le pedí que escribiera una canción propia.</title>
      <link>/2019/12/rammbot-un-bot-que-crea-canciones-de-rammstein/</link>
      <pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/12/rammbot-un-bot-que-crea-canciones-de-rammstein/</guid>
      <description>


&lt;p&gt;Cuando le conté a una amiga que &lt;a href=&#34;../2019/11/rammstein-vs-lacrimosa/&#34;&gt;había analizado las letras de Rammstein y Lacrimosa&lt;/a&gt;, me tiró la idea de usar un modelo para crear letras de las bandas. Me pareció una idea divertida, así que acá tienen el futuro de la música:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(data.table)
library(magrittr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Igual que hice antes, bajo las letras de losdiscos de estudio de cada artista. Guardo las cosas en un archivo para no tener que bajar los datos cada vez que corro esto. Además de bajar las letras, uso textcat para determinar el idioma de las letras (no todas estásn en alemán).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lacrimosa &amp;lt;- data.table(
  album = c(&amp;quot;Angst&amp;quot;, &amp;quot;Einsemkeit&amp;quot;, &amp;quot;Satura&amp;quot;, &amp;quot;Inferno&amp;quot;, &amp;quot;Stille&amp;quot;, &amp;quot;Elodia&amp;quot;, &amp;quot;Fassade&amp;quot;, &amp;quot;Echos&amp;quot;, 
            &amp;quot;Lichtgestalt&amp;quot;, &amp;quot;Sehnsucht&amp;quot;, &amp;quot;Revolution&amp;quot;, &amp;quot;Hoffnung&amp;quot;, &amp;quot;Testimonium&amp;quot;),
  year = c(1991, 1992, 1993, 1995, 1997, 1999, 2001, 2003,
           2005, 2009, 2012, 2015, 2017)
)

rammstein &amp;lt;- data.table(
  album = c(&amp;quot;Herzeleid&amp;quot;, &amp;quot;Sehnsucht&amp;quot;, &amp;quot;Mutter&amp;quot;, &amp;quot;Reise Reise&amp;quot;, &amp;quot;Rosenrot&amp;quot;, 
            &amp;quot;Liebe ist fur alle da&amp;quot;,  &amp;quot;Rammstein&amp;quot;),
  year = c(1995, 1997, 2001, 2004, 2005, 2009, 2019)
)

albums &amp;lt;- rbindlist(list(Lacrimosa = lacrimosa, 
                         Rammstein = rammstein), 
                    idcol = &amp;quot;artist&amp;quot;)
cache &amp;lt;- here::here(&amp;quot;content&amp;quot;, &amp;quot;post&amp;quot;, &amp;quot;data&amp;quot;, &amp;quot;letras.Rds&amp;quot;)

if (file.exists(cache)) {
  lyrics &amp;lt;- readRDS(cache)
} else {
  lyrics &amp;lt;-  albums %&amp;gt;% 
    genius::add_genius(artist, album) %&amp;gt;% 
    as.data.table() %&amp;gt;% 
    .[artist == &amp;quot;Lacrimosa&amp;quot; &amp;amp; album == &amp;quot;Sehnsucht&amp;quot;, album := &amp;quot;Sehnsucht (L)&amp;quot;]  %&amp;gt;% 
    .[, lang := textcat::textcat(paste0(lyric, collapse = &amp;quot;\n&amp;quot;)), by = .(track_title, artist)] %&amp;gt;% 
    na.omit()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora a los bifes. El bot lo voy a hacer como una cadena de Markov. Lo que signfica es que toma una palabra y luego elije la siguiente al azar usando la probabilidad condicional de cada palabra. Es decir, ¿cuál es la probabilidad de que a esta palabra le siga esta otra? Como ejemplo, voy a trabajar con las letras de Rammstein (y que estén en alemán) y a partir de eso voy a armar una función generalizable.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;corpus &amp;lt;- lyrics[lang == &amp;quot;german&amp;quot; &amp;amp; artist == &amp;quot;Rammstein&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para delimitar las estrofas voy a usar puntuación. Entonces voy a primero detectar qué líneas terminan con un punto, signo de pregunta o exlamación y agregar un punto a las que NO terminan con puntuación.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;corpus &amp;lt;- corpus %&amp;gt;% 
  .[, has_punct := grepl(&amp;quot;^[\\w\\s]+[?.!]$&amp;quot;, lyric, perl = TRUE)] %&amp;gt;% 
  .[has_punct == FALSE, lyric := paste0(lyric, &amp;quot;.&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Luego, con la magia de tidytext separo las palabras (sin eliminar la puntuación), creo una columna que es la palabra siguiente y luego calculo, para cada par de palabras, la probabilida de que a una palabra le siga la otra.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;freq &amp;lt;- corpus %&amp;gt;% 
  tidytext::unnest_tokens(word, lyric, strip_punct = FALSE) %&amp;gt;% 
  as.data.table()  %&amp;gt;% 
  .[, next_word := shift(word, type = &amp;quot;lead&amp;quot;)] %&amp;gt;% 
  na.omit() %&amp;gt;% 
  .[, n_word := .N, by = .(word)] %&amp;gt;%        # número de veces que aparece la palabra (para normalizar)
  .[, .(n_next_word = .N, n_word = n_word[1]), by = .(word, next_word)] %&amp;gt;% 
  .[, prob := n_next_word/n_word] %&amp;gt;%                
  .[n_word &amp;gt; 5] %&amp;gt;%                          # me quedo con las palabras que aparecen más de 5 veces
  .[order(-prob)]

head(freq)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         word next_word n_next_word n_word prob
## 1: verderben         .          10     10    1
## 2:      boot         .           6      6    1
## 3:   riechst        so          14     14    1
## 4: hinterher         .           7      7    1
## 5:     sache       und           6      6    1
## 6:      jede     nacht           7      7    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora, armo una función que a partir de una palabra, selecciona la siguiente:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;next_word &amp;lt;- function(prev_word) {
  if (prev_word %in% freq$word) {
    next_word &amp;lt;- freq[word == prev_word] %&amp;gt;% 
      .[, sample(next_word, size = 1, prob = prob)]   # Samplea 1 palabra sigiente usando la probabilidad calculada arriba
  } else {
    # Si la palabra no aparece...
    next_word &amp;lt;- freq %&amp;gt;% 
      .[, sample(word, 1)]        # Elegir cualquiera aleatoriametne pero según su frecuencia. 
  }
  
  return(next_word)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por ejemplo,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;next_word(&amp;quot;ich&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;bin&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora, sobre esa funcion, armo otra que a partir de una palabra inicial va agregando palabras hasta encontrarse con un signo de puntuación (que indica que se termina el verso). Además, le agrego un truco recursivo por si la cadena de palabras se hace demasiado larga.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;verse &amp;lt;- function(first_word = NULL, n_max = 20) {
  if (is.null(first_word)) {
    first_word &amp;lt;- first_words[, sample(word, size = 1, prob = N)]
  }
  
  verse &amp;lt;- tolower(first_word)
  word_candidate &amp;lt;- verse
  
  end_verse &amp;lt;- FALSE
  n &amp;lt;- 1
  while(end_verse == FALSE &amp;amp;&amp;amp; n &amp;lt; n_max) {
    word_candidate &amp;lt;- next_word(word_candidate)
    
    if (n == 1) {
      verse &amp;lt;- R.utils::capitalize(verse)
    }
    
    end_verse &amp;lt;- grepl(&amp;quot;[?.!]$&amp;quot;, word_candidate, perl = TRUE)
    punctuation &amp;lt;- grepl(&amp;quot;[[:punct:]]&amp;quot;, word_candidate)
    
    if (punctuation) {
      verse &amp;lt;- paste0(verse, word_candidate)
    } else {
      verse &amp;lt;- paste0(verse, &amp;quot; &amp;quot;, word_candidate)
    }
    n &amp;lt;- n + 1
  }
  
  # Si no llegó a un final, volvé a tratar. 
  if (n == n_max) {
    verse &amp;lt;- verse(first_word = first_word, n_max = n_max)
  }
  verse
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por ejemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;verse(&amp;quot;ich&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Registered S3 method overwritten by &amp;#39;R.oo&amp;#39;:
##   method        from       
##   throw.default R.methodsS3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Ich nirgendwo schreien.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;¿Qué palabra puedo usar para empezar? En principio podría usar cualquiera que aparezca en el corpus, pero para hacer las cosas un poco más fáciles voy a seleccionar especialmente palabras iniciales. Me voy a agarrar una lista de “primeras palabras” y computar también su frecuencia.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;first_words &amp;lt;- corpus %&amp;gt;% 
  copy() %&amp;gt;% 
  .[, id := 1:.N] %&amp;gt;% 
  .[, tidytext::unnest_tokens(.SD, word, lyric, strip_punct = FALSE), by = id] %&amp;gt;% 
  .[, .SD[1], by = id] %&amp;gt;% 
  .[, .N, by = word]

head(first_words)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         word  N
## 1:     wollt  4
## 2:       ihr 13
## 3: rammstein 25
## 4:      doch 46
## 5:       sex 11
## 6:     liebe 14&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(43543) # para reproducibilidad
verse(first_words[, sample(word, 1, prob = N)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Wir sind nicht.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;“No somos”. Mh… profundo.&lt;/p&gt;
&lt;p&gt;En fin. Ahora a empaquetar todo eso en una sola función que crea un bot a partir de un corpus. La mayoría del código es el mismo de arriba. La función que devuelve toma una semilla (opcional) y un número de versos para generar una estrofa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;make_lyric_bot &amp;lt;- function(corpus) {
  corpus &amp;lt;- as.data.table(na.omit(corpus))
  
  first_words &amp;lt;- corpus %&amp;gt;% 
    .[, id := 1:.N] %&amp;gt;% 
    .[, tidytext::unnest_tokens(.SD, word, lyric, strip_punct = FALSE), by = id] %&amp;gt;% 
    .[, .SD[1], by = id] %&amp;gt;% 
    .[, .N, by = word]
  
  freq &amp;lt;- corpus %&amp;gt;% 
    copy() %&amp;gt;% 
    .[, has_punct := grepl(&amp;quot;^[\\w\\s]+[?.!]$&amp;quot;, lyric, perl = TRUE)] %&amp;gt;% 
    .[has_punct == FALSE, lyric := paste0(lyric, &amp;quot;.&amp;quot;)] %&amp;gt;% 
    tidytext::unnest_tokens(word, lyric, strip_punct = FALSE) %&amp;gt;% 
    as.data.table()  %&amp;gt;% 
    .[, next_word := shift(word, type = &amp;quot;lead&amp;quot;)] %&amp;gt;% 
    na.omit() %&amp;gt;% 
    .[, n_word := .N, by = .(word)] %&amp;gt;%               # número de veces que aparece la palabra (para normalizar)
    .[, .(n_next_word = .N, n_word = n_word[1]), by = .(word, next_word)] %&amp;gt;% 
    .[, prob := n_next_word/n_word] %&amp;gt;%                
    .[n_word &amp;gt; 5] %&amp;gt;%                                    # me quedo con las palabras que aparecen más de 5 veces
    .[order(-prob)]
  
  
  next_word &amp;lt;- function(prev_word) {
    if (prev_word %in% freq$word) {
      next_word &amp;lt;- freq[word == prev_word] %&amp;gt;% 
        .[, sample(next_word, size = 1, prob = prob)]     # Samplea 1 palabra sigiente usando la probabilidad calculada arriba
    } else {
      # Si la palabra no aparece...
      next_word &amp;lt;- freq %&amp;gt;% 
        .[, sample(word, 1)]          # Elegir cualquiera aleatoriametne pero según su frecuencia. 
    }
    
    return(next_word)
  }
  
  verse &amp;lt;- function(first_word = NULL, n_max = 20) {
    if (is.null(first_word)) {
      first_word &amp;lt;- first_words[, sample(word, size = 1, prob = N)]
    }
    
    verse &amp;lt;- tolower(first_word)
    word_candidate &amp;lt;- verse
    
    end_verse &amp;lt;- FALSE
    n &amp;lt;- 1
    while(end_verse == FALSE &amp;amp;&amp;amp; n &amp;lt; n_max) {
      word_candidate &amp;lt;- next_word(word_candidate)
      
      if (n == 1) {
        verse &amp;lt;- R.utils::capitalize(verse)
      }
      
      end_verse &amp;lt;- grepl(&amp;quot;[?.!]$&amp;quot;, word_candidate, perl = TRUE)
      punctuation &amp;lt;- grepl(&amp;quot;[[:punct:]]&amp;quot;, word_candidate)
      
      if (punctuation) {
        verse &amp;lt;- paste0(verse, word_candidate)
      } else {
        verse &amp;lt;- paste0(verse, &amp;quot; &amp;quot;, word_candidate)
      }
      n &amp;lt;- n + 1
    }
    
    # Si no llegó a un final, volvé a tratar. 
    if (n == n_max) {
      verse &amp;lt;- verse(first_word = first_word, n_max = n_max)
    }
    verse
  }
  
  function(seed = NULL, n = 4) {
    if (inherits(seed, &amp;quot;lyric&amp;quot;)) {
      seed &amp;lt;-  attr(seed, &amp;quot;seed&amp;quot;)
      assign(&amp;quot;.Random.seed&amp;quot;, seed, globalenv())
      res &amp;lt;- vapply(seq_len(n), function(x) verse(), &amp;quot;a&amp;quot;)
    } else if (is.null(seed)) {
      seed &amp;lt;- get(&amp;quot;.Random.seed&amp;quot;, globalenv(), mode = &amp;quot;integer&amp;quot;, inherits = FALSE)   
      # set.seed(seed)
      res &amp;lt;- vapply(seq_len(n), function(x) verse(), &amp;quot;a&amp;quot;)
    } else {
      res &amp;lt;- withr::with_seed(seed, vapply(seq_len(n), function(x) verse(), &amp;quot;a&amp;quot;))      
    }
    
    attr(res, &amp;quot;seed&amp;quot;) &amp;lt;- seed
    class(res) &amp;lt;- c(&amp;quot;lyric&amp;quot;, class(res))
    return(res)
  }
}

print.lyric &amp;lt;- function(x, ...) {
  x &amp;lt;- paste(paste0(&amp;quot;&amp;gt; &amp;quot;, x), collapse = &amp;quot;   \n&amp;quot;)
  cat(x)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lacribot &amp;lt;- make_lyric_bot(lyrics[lang == &amp;quot;german&amp;quot; &amp;amp; artist == &amp;quot;Lacrimosa&amp;quot;])
rammbot &amp;lt;- make_lyric_bot(lyrics[lang == &amp;quot;german&amp;quot; &amp;amp; artist == &amp;quot;Rammstein&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora estas funciones generan estrofas pseudo-lacrimosa y pseudo-rammstein:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rammbot(seed = 12345, n = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Nur die ecke immer.&lt;br /&gt;
Wir halten das bin alleine.&lt;br /&gt;
Die asche.&lt;br /&gt;
Mein teil– nein.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Estas oraciones no aprobarían una prueba de Alemán 1, pero si damos un poco de licencia poética, imaginación y agregando un poco de puntuación se podría traducir a:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sólo la esquina, siempre.&lt;br /&gt;
Creemos que estamos solos.&lt;br /&gt;
Las cenizas.&lt;br /&gt;
Mi parte - no.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Un detalle curioso es que en alemán todos los sustantivos van en mayúsculas pero en el procesamiento de los datos se las quité. Habría que cambiar el tokenizador para que no pase todo a mínúsculas, pero bueno, ya está.&lt;/p&gt;
&lt;p&gt;Otra copada:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rammbot(seed = 3123)&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Und keiner der sonne.&lt;br /&gt;
Oh weh, mutter.&lt;br /&gt;
Wie ein spiel begann zu gehen.&lt;br /&gt;
Eifersucht.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Y nadie del Sol.&lt;br /&gt;
Oh dolor, madre.&lt;br /&gt;
Como un juego, empezó a irse.&lt;br /&gt;
Celos.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;¿Y qué dice Lacribot?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lacribot(seed = 47665, n = 5)&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Dir.&lt;br /&gt;
Millionen uns beide augen brennen eine kluft mit schweren licht, ich reiße a dream has.&lt;br /&gt;
Niemand erlebt mensch zu ihr- nichts.&lt;br /&gt;
Ich sie nie sah die dich.&lt;br /&gt;
Und im wind ich dich.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ups, se me infiltró un poco de inglés.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A tí.&lt;br /&gt;
Millones de nosotros, ambos ojos queman una brecha con luz pesada, yo rompo un sueño.&lt;br /&gt;
Nadie experimenta humanamente a ella- nada.&lt;br /&gt;
Yo, ella, nunca te vi.&lt;br /&gt;
Y en el viento yo a tí.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lacribot(seed = 6)&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Keine stillen.&lt;br /&gt;
Nur diesen schmerz zerquetschte lebens.&lt;br /&gt;
Und vielleicht nicht mehr.&lt;br /&gt;
Ihn.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;No amamantar.&lt;br /&gt;
Sólo esta vida aplastada por el dolor.&lt;br /&gt;
Y quizás no más.&lt;br /&gt;
A él.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;No sé si estas funciones podrán ganar un premio, pero probablemente escriban mejor poesía que yo.&lt;/p&gt;
&lt;p&gt;Para cerrar, vamos a armar una canción de Rammstein.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(23543)
intro &amp;lt;- rammbot(n = 3)
pre_estribillo &amp;lt;- rammbot(n = 1)
estribillo &amp;lt;- rammbot()
estrofa1 &amp;lt;- rammbot()
estrofa2 &amp;lt;- rammbot()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y así de fácil, les presento el nuevo hit de Rammstein, que voy a titular “Und Frei”.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
Feuer liebt mich ganz auf die kreatur.&lt;br /&gt;Tut es wird nass fallen.&lt;br /&gt;Asche zu lebzeit in amerika).&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;
Schwuler.&lt;br /&gt;Ich die musik.&lt;br /&gt;Ohne dich).&lt;br /&gt;Verheißung sag ihr bleibt nicht dass ich hab’ das röslein ihn lesen там и тут.&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;
Laben brauch keine lust vom degen.&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;
Und frei!&lt;br /&gt;Ich werde immer wenn ich nehme in schlechten i can, was nicht sein.&lt;br /&gt;Recht wortlos auch den kleinen so kalt, du mir.&lt;br /&gt;Asche.&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;
Die liebe ist für ein.&lt;br /&gt;Du hast, benzin.&lt;br /&gt;Zwei, du sehen?&lt;br /&gt;Verlogen euch scheidet von der tiefe brunnen mehr ach scheine.&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;
Und frei!&lt;br /&gt;Ich werde immer wenn ich nehme in schlechten i can, was nicht sein.&lt;br /&gt;Recht wortlos auch den kleinen so kalt, du mir.&lt;br /&gt;Asche.&lt;br /&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;¿Alguien quiere musicalizarlo?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rammstein vs. Lacrimosa</title>
      <link>/2019/11/rammstein-vs-lacrimosa/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/11/rammstein-vs-lacrimosa/</guid>
      <description>
&lt;script src=&#34;../rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;../rmarkdown-libs/pymjs/pym.v1.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;../rmarkdown-libs/widgetframe-binding/widgetframe.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Hace un tiempo una conocida twiteó que había tenido que comprarse un libro entero para aprender los géneros gramaticales del alemán. Entre las repuestas, había una persona que contaba que de adolescente creyó (erróneamente) que podría aprender alemán sólo escuchando Rammstein. Habeindo estudiado unos drei Jahre de alemán al mismo tiempo que escuchaba Rammstein y otras bandas en alemán, las letras de Rammstein siempre me parecieron extremadamente simples. Tan simples, de hecho, que sospecho que Till Lindemann trata de escribir de forma fácil pensando en los estudiantes principantes de alemán.&lt;/p&gt;
&lt;p&gt;Decidí explorar esta idea. Para eso descargué las letras de Rammstein y medí su complejidad. Como comparación usé letras de Lacrimsoa, otra banda germanoparlante de mi juventud.&lt;/p&gt;
&lt;div id=&#34;un-poco-de-los-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Un poco de los datos&lt;/h2&gt;
&lt;p&gt;Para quienes no estén familiarizados con ambas bandas, este es el estribillo de &lt;a href=&#34;https://www.youtube.com/watch?v=StZcUAPRRac&#34;&gt;Sonne&lt;/a&gt;, de Rammstein:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Eins, hier kommt die Sonne.&lt;br /&gt;
Zwei, hier kommt die Sonne.&lt;br /&gt;
Drei, sie ist der hellste Stern von allen.&lt;br /&gt;
Vier, hier kommt die Sonne.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Más allá de las sutilezas de significado y el uso de metáforas, la estructura sintáctica es recontra simple. Para colmo, como repite los números del uno al diez una y otra vez, casi que parece una canción diseñada para que los chicos aprendan a contar.&lt;/p&gt;
&lt;p&gt;Por otro lado, este es un recorte de &lt;a href=&#34;https://www.youtube.com/watch?v=cSXaWvFFXuI&#34;&gt;Warum so Tief&lt;/a&gt;, de Lacrimosa:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Warum so tief - und warum gerade jetzt?&lt;br /&gt;
Warum vor ihr - warum diese Ironie?&lt;br /&gt;
Warum so hart - und warum nicht einfach besiegt?&lt;br /&gt;
Muss ich denn wirklich für jede Begegnung&lt;br /&gt;
für immer und ewig mit all meiner Liebe bezahlen?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Einmal ohne das eine und endgültige Gefühl - verloren zu sein&lt;br /&gt;
Nur einmal bei ihr - keine Tobsucht in Ketten&lt;br /&gt;
Doch ich kann es nicht ’mal bestreiten - dass ich euch liebe&lt;br /&gt;
Mutter Angst und Vater Schmerz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Creo que el contraste se aprecia fácilmente. En particular, los últimos dos versos de la primera estrofa arman una oración sorprendentemente larga, especialmente para ser una canción.&lt;/p&gt;
&lt;p&gt;Estos dos ejemplos están clarmaente seleccionados para ilustrar mi idea. Vamos a cuantificar la cosa analizando todas las canciones de cada banda.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;consiguiendo-los-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Consiguiendo los datos&lt;/h2&gt;
&lt;p&gt;Quiero las letras correspondientes a los discos de estudio de ambas bandas. Podría automatizar esto scrappeando, por ejemplo, los &lt;a href=&#34;https://es.wikipedia.org/wiki/Lacrimosa_(banda)&#34;&gt;artículos de wikipedia&lt;/a&gt; correspondientes, pero fue más fácil armar la lista a mano.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(data.table)
library(magrittr)
library(ggplot2)

theme_set(hrbrthemes::theme_ipsum_rc())&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lacrimosa &amp;lt;- data.table(
   album = c(&amp;quot;Angst&amp;quot;, &amp;quot;Einsemkeit&amp;quot;, &amp;quot;Satura&amp;quot;, &amp;quot;Inferno&amp;quot;, &amp;quot;Stille&amp;quot;, &amp;quot;Elodia&amp;quot;, &amp;quot;Fassade&amp;quot;, &amp;quot;Echos&amp;quot;, 
             &amp;quot;Lichtgestalt&amp;quot;, &amp;quot;Sehnsucht&amp;quot;, &amp;quot;Revolution&amp;quot;, &amp;quot;Hoffnung&amp;quot;, &amp;quot;Testimonium&amp;quot;),
   year = c(1991, 1992, 1993, 1995, 1997, 1999, 2001, 2003,
            2005, 2009, 2012, 2015, 2017)
)

rammstein &amp;lt;- data.table(
   album = c(&amp;quot;Herzeleid&amp;quot;, &amp;quot;Sehnsucht&amp;quot;, &amp;quot;Mutter&amp;quot;, &amp;quot;Reise Reise&amp;quot;, &amp;quot;Rosenrot&amp;quot;, 
             &amp;quot;Liebe ist fur alle da&amp;quot;,  &amp;quot;Rammstein&amp;quot;),
   year = c(1995, 1997, 2001, 2004, 2005, 2009, 2019)
)

albums &amp;lt;- rbindlist(list(Lacrimosa = lacrimosa, 
                         Rammstein = rammstein), 
                    idcol = &amp;quot;artist&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Luego, usé el paquete &lt;a href=&#34;https://github.com/JosiahParry/genius&#34;&gt;genius&lt;/a&gt; que descarga las letras de (sorpresa) &lt;a href=&#34;https://genius.com/&#34;&gt;Genius&lt;/a&gt;&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. Lo que hago es agregar la información de las letras al data frame anterior:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;albums &amp;lt;- albums %&amp;gt;% 
   genius::add_genius(artist, album) %&amp;gt;% 
   as.data.table() %&amp;gt;% 
   .[artist == &amp;quot;Lacrimosa&amp;quot; &amp;amp; album == &amp;quot;Sehnsucht&amp;quot;, album := &amp;quot;Sehnsucht (L)&amp;quot;]  
# (Las dos bandas tienen un album llamado Sehnsucht)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora cada fila de &lt;code&gt;albums&lt;/code&gt; es un verso de cada canción de cada artista.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT::datatable(albums) %&amp;gt;% 
   widgetframe::frameWidget()&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;htmlwidget-1&#34; style=&#34;width:100%;height:480px;&#34; class=&#34;widgetframe html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-1&#34;&gt;{&#34;x&#34;:{&#34;url&#34;:&#34;/post/2019-11-20-rammstein-vs-lacrimosa_files/figure-html//widgets/widget_unnamed-chunk-4.html&#34;,&#34;options&#34;:{&#34;xdomain&#34;:&#34;*&#34;,&#34;allowfullscreen&#34;:false,&#34;lazyload&#34;:false}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;/div&gt;
&lt;div id=&#34;legibilidad-de-las-letras-de-rammstein&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Legibilidad de las letras de Rammstein&lt;/h2&gt;
&lt;p&gt;Con estos datos voy a tratar de testear mi hipótesis. ¿Pero como? Lo que voy a hacer es calcular la &lt;a href=&#34;https://legible.es/blog/grado-smog-sol/&#34;&gt;legibilidad&lt;/a&gt; de cada letra. Mi suposición es que las letras de Rammstein van a tener menor grado de legibilidad (es decir, son más simples) que las de Lacrimosa. Una lmitación es que las formulas de legibilidad están basadas en inglés. Este problema está muy presente siempre que se analizan textos que no sean en inglés. En este caso, googleé un poco y encontŕe que la fórmula &lt;a href=&#34;https://en.wikipedia.org/wiki/SMOG&#34;&gt;SMOG&lt;/a&gt; tiene una variante adaptada al alemán que está implementada en el paquete &lt;a href=&#34;https://quanteda.io/&#34;&gt;quantea&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Relacionado con eso, no todas las canciones de estas bandas están en Alemán. La mayoría de los álbumes de Lacrimosa tienen al menos una canción en inglés (generalmente cantada por Anne Nurmi en vez de Tilo Wolff). Así que voy a tener que detectarlas y descartarlas en partes del análisis. De nuevo google me salvó, y encontré el paquete &lt;a href=&#34;https://cran.r-project.org/web/packages/textcat/index.html&#34;&gt;textcat&lt;/a&gt;, que voy a considerar una caja negra porque ya sería demasiado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Join all verses from each song
full_lyrics &amp;lt;- albums %&amp;gt;% 
   na.omit() %&amp;gt;% 
   .[, .(lyric = paste0(lyric, collapse = &amp;quot;.\n&amp;quot;) ), 
     by = .(artist, album, year, track_title)]

# Get the language
full_lyrics[, language := textcat::textcat(lyric), 
            by = .(track_title, artist, album)]

# How many songs for each language?
full_lyrics %&amp;gt;% 
   .[, .N, by = .(artist, language)] %&amp;gt;% 
   .[order(-N)] %&amp;gt;% 
   knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;artist&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;language&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;N&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Lacrimosa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;german&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Rammstein&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;german&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Lacrimosa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;english&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Rammstein&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;scots&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Lacrimosa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;scots&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Lacrimosa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;catalan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Lacrimosa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;romanian&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Lacrimosa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;finnish&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Rammstein&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;english&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Rammstein&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;portuguese&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Como era de esperarse, la gran mayoría de las canciones están en Alemán pero una parte improtante de las de Lacrimosa están en inglés. Algunas parecen mal clasificadas y tuve que mirarlas a mano. Las marcada como “scots” son canciones en inglés. Las que supuestamente están en catalán o romano son canciones instrumentales que el paquete genius no parece procesas correctamente. La que está en “portugués” es Te quiero, Puta de Rammstein que está, obviamente, en español. Finalmente, Lacrimosa efectivamente tiene una canción que está en finlandés.&lt;/p&gt;
&lt;p&gt;Cabe notar que como las canciones son poesía no tienen oraciones marcadas con punto. Tuve que asumir que cada verso es una oración.&lt;/p&gt;
&lt;p&gt;Otra limitación importante es que estas medidas de legibilidad están pensadas para prosa, no para poesía, por lo que su validez en este caso no está garantizada.&lt;/p&gt;
&lt;p&gt;Con esto, computo la legibiliad únicamente de las canciones en alemán.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;full_lyrics[language == &amp;quot;german&amp;quot;, 
            &amp;quot;SMOG&amp;quot; := quanteda::textstat_readability(lyric, measure = &amp;quot;SMOG.de&amp;quot;)$SMOG.de]

full_lyrics %&amp;gt;%  
   .[language %in% &amp;quot;german&amp;quot;] %&amp;gt;% 
   ggplot(aes(SMOG)) +
   geom_density(aes(color = artist)) +
   geom_rug(aes(color = artist)) +
   scale_color_brewer(&amp;quot;Artist&amp;quot;, palette = &amp;quot;Set1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2019-11-20-rammstein-vs-lacrimosa_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Mh.. 🤔. Hipótesis confirmada? Las letras de Rammstein definitivamente son más bien simplonas. Aunque ojo, ya que las tres canciones más complejas son de Rammstein. Esto es un poco engañoso, quizás. Esta es la canción más compleja:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;full_lyrics[which.max(SMOG)] %&amp;gt;% 
   with(cat(lyric))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Bewahret einander vor Herzeleid.
## Denn kurz ist die Zeit die ihr beisammen seid.
## Denn wenn euch auch viele Jahre vereinen.
## Einst werden sie wie Minuten euch scheinen.
## Herzeleid.
## Bewahret einander vor der Zweisamkeit&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Herzeleid es bastante corta (en términos de letra) y no es tan terriblemente complicada. Pero sí tiene varias palabras largas. Irónicamente la letra proviene de un poema tradicional que puede encontrarse colgado en muchas casas.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;../post/2019-11-20-rammstein-vs-lacrimosa_files/herzeleid.png&#34; alt=&#34;Poema Herzeleid&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Poema Herzeleid&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Algo similar para con la segunda canción más compleja (Zeig dich) que está compuesta casi exclusivamente por versos de dos palabras. Esto no me da demasiada confianza en estos resultados. Pero si vemos el otro extremo, todo tiene más sentido:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;full_lyrics[which.min(SMOG)] %&amp;gt;% 
   with(cat(lyric))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Du, du hast, du hast mich.
## Du, du hast, du hast mich.
## Du, du hast, du hast mich.
## Du, du hast, du hast mich.
## Du, du hast, du hast mich, du hast mich.
## Du hast mich gefragt, du hast mich gefragt.
## Du hast mich gefragt und ich hab&amp;#39; nichts gesagt.
## Willst du bis der Tod euch scheidet.
## Treu ihr sein für alle Tage?(Ja) Nein.
## (Ja) Nein.
## Willst du bis zum Tod, der scheide.
## Sie lieben auch in schlechten Tagen?(Ja) Nein.
## (Ja) Nein.
## Du, du hast, du hast mich.
## Du, du hast, du hast mich.
## Du, du hast, du hast mich, du hast mich.
## Du hast mich gefragt, du hast mich gefragt.
## Du hast mich gefragt und ich hab&amp;#39; nichts gesagt.
## Willst du bis der Tod euch scheidet.
## Treu ihr sein für alle Tage?(Ja) Nein.
## (Ja) Nein.
## Willst du bis zum Tod, der scheide.
## Sie lieben auch in schlechten Tagen?(Ja) Nein.
## (Ja) Nein.
## Willst du bis der Tod euch scheidet.
## Treu ihr sein(Ja) Nein.
## (Ja) Nein&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La canción más simple es Du hast. Completamente comprensible ya que es una canción bastate “boba”, al menos en lo que respecta a legibilidad. Tiene versos muy cortos, con palabras muy cortas y una estructura muy simple. Lo que el valor SMOG no captura es que que además es tremendamente repetitiva. Prácticamente tiene sólo 3 estrofas distintas!&lt;/p&gt;
&lt;p&gt;Esto resuena con mi exepriencia con ambas bandas. Rammstein sigue la estructura tradicional de canciones con estribillos, estrofas y puentes, mientras que Lacrimosa no tiene problema en usar letras más parecidas a la prosa, con poca repetición. Por ejemplo, &lt;a href=&#34;https://www.youtube.com/watch?v=qdzI88X4YZk&#34;&gt;Der Strasse der Zeit&lt;/a&gt; directamente no tiene estribillo y contando la proporción de estrofas únicas se puede ver que sólo 7% de las líneas se repiten.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;albums[track_title == &amp;quot;Die Strasse der Zeit&amp;quot;] %&amp;gt;% 
   .[, mean(duplicated(lyric))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.07017544&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y esto se puede extender a todas las canciones de la discografía de cada banda:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;albums %&amp;gt;% 
   .[, .(repetition = mean(duplicated(lyric)), .N), by = .(track_title, artist)] %&amp;gt;% 
   ggplot(aes(repetition)) +
   geom_density(aes(color = artist)) +
   geom_rug(aes(color = artist)) +
   scale_color_brewer(&amp;quot;Artist&amp;quot;, palette = &amp;quot;Set1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2019-11-20-rammstein-vs-lacrimosa_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Guau! La diferencia es increíble. Mientras que Rammstein hace canciones con más del 30% de su estrofas repetidas, muy pocas canciones de Lacrimosa repiten más del 20% de sus líneas. Es más, hay una buena cantidad de canciones de Lacrimosa que no tienen absolutamente nada de repetición!&lt;/p&gt;
&lt;p&gt;Uniendo ambas medidas, aparece una distinción bastante clara.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;full_lyrics %&amp;gt;% 
   .[language == &amp;quot;german&amp;quot;] %&amp;gt;% 
   .[, repetition := mean(duplicated(strsplit(lyric, &amp;quot;.\n&amp;quot;)[[1]])), 
     by = .(track_title, artist)] %&amp;gt;% 
   ggplot(aes(repetition, SMOG)) +
   geom_point(aes(color = artist)) +
   geom_density_2d(aes(color = artist), adjust = 1.5, bins = 4) +
   scale_color_brewer(&amp;quot;Artist&amp;quot;, palette = &amp;quot;Set1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2019-11-20-rammstein-vs-lacrimosa_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Las canciones de Rammstein son generalmente más simples y tienen muchísima más repetición.&lt;/p&gt;
&lt;p&gt;No sólo repiten líneas a lo pavote, sino que los versos en las canciones de Rammstein muchas veces ni siquiera son oraciónes completas. Esto se puede inferir usando el &lt;em&gt;log odds ratio&lt;/em&gt; entre ambos artistas para obtener pares de palabras característicamente “rammsteinianos” vs “lacrimosianos”.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;full_lyrics %&amp;gt;% 
   .[language == &amp;quot;german&amp;quot;] %&amp;gt;% 
   .[, tidytext::unnest_tokens(.SD, word, lyric, token = &amp;quot;ngrams&amp;quot;, n = 2), 
     by = .(track_title, artist)] %&amp;gt;% 
   .[, .N, by = .(word, artist)] %&amp;gt;% 
   .[!is.na(word)] %&amp;gt;% 
   tidylo::bind_log_odds(artist, word, N) %&amp;gt;% 
   .[order(-log_odds)] %&amp;gt;% 
   .[, .SD[1:10], by = artist] %&amp;gt;% 
   .[, word := tidytext::reorder_within(word, log_odds, artist)] %&amp;gt;% 
   ggplot(aes(word, log_odds)) +
   geom_col() +
   tidytext::scale_x_reordered() +
   coord_flip() +
   facet_wrap(~artist, scales = &amp;quot;free&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2019-11-20-rammstein-vs-lacrimosa_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Los pares de palabras que caracterizan a las letras de Lacrimosa son partes comunes de oraciones correctas, como “so wie” (“como”) o “das ist” (“eso es”). Las de Rammstein, en cambio, se distinguen por repetir palabras sin estructura sintáctica, como “bang bang”, “link zwo” (“izquierda dos”; el verso completo es “izquierda dos tres cuatro”) y “zwiter zwiter”.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simpleza-falta-de-calidad&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simpleza ≠ falta de calidad&lt;/h2&gt;
&lt;p&gt;Me divertí un poco aprendiendo estas herramientas básicas para la manipulación de datos textuales, pero no hay nada revolucionario en la conclusión de que las letras de Rammstein son más imples y más “cancioneras” que las de Lacrimosa. No hace falta webscapping ni R, sólo es necesario poder escuchar música.&lt;/p&gt;
&lt;p&gt;Más importane, nada dice que letras más largas y más complicadas impliquen mejores canciones. Bajo cualqueir medida, Du hast es terriblemnete simple, pero se basa en un juego de palabras interesante y en romper las expectativas.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;También hay un paquete llamado &lt;a href=&#34;https://github.com/ewenme/geniusr&#34;&gt;geniusr&lt;/a&gt; que usa la API oficial de Genius. Es preferible usar ese para uso más intensivo. Lo descubrí cuando ya había escrito casi todo el código, así que no lo cambié.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Lo que aprendí en LatinR 2019</title>
      <link>/2019/10/lo-que-aprend%C3%AD-en-latinr-2019/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/10/lo-que-aprend%C3%AD-en-latinr-2019/</guid>
      <description>


&lt;p&gt;Hace unas semanas volví de Santiago de Chile luego de ir a Latinr 2019. Igual que el año pasado, fue una experiencia divertida. Estas son algunas de las cosas que me llamaron la atención.&lt;/p&gt;
&lt;div id=&#34;workshops&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Workshops&lt;/h1&gt;
&lt;p&gt;A la mañana del primer día asistí al workshop de Mine Çetinkaya-Rundel sobre enseñanza de R. Ejemplificó algunos principios básicos a la hora de diseñar clases. La idea de “dejales comer el pastel primero” creo que es la principal enseñanza. No empezar con las nimedades aburridas de la programación, sino con un pantallazo general que muestre todo el poder de R y, en particular, R Markdown.&lt;/p&gt;
&lt;p&gt;Luego experimentamos en primera persona cómo usar &lt;a href=&#34;https://rstudio.cloud&#34;&gt;RStudio Cloud&lt;/a&gt; y el paquete &lt;a href=&#34;https://rundel.github.io/ghclass/&#34;&gt;ghclass&lt;/a&gt; para administrar un curso. Yo soy un poco reticente a depender de plataformas en “la nube” (que es el disco rígido de otro), pero aún así veo que hay muchísimo potencial. Es maravilloso poder abrir el explorador y empezar a correr R sin preocuparse por instalar cosas en las computadoras de los estudiantes. Uno se libera de los dolores de cabeza de las librerías de sistema, las diferencias entre linux, windows y mac, y no requiere una laptop potente.&lt;/p&gt;
&lt;p&gt;La noticia es que apenas una semana luego de hacer el workshop, mi novia yo yo aplicamos lo que aprendimos en una pequeña clase que dimos para una materia de la facultad. La clase fue un éxito rotundo (lo que no quiere decir que no haya cosas para mejorar). Los materiales están &lt;a href=&#34;https://docs.google.com/presentation/d/1wA89WFKhFWfd6SnoFq6a-c37dmIlMB_S1NHNbEuNtRI/edit?usp=sharing&#34;&gt;acá&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;../post/2019-10-04-lo-que-aprendí-en-latinr-2019_files/taller.jpg&#34; alt=&#34;Estudiantes en el Taller de R inspirado en Mine&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Estudiantes en el Taller de R inspirado en Mine&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Otra potencial aplicación de Rstudio Cloud es la de crear demos de paquetes. Es decir, una especie viñetas interactivas que se pueden seguir sin necesidad de instalar el paquete en la computadora. Por ejemplo, si entran al &lt;a href=&#34;https://bitly.com/ggnewscale-demo&#34;&gt;demo de ggnewscale&lt;/a&gt; se van a encontrar con un entorno que tiene el paquete &lt;a href=&#34;https://eliocamp.github.io/ggnewscale&#34;&gt;ggnewscale&lt;/a&gt; ya instalado junto con un script de ejemplo. El entorno podría incluir bases de datos de ejemplo demasiado pesadas para empaquetar en CRAN.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;charlas-que-me-resultaron-interesantes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Charlas que me resultaron interesantes&lt;/h1&gt;
&lt;p&gt;Como el congreso tuvo sesiones en paralelo, por desgracia me perdí la mitad de las charlas. Estas son sólo algunas que me llamaron la atención de la mitad a las que sí pude ir.&lt;/p&gt;
&lt;p&gt;Juan Cruz Rodriguez mostró su trabajo con el paquete &lt;a href=&#34;https://github.com/r-tensorflow/autokeras&#34;&gt;autokeras&lt;/a&gt; (&lt;strong&gt;Auto-Keras: An R easily accessible deep learning library&lt;/strong&gt;). Es la primera vez que escuché hablar sobre auto machine learning. Resulta interesante y a la vez preocupante. Es más que conocido el abuso y mal uso que se hace de los algoritmos de machine learning y lo peligroso que es usar modelos ciegamente sin apreciar las suposiciones que acarrean tanto el modelo como los datos que se usaron para entrenarlo. Por otro lado, estoy seguro que va a ser muy útil para usar como “baseline” en futuros desarrollos. Si te pasaste semanas rompiéndote el bocho desarollando la arquitectura de una red neuronal que luego es peor que una entrenada “ciegamente”, ¿vale la pena?. Claro que todo esto lo úncio que hace es pasar la discusión a otro nivel de abstracción. Ahora hay cientos de parámetros y métodos de auto machine learning. ¿Para cuando el auto auto machine learning para optimizarlos?&lt;/p&gt;
&lt;p&gt;La presentación “&lt;a href=&#34;https://www.dropbox.com/s/peq9poppxdwpn53/Presentaci%C3%B3n%20LATINR.pptx?dl=0&#34;&gt;&lt;strong&gt;¿Quienes investigan sobre género?&lt;/strong&gt;&lt;/a&gt;” de Juan Pablo Sokil me pareció refrescante porque toca el tema inverso a lo que generalmente se habla. Mostró que las publicaciones en temáticas de género están dominadas por mujeres y que los pocos hombres que publican lo hacen en áreas que tocan el género de forma secundaria, principalmente en cuestiones de medicina.&lt;/p&gt;
&lt;p&gt;Algo que me toca de cerca fue la presentación de Javier Fajardo “&lt;a href=&#34;https://docs.google.com/presentation/d/1A8yJVfiLsSHUTuILlcmk5sZPTSvDoL74S3-E5Q3kq0w/edit&#34;&gt;&lt;strong&gt;GCM compareR: una aplicación web para evaluar escenarios de cambio climático&lt;/strong&gt;&lt;/a&gt;”. Con su equipo armaron una aplicación web para comparar las salidas de los distintos miembros de los Modelos de Circulación Global. Yo justamente estoy empezando a usar los modelos climáticos del CMIP6 y me encuentro con esos problemas. Habiendo tantos modelos distintos, cada uno con varios miembros, ¿cómo elijo los mejores o el conjunto más variado? Su herramienta está pensada más para la biología que las meteorología, pero es posible que me sirva.&lt;/p&gt;
&lt;p&gt;Francisco Zambrano explicó su trabajo que, además de estar relacionado con mi área, es más munución para la guerra sobre deep learning. En “&lt;strong&gt;Predicción de la sequía agrícola en Chile: regresión lineal vs deep learning&lt;/strong&gt;” mostró los resultados de aplicar regresión lienal y deep learning en datos geoespaciales. La conclusión no es demasiado sorprendente: la regresión fue tan buena (o mala) como el deep learning. Esto va en línea con &lt;a href=&#34;https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0194889&#34;&gt;otras&lt;/a&gt; &lt;a href=&#34;https://www.sciencedirect.com/science/article/abs/pii/S0895435618310813&#34;&gt;investigaciones&lt;/a&gt; que ponen en duda la supremacía del “machine learning” sobre “métodos estadíscitos” clásicos. La moraleja es que antes de “meterle machine learning a todo”, hay que reflexionar bien sobre el tipo y la cantidad de datos que uno tiene.&lt;/p&gt;
&lt;p&gt;Siguiendo con el tema de los datos geográficos, Antonio Vazquez Brust dio una clase de ruteo en “&lt;a href=&#34;https://vsanitaria.netlify.com/#1&#34;&gt;&lt;strong&gt;Mapeando la Vulnerabilidad Sanitaria en Argentina con R&lt;/strong&gt;&lt;/a&gt;”. Se pasaron con su trabajo en crear un mapa de la distancia media a hospitales. Lo lindo fue que la charla de Antonio fue ultra didáctica, explicando paso a paso todo lo que hicieron; ¡fue casi un tutorial! Resalto la importancia de OpenStreetMaps como alternativa abierta a Google Maps. Ya tengo ganas de hacer algo parecido pero usando la red de estaciones de bicicletas públicas de la Ciudad de Buenos Aires.&lt;/p&gt;
&lt;p&gt;Finalmente, por motivos egoístas hay dos presentaciones que no podría dejar de resaltar. Mi charla se tituló “&lt;a href=&#34;https://docs.google.com/presentation/d/1bCWgydT40ZFKoD4VL7-yZBIDGM7PvWXOnIP1ocIh-HI/edit&#34;&gt;&lt;strong&gt;Si te gusta la estadística, bancate los metámeros&lt;/strong&gt;&lt;/a&gt;”, basada en &lt;a href=&#34;https://eliocamp.github.io/codigo-r/2019/01/metamerismo-estadístico/&#34;&gt;este artículo&lt;/a&gt; publicado en el blog. &lt;a href=&#34;https://paocorrales.github.io&#34;&gt;Paola Corrales&lt;/a&gt; presentó el paquete &lt;a href=&#34;https://docs.google.com/presentation/d/1lPzPhGV001I6o-O8mkyZC65ZzF3irfqwOyYc1H8FT0Y/edit#slide=id.p&#34;&gt;&lt;strong&gt;rvad: perfiles verticales de viento a partir de datos de radares meteorológicos&lt;/strong&gt;&lt;/a&gt; que desarrollamos juntos. Es la implementación de un algoritmo para obtener perfiles verticales de viento a patir de datos de radares meteorológicos.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;charlas-plenarias&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Charlas plenarias&lt;/h1&gt;
&lt;p&gt;Mine Çetinkaya-Rundel dio su charla titulada “&lt;strong&gt;R 4 All: Welcoming and inclusive practices for teaching R&lt;/strong&gt;”. Para alguien que además de usar R, le gusta enseñar R, esta charla fue excelente. Mine dio una gran cantidad de principios básicos para mejorar el ambiente de una clase o taller. Como dije arriba, mi novia y yo tuvimos la oportunidad de aplicar algunos de ellos pocos días luego de volver a Buenos Aires. El resultado fue muy bueno, me parece. Además de que fue divertido y llevadero, recibimos buen feedback directo de los estudiantes.&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;Automatic Machine Learning with H2O&lt;/strong&gt;” de Erin LeDell fue una buena oportunidad escuchar a Erin explicando cómo funciona H2O en general y e Auto Machine Learning en particular. No es algo que le vea aplicación directa en mi trabajo, pero está bueno tenerlo en mente.&lt;/p&gt;
&lt;p&gt;En “&lt;strong&gt;The many backends of dplyr&lt;/strong&gt;” Hadley Wickham mostró cómo funcionan dos paquetes que extienden la funcionalidad de dplyr para otras clases de data.frames. El paquete &lt;a href=&#34;https://dtplyr.tidyverse.org&#34;&gt;dtplyr&lt;/a&gt; permite usar los verbos de dplyr para manipular data.tables y &lt;a href=&#34;https://dbplyr.tidyverse.org&#34;&gt;dbplyr&lt;/a&gt; hace lo mismo con bases de datos. Yo soy un declarado fan de la sintaxis de &lt;a href=&#34;https://rdatatable.gitlab.io/data.table/&#34;&gt;data.table&lt;/a&gt;, pero entiendo que no sea para todos.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fuera-de-programa&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Fuera de programa&lt;/h1&gt;
&lt;p&gt;Como en toda conferencia, los eventos principales son las conversaciones informales durante el coffee break, el almuerzo y las salidas nocturnas con cerveza. 🍺&lt;/p&gt;
&lt;p&gt;Tuve la oportunidad de hablar con Hadley sobre algunos proyectos que tengo en mente. Entre otras cosas, hablamos sobre cómo tener documentación multilingüe. Hace rato que la comunidad reconoce la falta de recursos en idiomas distintos al inglés y existen varios proyectos para rellenar este bache. Están los esfuerzos de traducción de libros como &lt;a href=&#34;https://es.r4ds.hadley.nz&#34;&gt;R para ciencias de datos&lt;/a&gt;, lecciones de &lt;a href=&#34;https://github.com/Carpentries-ES&#34;&gt;The Carpentries&lt;/a&gt; y &lt;a href=&#34;https://twitter.com/search?q=%23datosdemiercoles&#34;&gt;#DatosDeMiércoles&lt;/a&gt;. Pero algo que falta es traducir la documentación técnica de los diversos paquetes del ecosistema de R. ¿Cómo hacerlo? ¿Cómo implementarlo dentro de R?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;latinr-2020&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Latinr 2020!&lt;/h1&gt;
&lt;p&gt;Ya se está gestando LatinR 2020, que va a ser en Montevideo, Uruguay. No puedo esperar a “cruzar el charco” y conocer más gente de la comunidad R oriental.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Midiendo el calentamiento global con ecmwfr</title>
      <link>/2019/04/ecmwfr-calentamiento-global/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/04/ecmwfr-calentamiento-global/</guid>
      <description>


&lt;p&gt;Para mi investigación necesitaba bajar datos meteorológicos grillados del ERA-Interim, que es una base de datos generada por el &lt;a href=&#34;https://www.ecmwf.int/&#34;&gt;ECMWF&lt;/a&gt;. Bajar los datos en su sitio web es &lt;strong&gt;muy&lt;/strong&gt; incómido y requiere &lt;strong&gt;muchos&lt;/strong&gt; clicks. Por suerte, me encontré con el paquete &lt;a href=&#34;https://github.com/khufkens/ecmwfr&#34;&gt;ecmwfr&lt;/a&gt; con el que pude bajar los datos directamente desde R y muy fácilmente. Una de las cosas geniales del código abierto, es que los usuarios pueden ser colaboradores, así que sugerí algunas cosas y aporté un poco de código.&lt;/p&gt;
&lt;p&gt;Ahora, una nueva versión está de camino a CRAN, así que quería mostrar un pequeño ejemplo de lo que se puede hacer con el paquete.&lt;/p&gt;
&lt;p&gt;Para bajar datos de los servidores del ECMWF hace falta tener una cuenta. Si van a seguir estos pasos, antes que nada van a tener que crearse una y agregar la key del API al keyring de ecmwfr. Esto se hace todo interactivamente con este comando:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ecmwfr)

wf_set_key(service = &amp;quot;webapi&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eso los lleva a la URL correcta donde pueden conseguir la clave y después configura todo para usarla.&lt;/p&gt;
&lt;p&gt;Lo segundo que hace fatla es un &lt;em&gt;request&lt;/em&gt; válido. Como la API tiene un montón de dataset distintos, con distinta resolución temporal y otras propiedades, armar uno desde cero es más bien complicado. Es preferible ir &lt;a href=&#34;https://apps.ecmwf.int/datasets/&#34;&gt;a la página&lt;/a&gt; y usar su interfaz para crear un &lt;em&gt;request&lt;/em&gt; básico del dataset de interes. En mi caso, voy a usar datos mensuales de &lt;a href=&#34;https://apps.ecmwf.int/datasets/data/interim-full-daily/levtype=sfc/&#34;&gt;ERA Interim&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;../post/2019-04-19-como-cambio-el-tiempo-desde-que-naci_files/webapi-erainterim.png&#34; alt=&#34;ERA Interim request&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;ERA Interim request&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se puede ver que no hay forma alguna de descargar todos los años usando la interfaz web. Pero abajo dse todo hay un botón que dice “View the MARS request”.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;../post/2019-04-19-como-cambio-el-tiempo-desde-que-naci_files/webapi-erainterim2.png&#34; alt=&#34;ERA Interim MARS&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;ERA Interim MARS&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Y eso provee el texto del &lt;em&gt;request&lt;/em&gt; que después voy a modificar un poco. En R, convierto este template en una lista usando la addin de RStudio “MARS to list” (pero si quieren peuden hacerlo a mano). Agregué &lt;code&gt;format  = &amp;quot;netcdf&amp;quot;&lt;/code&gt; al final para que me devuelva todo en formato NetCDF.&lt;/p&gt;
&lt;p&gt;Después le paso esa lista a la función &lt;code&gt;wf_archetype()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ERAI_monthly &amp;lt;- wf_archetype(
   request = list(
      class   = &amp;quot;ei&amp;quot;,
      dataset = &amp;quot;interim&amp;quot;,
      date    = &amp;quot;19790101/19790201/19790301/19790401/19790501/19790601/19790701/19790801/19790901/19791001/19791101/19791201&amp;quot;,
      expver  = &amp;quot;1&amp;quot;,
      grid    = &amp;quot;0.75/0.75&amp;quot;,
      levtype = &amp;quot;sfc&amp;quot;,
      param   = &amp;quot;167.128&amp;quot;,
      stream  = &amp;quot;moda&amp;quot;,
      type    = &amp;quot;an&amp;quot;,
      target  = &amp;quot;output&amp;quot;,
      format  = &amp;quot;netcdf&amp;quot;),
   dynamic_fields = c(&amp;quot;date&amp;quot;, &amp;quot;grid&amp;quot;, &amp;quot;target&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esto me crea una función (que llamé “ERAI_monthly”) con argumentos “date”, “grid” and “target”. No cambio la lista a mano porque quiero estar seguro de siempre tener un &lt;em&gt;request&lt;/em&gt; válido que apunte a ERA Interim. Para este pequeño ejemplo es medio mucho, pero es útil para usar en un proyecto más grande.&lt;/p&gt;
&lt;p&gt;Una cosa a notar es que el formato de las fechas es bastante largo. Voy a armarme una función que haga el trabajo pesado por mí.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;format_dates &amp;lt;- function(dates) {
   dates &amp;lt;- as.Date(dates)
   paste0(lubridate::year(dates),
          formatC(lubridate::month(dates), width = 2, flag = &amp;quot;0&amp;quot;),
          formatC(lubridate::day(dates), width = 2, flag = &amp;quot;0&amp;quot;),
          collapse = &amp;quot;/&amp;quot;)
}

format_dates(c(&amp;quot;2018-01-01&amp;quot;, &amp;quot;2018-02-01&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;20180101/20180201&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora estoy listo para descargar los datos! Como nací en agosto de 1988, voy a ver cómo aumentó la temperatura media de ese mes desde ese año. Y como no me interesan mucho los detalles locales, voy a usar una resolución de 3° por 3°.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dates &amp;lt;- seq.Date(as.Date(&amp;quot;1988-08-01&amp;quot;), as.Date(&amp;quot;2018-08-01&amp;quot;), &amp;quot;1 year&amp;quot;)

my_request &amp;lt;- ERAI_monthly(date = format_dates(dates), 
                           grid = &amp;quot;3/3&amp;quot;,
                           target = &amp;quot;august_monthly.nc&amp;quot;)
str(my_request)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 11
##  $ class  : chr &amp;quot;ei&amp;quot;
##  $ dataset: chr &amp;quot;interim&amp;quot;
##  $ date   : chr &amp;quot;19880801/19890801/19900801/19910801/19920801/19930801/19940801/19950801/19960801/19970801/19980801/19990801/200&amp;quot;| __truncated__
##  $ expver : chr &amp;quot;1&amp;quot;
##  $ grid   : chr &amp;quot;3/3&amp;quot;
##  $ levtype: chr &amp;quot;sfc&amp;quot;
##  $ param  : chr &amp;quot;167.128&amp;quot;
##  $ stream : chr &amp;quot;moda&amp;quot;
##  $ type   : chr &amp;quot;an&amp;quot;
##  $ target : chr &amp;quot;august_monthly.nc&amp;quot;
##  $ format : chr &amp;quot;netcdf&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y con esto, uso &lt;code&gt;wf_request()&lt;/code&gt; para bajar los datos. Esto puede llevar su tiempo. No porque el archivo sea muy pesado (para nada, sólo 455kb), sino porque el servidor tiene que procesar el &lt;em&gt;request&lt;/em&gt; y unir todos los datos. Si están siguiendo esto desde su casa, éste es el momento para ir a hacere un té o, en mi caso, un mate. 🍵&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wf_request(request = my_request,
           user = &amp;quot;eliocampitelli@gmail.com&amp;quot;, 
           transfer = TRUE,
           path = &amp;quot;data&amp;quot;, 
           verbose = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora que tengo mis datos en “august_monthly.nc”, sólo necesito cargarlo en memoria para analizarlo. Voy a usar mi paquete &lt;a href=&#34;https://eliocamp.github.io/metR/&#34;&gt;metR&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(metR)
library(ggplot2)
library(data.table)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;august_temp &amp;lt;- ReadNetCDF(&amp;quot;data/august_monthly.nc&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primero, mirar un poco la estructura de los datos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(august_temp)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Classes &amp;#39;data.table&amp;#39; and &amp;#39;data.frame&amp;#39;:   226920 obs. of  4 variables:
##  $ longitude: int  0 3 6 9 12 15 18 21 24 27 ...
##  $ latitude : int  90 90 90 90 90 90 90 90 90 90 ...
##  $ t2m      : num  273 273 273 273 273 ...
##  $ time     : POSIXct, format: &amp;quot;1988-08-01&amp;quot; &amp;quot;1988-08-01&amp;quot; ...
##  - attr(*, &amp;quot;.internal.selfref&amp;quot;)=&amp;lt;externalptr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Es un data frame con un valor de &lt;code&gt;t2m&lt;/code&gt; para cada longitud, latitud y tiempo. La temperatura está en Kelvin. Quiero ver un campo; el primero.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapa
world &amp;lt;- list(geom_path(data = map_data(&amp;quot;world2&amp;quot;), 
                        aes(long, lat, group = group), 
                        size = 0.2, color = &amp;quot;gray50&amp;quot;),
              coord_quickmap(),
              scale_x_longitude(),
              scale_y_latitude())

ggplot(august_temp[time == time[1]], aes(longitude, latitude)) +
   geom_contour_fill(aes(z = t2m - 273.15)) +
   world +
   scale_fill_divergent(&amp;quot;Temperatura a 2m (°C)&amp;quot;) +
   metR:::theme_field()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2019-04-19-como-cambio-el-tiempo-desde-que-naci_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Los trópicos son más cálidos que los polos, como debe ser.&lt;/p&gt;
&lt;p&gt;Luego de conocer los datos, voy a computar la tendencia lineal de la temperatura para cada punto de grilla. Estoy usando una forma &lt;strong&gt;muy bruta&lt;/strong&gt; para evaluar la significancia estadística.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;trends &amp;lt;- august_temp[, FitLm(year = year(time), t2m, se = TRUE), 
                      by = .(longitude, latitude)] 
trends[, p.value :=  pt(abs(estimate)/std.error, df, lower.tail = FALSE)]

ggplot(trends[term == &amp;quot;year&amp;quot;], aes(longitude, latitude)) +
   geom_contour_fill(aes(z = estimate*10), 
                     breaks = AnchorBreaks(0, 0.25, exclude = 0)) +
   stat_subset(aes(subset = p.value &amp;lt;= 0.01), 
               geom = &amp;quot;point&amp;quot;, size = 0.1, alpha = 0.5) +
   world +
   scale_fill_divergent(&amp;quot;Tendencia de temperatura a 2m \n (°C/década)&amp;quot;) +
   metR:::theme_field() +
   labs(subtitle = &amp;quot;Cambio de la temperatura media de agosto 1988-2018&amp;quot;, 
        caption = &amp;quot;Datos: ERA Interim&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2019-04-19-como-cambio-el-tiempo-desde-que-naci_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;No es sorprendente que la tendencia sea positiva en casi todos lados, aunque no es estadísticamente significativa siempre (usando este método &lt;strong&gt;muy bruto&lt;/strong&gt;). Notablemente, la temperatura de agosto no aumentó mucho donde yo vivo.&lt;/p&gt;
&lt;p&gt;Voy a construir (a lo bruto) una serie temporal de temperatura media global de agosto promediando todos los puntos de grilla para cada año (usando como peso el coseno de la latitud).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gmat &amp;lt;- august_temp[, .(t2m = weighted.mean(t2m, cos(latitude*pi/180))), 
                   by = year(time)]

ggplot(gmat, aes(year, t2m - 273.15)) +
   geom_line() +
   geom_smooth(method = &amp;quot;lm&amp;quot;) +
   scale_y_continuous(&amp;quot;Temperatura media a 2m global de agosto (°C)&amp;quot;) +
   hrbrthemes::theme_ipsum_rc()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2019-04-19-como-cambio-el-tiempo-desde-que-naci_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;De nuevo, no sorprende a nadie que la temperatura global está aumentando. Voy a calcular la tasa de aumento.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;trend &amp;lt;- lm(t2m ~ I(year/10), data = gmat)
summary(trend)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = t2m ~ I(year/10), data = gmat)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.28121 -0.05954 -0.01535  0.06890  0.28129 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept) 255.78307    4.71318  54.270  &amp;lt; 2e-16 ***
## I(year/10)    0.16756    0.02353   7.121 7.77e-08 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.1172 on 29 degrees of freedom
## Multiple R-squared:  0.6362, Adjusted R-squared:  0.6236 
## F-statistic: 50.71 on 1 and 29 DF,  p-value: 7.772e-08&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La tendencia (1.68 °C/década) es consistente con &lt;a href=&#34;https://www.ipcc.ch/site/assets/uploads/2018/02/AR5_SYR_FINAL_SPM.pdf&#34;&gt;estimaciones mejores&lt;/a&gt;. 🔥&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metamerismo estadístico</title>
      <link>/2019/01/metamerismo-estad%C3%ADstico/</link>
      <pubDate>Thu, 03 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/01/metamerismo-estad%C3%ADstico/</guid>
      <description>


&lt;div id=&#34;resumen&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Resumen&lt;/h1&gt;
&lt;p&gt;El paquete &lt;a href=&#34;https://github.com/eliocamp/metamer&#34;&gt;metamer&lt;/a&gt; implementa en R el algoritmo descripto por &lt;span class=&#34;citation&#34;&gt;Matejka and Fitzmaurice (&lt;a href=&#34;#ref-Matejka2017&#34;&gt;2017&lt;/a&gt;)&lt;/span&gt; para generar sets de datos distintos entre sí pero con estadísticos idénticos. Además, propongo el nombre “metámeros” para estos grupos de datos en analogía con el concepto proveniente de colorimetría.&lt;/p&gt;
&lt;div id=&#34;metameros-en-la-vision&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Metámeros en la visión&lt;/h2&gt;
&lt;p&gt;Esto &lt;strong&gt;no es&lt;/strong&gt; un prisma separando la luz blanca en las longitudes de onda que la componen. Es una &lt;em&gt;imagen&lt;/em&gt; de un prisma separando la luz blanca en las longitudes de onda que la componen.&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:prism&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../images/Prism_flat_rainbow.jpg&#34; alt=&#34;C&#39;est ne pas un prisme.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Fig. 1: C’est ne pas un prisme.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Esta observación magrittiana no es trivial. El monitor que está mostrando la imagen sólo tiene tres LEDs que emiten luz en sólo tres longitudes de onda (más o menos). ¿Cómo hace para reproducir todo el espectro de la luz blanca? La respuesta es que no lo hace. Para cada color de ese arcoíris, el monitor está emitiendo una mezcla de longitudes de onda roja, verde y azul que nuestro sistema visual interpreta como el mismo color que esa longitud de onda específica.&lt;/p&gt;
&lt;p&gt;Cómo sucede todo eso es complicadísimo y va más allá de lo que pueda explicar en este artículo (pero sí recomiendo leer &lt;a href=&#34;http://jamie-wong.com/post/color/&#34;&gt;esta excelente nota&lt;/a&gt; sobre el tema) pero el núcleo de la cuestión es que nuestros ojos tienen sólo tres tipos de receptores (conos) que responden a longitudes de onda cortas (S), medias (M) y largas (L). Por lo tanto, cualquier distribución de longitudes de onda que llegue a nuestros ojos, sin importar cuán complicada sea es reducida a únicamente tres números: la excitación de los receptores S, M y L. Y cualquier distribución de longitudes de onda que excite nuestros receptores en la misma proporción va a ser percibido como el mismo color. En colorimetría, esto se conoce como &lt;em&gt;metamerismo&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Hunt &lt;a href=&#34;#ref-Hunt2004-7&#34;&gt;2004&lt;/a&gt;)&lt;/span&gt;. El amarillo monocromático que se ve en un prisma se percibe igual que el amarillo producido por el monitor aunque no tenga ni remotamente el mismo espectro. Son metámeros.&lt;/p&gt;
&lt;p&gt;La creación de pares metaméricos es la base de la reproducción del color en monitores, impresiones y cuadros, pero también tiene su lado oscuro. Dos pigmentos pueden ser pares metaméricos bajo ciertas condiciones de iluminación pero tener colores muy distintos en otras. Esto puede ser un problema, por ejemplo, al comprar ropa en un negocio con iluminación artificial y luego usarla bajo la luz del Sol.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;metameros-en-la-estadistica&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Metámeros en la estadística&lt;/h2&gt;
&lt;p&gt;Ahora pensemos en el famoso cuarteto de Anscombe&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:anscombe-plot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../post/2018-12-18-metamerismo-estad%C3%ADstico_files/figure-html/anscombe-plot-1.png&#34; alt=&#34;Cuarteto de Anscombe&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Fig. 2: Cuarteto de Anscombe
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A pesar de ser cuatro sets de datos muy distintos, los miembros del cuarteto comparten el promedio y desvío estándar de cada variable, así como la correlación entre ambas &lt;span class=&#34;citation&#34;&gt;(Anscombe &lt;a href=&#34;#ref-Anscombe1973&#34;&gt;1973&lt;/a&gt;)&lt;/span&gt;. Vistos a través de esta transformación estadística, los cuatro sets de datos se ven iguales aún cuando no son ni remotamente similares. Son metámeros.&lt;/p&gt;
&lt;p&gt;Al igual que los pares metaméricos de colores, los metámeros estadísticos muestran sus diferencias cuando se los ve con otra “iluminación.” En este caso, un gráfico.&lt;/p&gt;
&lt;p&gt;El concepto de “datos con estadísticos idénticos pero gráficos distintos” todavía tiene relevancia, con varias publicaciones describiendo distintos métodos para crearlos &lt;span class=&#34;citation&#34;&gt;(p.e. Chatterjee and Firat &lt;a href=&#34;#ref-Chatterjee2007&#34;&gt;2007&lt;/a&gt;; Govindaraju and Haslett &lt;a href=&#34;#ref-Govindaraju2008&#34;&gt;2008&lt;/a&gt;; Haslett and Govindaraju &lt;a href=&#34;#ref-Haslett2009&#34;&gt;2009&lt;/a&gt;; Matejka and Fitzmaurice &lt;a href=&#34;#ref-Matejka2017&#34;&gt;2017&lt;/a&gt;)&lt;/span&gt; pero, que yo sepa, nunca fue nombrado. En analogía al metamerismo del color, en este artículo voy a llamar “metámeros” a cualquier conjunto de sets de datos que se comporta de forma idéntica bajo una determinada transformación estadística.&lt;/p&gt;
&lt;p&gt;El paquete &lt;a href=&#34;https://github.com/eliocamp/metamer&#34;&gt;metamer&lt;/a&gt; implementa el algoritmo de &lt;span class=&#34;citation&#34;&gt;Matejka and Fitzmaurice (&lt;a href=&#34;#ref-Matejka2017&#34;&gt;2017&lt;/a&gt;)&lt;/span&gt; para generar metámeros. La función principal, &lt;code&gt;metamerize()&lt;/code&gt;, permite generar metámeros a partir de un data set inicial y una función a preservar. Opcionalmente, se puede establecer una función que deben minimizar los metámeros sucesivos.&lt;/p&gt;
&lt;p&gt;Primero, la función &lt;code&gt;delayed_with()&lt;/code&gt; sirve para definir la serie de transformaciones estadísticas que deben ser preservadas. Los cuatro elementos del cuarteto de anscombe preservan estas propiedades con hasta tres cifras significativas (salvo por la correlación entre x e y en el cuarto cuarteto).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(metamer)

summ_fun &amp;lt;- delayed_with(mean_x = mean(x), 
                         mean_y = mean(y), 
                         sd_x = sd(x), 
                         sd_y = sd(y), 
                         cor_xy = cor(x, y))
summ_names &amp;lt;-  c(&amp;quot;$\\overline{x}$&amp;quot;, &amp;quot;$\\overline{y}$&amp;quot;, 
                 &amp;quot;$S_x$&amp;quot;,  &amp;quot;$S_y$&amp;quot;, &amp;quot;$r(x, y)$&amp;quot;)

anscombe[, as.list(signif(summ_fun(.SD), 3)), by = quartet] %&amp;gt;% 
   knitr::kable(col.names = c(&amp;quot;Cuarteto&amp;quot;, summ_names),
                escape = FALSE, 
                caption = &amp;quot;Propiedades estadísticas del cuarteto de Anscombe&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;caption&gt;&lt;span id=&#34;tab:anscombe-summ&#34;&gt;Tab. 1: &lt;/span&gt;Propiedades estadísticas del cuarteto de Anscombe&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Cuarteto&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(\overline{x}\)&lt;/span&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(\overline{y}\)&lt;/span&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(S_x\)&lt;/span&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(S_y\)&lt;/span&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(r(x, y)\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.817&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Para encontrar metámeros “entre” el primero y el segundo cuarteto, se puede empezar por el primero y generar metámeros que minimicen la distancia media al segundo. La función &lt;code&gt;mean_dist_to()&lt;/code&gt; sirve para este caso.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Extraigo el segundo cuarteto y eliminto la columna `quartet`
start_data &amp;lt;- subset(anscombe, quartet == 1)
start_data$quartet &amp;lt;- NULL

# Exraigo el tercer cuarteto y eliminto la columna `quartet`
target &amp;lt;- subset(anscombe, quartet == 2)
target$quartet &amp;lt;- NULL

set.seed(42)  # para resultados reproducibles
metamers &amp;lt;- metamerize(start_data, 
                       preserve = summ_fun,
                       minimize = mean_dist_to(target), 
                       signif = 3,
                       change = &amp;quot;y&amp;quot;,
                       perturbation = 0.008, 
                       N = 30000)
print(metamers)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 4690 metamers&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El proceso genera 4689 metámeros además de los datos originales. Seleccionando sólo 10 usando &lt;code&gt;trim()&lt;/code&gt; y aplicando &lt;code&gt;summ_fun()&lt;/code&gt; a cada uno se confirma que tienen las mismas propiedades con 3 cifras significativas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;metamers %&amp;gt;% 
   trim(10) %&amp;gt;% 
   lapply(summ_fun) %&amp;gt;% 
   lapply(signif, digits = 3) %&amp;gt;% 
   do.call(rbind, .) %&amp;gt;% 
   knitr::kable(col.names = c(summ_names),
                caption = &amp;quot;Propiedades estadísticas de los metámeros generados (redondeados a tres cifras significativas).&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;caption&gt;&lt;span id=&#34;tab:anscombe-metamers&#34;&gt;Tab. 2: &lt;/span&gt;Propiedades estadísticas de los metámeros generados (redondeados a tres cifras significativas).&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(\overline{x}\)&lt;/span&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(\overline{y}\)&lt;/span&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(S_x\)&lt;/span&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(S_y\)&lt;/span&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(r(x, y)\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.816&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Y usando &lt;a href=&#34;https://github.com/thomasp85/gganimate&#34;&gt;gganimate&lt;/a&gt; se puede visualizar cómo pasar del segundo al tercer cuarteto. Todos los pasos intermedios son metámeros del original.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(gganimate)

metamers %&amp;gt;% 
   trim(100) %&amp;gt;% 
   as.data.frame() %&amp;gt;%
   ggplot(aes(x, y)) +
   geom_point() +
   transition_manual(.metamer)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:anscombe-animate&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../post/2018-12-18-metamerismo-estad%C3%ADstico_files/figure-html/anscombe-animate-1.gif&#34; alt=&#34;Transformación del segundo al tercer cuarteto de Anscombe.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Fig. 3: Transformación del segundo al tercer cuarteto de Anscombe.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;En general la discusión alrededor del metamerismo estadístico suele ser sobre la importancia de graficar los datos en vez de únicamente calcular estadísticas resumidas. Anscombe creó su cuarteto para contradecir la idea de que “los cálculos numéricos son exactos, mientras que los gráficos son aproximados”. Actualmente esa es la interpretación que se sigue dando a este fenómeno:&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:tweet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../images/datasaurus_tweet.png&#34; alt=&#34;Descargá el Datasaurio: Nunca confíes sólo en las estadísticas resumidas; siempre visualizá tus datos. ([Tweet](https://twitter.com/albertocairo/status/770267777169035264))&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Fig. 4: Descargá el Datasaurio: Nunca confíes sólo en las estadísticas resumidas; siempre visualizá tus datos. (&lt;a href=&#34;https://twitter.com/albertocairo/status/770267777169035264&#34;&gt;Tweet&lt;/a&gt;)
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Sin embargo, creo que hay un principio más fundamental. El problema de las &lt;em&gt;summary statistics&lt;/em&gt; es la parte de &lt;em&gt;summary&lt;/em&gt;. El rol de la estadística es, en muchos casos, &lt;em&gt;resumir&lt;/em&gt; datos. Tomar una gran cantidad de observaciones que no pueden ser entendidas en su completitud porque nuestro entendimiento es limitado, y reducirlas a unos pocos números o propiedades que podemos entender fácilmente. El problema es que lo que se gana en entendimiento, se pierde información.&lt;/p&gt;
&lt;p&gt;Por ejemplo, un censo de los ingresos de todos los ciudadanos de un país tiene una enorme cantidad de información, pero tomados como datos separados dicen poco. Se puede resumir con el promedio (el primer momento) para tener alguna idea del valor “típico” de esta variable. Obviamente, este número esconde una gran desigualdad, por lo que es conveniente usar el desvío estándar (segundo momento) para tener una idea de cuán variable es la distribución del ingreso. Pero es muy probable que la distribución no sea simétrica. Se puede usar la asimetría (tercer momento) para empezar a cuantificar ese efecto.&lt;/p&gt;
&lt;p&gt;Cada momento que se agrega permite tener más información sobre los datos crudos. El límite es cuando se tienen tantos momentos como datos en la muestra. Una muestra univariada de tamaño N puede ser descripta unívocamente por sus N primeros momentos. Esto tiene sentido intuitivamente –no se debería necesitar más de N números para describir N números– pero también &lt;a href=&#34;https://math.stackexchange.com/questions/3033407/is-a-sample-of-size-n-uniquely-described-by-n-sample-moments&#34;&gt;tiene demostración&lt;/a&gt; matemática&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;En otras palabras, la transformación “primeros N momentos de una muestra de tamaño N” no tiene metámeros estadísticos salvo cualquier permutación de la muestra original (pero ver &lt;a href=&#34;#fn1&#34;&gt;1&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Esta propiedad no es única de los momentos estadísticos. La transformada de fourier tiene la misma propiedad, lo mismo que las componentes principales, análisis factorial, clustering, etc…&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;. El problema no es gráficos vs. números sino “todos los números” vs. “sólo algunos números”. La ventaja de los gráficos es que permiten representar gran cantidad de números de una forma eficiente e intuitiva, permitiendo una &lt;em&gt;gestalt&lt;/em&gt; que es imposible lograr simplemente mirando una serie de números.&lt;/p&gt;
&lt;p&gt;Esta observación permite predecir en qué casos será más fácil encontrar metámeros y cuándo es matemáticamente imposible. Por ejemplo, no se puede encontrar metámeros de una muestra de tamaño 10 que preserve 10 momentos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(42) 
start_data &amp;lt;- data.frame(x = rnorm(10))

metamerize(start_data, 
           moments_n(1:10),
           signif = 3,
           perturbation = 0.05,
           N = 30000)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 1 metamers&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pero sí se puede encontrar metámeros que preserven dos momentos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(42) 
metamerize(start_data, 
           moments_n(1:2), 
           signif = 3,
           perturbation = 0.01,
           N = 30000)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 263 metamers&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Un boxplot representa una muestra mediante unos 5 números, por lo que es esperable que demuestre metamerismo para muestras de &lt;span class=&#34;math inline&#34;&gt;\(N&amp;gt;5\)&lt;/span&gt;. Una estimación de densidad usando métodos paramétricos, en cambio, devuelve potencialmente infinitos puntos a partir de una muestra de cualquier tamaño. La posibilidad de metamerismo en ese caso depende de la “resolución” con la que se describa la curva. Si la curva es descripta con menos puntos que el tamaño de la muestra, va a tener metámeros.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coarse_density &amp;lt;- function(data) {
   density(data$x, n = 16)$y
}
set.seed(42) 
metamerize(data.frame(x = rnorm(100)),
           preserve = coarse_density,
           N = 5000,
           signif = 3,
           perturbation = 0.001)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 11 metamers&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mientras que si se la describe con más puntos, no permite metamerismo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;highdef_density &amp;lt;- function(data) {
   density(data$x, n = 200)$y
}
set.seed(42) 
metamerize(data.frame(x = rnorm(100)),
           preserve = highdef_density,
           N = 5000,
           signif = 3,
           perturbation = 0.001)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 1 metamers&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este principio general está bien, pero no está completo. Imaginemos una transformación estadística que devuelva un vector de tamaño N con el promedio de una muestra repetido N veces. A pesar de obtener N números a partir de una muestra de tamaño N, tiene la misma información que si fuera sólo el promedio. Generar metámeros para esta transformación es trivial.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean_n_times &amp;lt;- function(data) {
   rep(mean(data$x), length.out = length(data$x))
}
set.seed(42) 
metamerize(data.frame(x = rnorm(100)),
           preserve = mean_n_times,
           perturbation = 0.1, 
           N = 1000)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 43 metamers&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esto motiva definir la categoría de transformaciones estadísticas “eficaces” como aquellas que pueden describir una muestra univariada de tamaño N con unicidad a partir de N números o menos. Bajo esta definición, “los primeros N momentos” es una transformación eficaz mientras que “repetir el primer momento N veces” no lo es. Esto, igual es pura especulación mía.&lt;/p&gt;
&lt;p&gt;Vale la pena notar que en la búsqueda empírica de metámeros hay que establecer un nivel de exactitud tolerable (con el argumento &lt;code&gt;signif&lt;/code&gt;). Si se quiere ser exactos, éstos no son metámeros verdaderos sino más bien “semi-metámeros”. Esta diferencia implica que si se tolera una exactitud baja es posible encontrar (semi)-metámeros aún cuando teóricamente no debería ser posible.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(42) 
metamerize(data.frame(x = rnorm(3)),
                       moments_n(1:4), 
                       signif = 1, 
                       perturbation = 0.001, 
                       N = 1000)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 1000 metamers&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;metameros-avanzados&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Metámeros avanzados&lt;/h2&gt;
&lt;p&gt;Finalmente, me gustaría mostrar algunas utilidades de metamer que facilitan mucho la creación de nuevos metámeros. Con &lt;code&gt;draw_data()&lt;/code&gt; uno puede dibujar datos a mano alzada en una interfaz de shiny, opcionalmente usando otra base de datos como fondo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;start_data &amp;lt;- subset(datasauRus::datasaurus_dozen, dataset == &amp;quot;dino&amp;quot;)
start_data$dataset &amp;lt;- NULL

smiley &amp;lt;- draw_data(start_data)
simley$.group &amp;lt;- NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:draw-data&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../images/draw_data.png&#34; alt=&#34;Interfaz de `draw_data()`.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Fig. 5: Interfaz de &lt;code&gt;draw_data()&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Además, &lt;code&gt;metamerize()&lt;/code&gt; puede encadenarse y guarda los parámetros que se usaron antes, excepto &lt;code&gt;N&lt;/code&gt; y &lt;code&gt;trim&lt;/code&gt;. De esta forma se puede hacer secuencias.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;X &amp;lt;- subset(datasauRus::datasaurus_dozen, dataset == &amp;quot;x_shape&amp;quot;)
X$dataset &amp;lt;- NULL

star &amp;lt;- subset(datasauRus::datasaurus_dozen, dataset == &amp;quot;star&amp;quot;)
star$dataset &amp;lt;- NULL&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;metamers &amp;lt;- metamerize(start_data, 
                       preserve = delayed_with(mean(x), mean(y), cor(x, y)),
                       minimize = mean_dist_to(smiley), 
                       perturbation = 0.08,
                       N = 30000,
                       trim = 150) %&amp;gt;% 
   metamerize(minimize = NULL, 
              N = 3000, trim = 10) %&amp;gt;% 
   metamerize(minimize = mean_dist_to(X), 
              N = 30000, trim = 150) %&amp;gt;% 
   metamerize(minimize = NULL, 
              N = 3000, trim = 10) %&amp;gt;% 
   metamerize(minimize = mean_dist_to(star), 
              N = 30000, trim = 150) %&amp;gt;%
   metamerize(minimize = NULL, 
              N = 3000, trim = 10) %&amp;gt;% 
   metamerize(minimize = mean_dist_to(start_data),
              N = 30000, trim = 150)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esta serie de metámeros muestra al datasaurio metamorfoseando en distintas figuras, siempre manteniendo las mismas propiedades estadísticas y logrando algo similar a &lt;a href=&#34;https://www.autodeskresearch.com/publications/samestats&#34;&gt;la animación de Justin Matejka y George Fitzmaurice&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;metamers %&amp;gt;% 
   as.data.frame() %&amp;gt;% 
   ggplot(aes(x, y)) +
   geom_point() +
   transition_manual(.metamer)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:metamer-chain-anim&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../post/2018-12-18-metamerismo-estad%C3%ADstico_files/figure-html/metamer-chain-anim-1.gif&#34; alt=&#34;Metamorfosis del datasaurio.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Fig. 6: Metamorfosis del datasaurio.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Anscombe1973&#34;&gt;
&lt;p&gt;Anscombe, F J. 1973. “Graphs in Statistical Analysis.” &lt;em&gt;The American Statistician&lt;/em&gt; 27 (1): 17–21. &lt;a href=&#34;https://doi.org/10.1007/978-3-540-71915-1_35&#34; class=&#34;uri&#34;&gt;https://doi.org/10.1007/978-3-540-71915-1_35&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Chatterjee2007&#34;&gt;
&lt;p&gt;Chatterjee, Sangit, and Aykut Firat. 2007. “Generating data with identical statistics but dissimilar graphics: A follow up to the anscombe dataset.” &lt;em&gt;American Statistician&lt;/em&gt; 61 (3): 248–54. &lt;a href=&#34;https://doi.org/10.1198/000313007X220057&#34; class=&#34;uri&#34;&gt;https://doi.org/10.1198/000313007X220057&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Govindaraju2008&#34;&gt;
&lt;p&gt;Govindaraju, K., and S. J. Haslett. 2008. “Illustration of regression towards the means.” &lt;em&gt;International Journal of Mathematical Education in Science and Technology&lt;/em&gt; 39 (4): 544–50. &lt;a href=&#34;https://doi.org/10.1080/00207390701753788&#34; class=&#34;uri&#34;&gt;https://doi.org/10.1080/00207390701753788&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Haslett2009&#34;&gt;
&lt;p&gt;Haslett, S. J., and K. Govindaraju. 2009. “Cloning data: Generating datasets with exactly the same multiple linear regression fit.” &lt;em&gt;Australian and New Zealand Journal of Statistics&lt;/em&gt; 51 (4): 499–503. &lt;a href=&#34;https://doi.org/10.1111/j.1467-842X.2009.00560.x&#34; class=&#34;uri&#34;&gt;https://doi.org/10.1111/j.1467-842X.2009.00560.x&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hunt2004-7&#34;&gt;
&lt;p&gt;Hunt, R. W. G. 2004. “The Colour Triangle.” In &lt;em&gt;The Reproduction of Colour&lt;/em&gt;, 6th ed., 68–91. &lt;a href=&#34;https://doi.org/10.1002/0470024275&#34; class=&#34;uri&#34;&gt;https://doi.org/10.1002/0470024275&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Matejka2017&#34;&gt;
&lt;p&gt;Matejka, Justin, and George Fitzmaurice. 2017. “Same Stats, Different Graphs.” &lt;em&gt;Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems - CHI ’17&lt;/em&gt;, 1290–4. &lt;a href=&#34;https://doi.org/10.1145/3025453.3025912&#34; class=&#34;uri&#34;&gt;https://doi.org/10.1145/3025453.3025912&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Técnicamente la descripción es única a menos a menos de permutaciones de los valores. Esto no es casualidad. El caso donde el orden de los valores importa es, en realidad, un caso de muestras bivariadas (cada “dato” es un par de valores (x; y)). La intuición es que además de los momentos de cada variable, son necesarios los momentos cruzados (covarianza, etc…). La demostración para el caso multivariado &lt;a href=&#34;https://mathoverflow.net/questions/201719/moment-problem-for-discrete-distributions&#34;&gt;es complicada pero parece que existe&lt;/a&gt;, aunque no creo poder entenderla. Por intuición me parece plausible que en ese caso sea necesaria la matriz &lt;span class=&#34;math inline&#34;&gt;\(A^{N\times N}\)&lt;/span&gt; donde el elemento de la fila &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; y columna &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; es &lt;span class=&#34;math inline&#34;&gt;\(x^iy^j\)&lt;/span&gt;; lo cual implica necesitar &lt;span class=&#34;math inline&#34;&gt;\(N^2 - 1\)&lt;/span&gt; momentos.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;El caso de la transformada de fourier es interesante porque describe una serie &lt;em&gt;ordenada&lt;/em&gt; de tamaño &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; con dos series ordenadas de &lt;span class=&#34;math inline&#34;&gt;\(N/2\)&lt;/span&gt; números (una real y otra imaginaria). Es decir, &lt;span class=&#34;math inline&#34;&gt;\(2N\)&lt;/span&gt; números en total (las dos series y sus respectivos órdenes). Esto es mucho menor que &lt;span class=&#34;math inline&#34;&gt;\(N^2-1\)&lt;/span&gt; supuesto antes pero sospecho que esto es porque esta propiedad de fourier es para series &lt;em&gt;equiespaciadas&lt;/em&gt;. Si los datos tienen alguna restricción, se puede “comprimir” la información.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Leyendo información del INCUCAI</title>
      <link>/2018/10/leyendo-informacion-incucai/</link>
      <pubDate>Tue, 02 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/10/leyendo-informacion-incucai/</guid>
      <description>

&lt;p&gt;El otro día el diario Clarín sacó &lt;a href=&#34;https://www.clarin.com/sociedad/ley-justina-agosto-registro-record-historico-donantes-trasplante-organos_0_SyvU8EwwQ.html&#34;&gt;una nota&lt;/a&gt; afirmando que el pasado agosto se había dado el récord histórico de transplantes de órganos y se lo adjudicaba a la &amp;ldquo;Ley Justina&amp;rdquo;, que establece que todos somos donantes presuntos a menos que se declare lo contrario en vida. Dado que esta ley se aprobó hace poco más de un mes y todavía no está reglamentada, es poco probable que este récord se deba al cambio legal. En cualquier caso, la nota me despertó curiosidad. ¿Cómo evolucionó la donación de órganos en Argentina?&lt;/p&gt;

&lt;p&gt;Como toda buena nota periodística, el artículo de Clarín sólo tira datos puntuales sin mostrar una linea de tiempo o poner los datos en perspectiva, así que tuve que ir a la fuente. El INCUCAI (Instituto Nacional Central Único Coordinador de Ablación e Implante) tiene un sistema de acceso a datos &lt;a href=&#34;https://cresi.incucai.gov.ar/IniciarCresiFromSintra.do&#34;&gt;llamado CRESI&lt;/a&gt; (Central de Reportes y Estadísticas del SINTRA (Sistema Nacional de Información de Procuración y Transplante de la República Argentina)) que es relativamente bueno por lo transparente, pero complicado para leer programáticamente. Esto me pareció un buen ejercicio para aprender a obtener datos de sitios web.&lt;/p&gt;

&lt;p&gt;Mi objetivo final era conseguir una serie mensual de donaciones de órganos pero el sitio sólo permite obtener los datos totales por período. Obteniendo algo como esto:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../images/cresi_tabla.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(Recién luego de todo lo que sigue me di cuenta que en otra parte se pueden ver los datos mensuales por año, lo que facilita un poco las cosas. Moraleja: ¡analizar bien la página &lt;em&gt;antes&lt;/em&gt; de empezar a escribir código!)&lt;/p&gt;

&lt;p&gt;Como las consultas se hacen de forma dinámica (lo cual implicaba que no es tan fácil como ir a un url en particular y listo) usé las herramientas de desarrollo de Firefox (apretando F12) y me fijé qué pasaba en la solapa &lt;em&gt;Network&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../images/cresi_post.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Así se puede ver que lo que hace es un &lt;code&gt;POST&lt;/code&gt; (uno de los &amp;ldquo;&lt;a href=&#34;https://robm.me.uk/web-development/2013/09/20/http-verbs.html&#34;&gt;verbos&lt;/a&gt;&amp;rdquo; del html) con una serie de parámetros entre los que está la fecha de inicio y final del período que busco y un número de &amp;ldquo;token&amp;rdquo;, que es el identificador único de mi sesión y que tengo que usar para acceder a los datos.&lt;/p&gt;

&lt;p&gt;Ok, ¿cómo obtener ese número de forma programática? Luego de dar MUCHAS vueltas me fijé en el código fuente de la &lt;a href=&#34;https://cresi.incucai.gov.ar/IniciarCresiFromSintra.do&#34;&gt;página de inicio&lt;/a&gt; del CRESI (click derecho -&amp;gt; View page source) y me encontré con que el token estaba ahí!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../images/cresi_token.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Excelente, entonces lo único que hay que hacer es navegar a esa página, leer el código fuente y extraer el ese valor. La función &lt;code&gt;get_token()&lt;/code&gt; hace eso.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(dplyr)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;dplyr&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(httr)
library(xml2)
get_token &amp;lt;- function() {
   
   fuente &amp;lt;- POST(&amp;quot;https://cresi.incucai.gov.ar/IniciarCresiFromSintra.do&amp;quot;,
                      add_headers(Conection = &amp;quot;keep-alive&amp;quot;)) %&amp;gt;% 
      read_html() 
   token &amp;lt;- xml_attrs(xml_child(xml_child(xml_child(xml_child(fuente, 3), 1), 1), 3))
   return(token[3])
}

(token &amp;lt;- get_token())
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##         value 
## &amp;quot;-1609985208&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora con ese token, tengo que hacer dos &lt;code&gt;POST&lt;/code&gt;; el primero define el tipo de búsqueda y el segundo la forma de agrupación de los datos. Como primer paso busco los datos para el mes de enero de 2000.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;primer_paso &amp;lt;- POST(&amp;quot;https://cresi.incucai.gov.ar/reporte/resumenestadistico/DonantePaso2.do&amp;quot;,
                          query = list(`5406` = &amp;quot;&amp;quot;,
                                       `5407` = &amp;quot;&amp;quot;,
                                       `5415` = &amp;quot;&amp;quot;,
                                       `5416` = &amp;quot;&amp;quot;,
                                       `5418` = &amp;quot;&amp;quot;,
                                       `5419` = &amp;quot;&amp;quot;,
                                       `5420_anio` = 2000,
                                       `5420_dia` = 01,
                                       `5420_mes` = 01,
                                       `5421_anio` = 2000,
                                       `5421_dia` = 31,
                                       `5421_mes` = 01,
                                       ABLACION = &amp;quot;&amp;quot;,
                                       CMUERTE = &amp;quot;&amp;quot;,
                                       CORAZONPD = &amp;quot;&amp;quot;,
                                       DEPENDENCIA = &amp;quot;&amp;quot;,
                                       ENTREVISTADOR = &amp;quot;&amp;quot;,
                                       ENTREVISTADOR_DESCRIPCION = &amp;quot;&amp;quot;,
                                       ESTABLECIMIENTO = &amp;quot;&amp;quot;,
                                       ESTABLECIMIENTO_DESCRIPCION = &amp;quot;&amp;quot;,
                                       ESTABLECIMIENTO_ORIGEN = 1,
                                       ESTABLECIMIENTO_ORIGEN_DESCRIPCION = &amp;quot;ARGENTINO&amp;quot;,
                                       FPROFESIONAL = &amp;quot;&amp;quot;,
                                       MMUERTE = &amp;quot;&amp;quot;,
                                       OPCIONES_AVANZADAS = &amp;quot;false&amp;quot;,
                                       ORIGENPD = &amp;quot;&amp;quot;,
                                       OTRO_ANIO = &amp;quot;&amp;quot;,
                                       PERIODO = 5,
                                       PERIODO_DESCRIPCION	= &amp;quot;ESPECIFICAR&amp;quot;,
                                       SERVICIO = &amp;quot;&amp;quot;,
                                       SPD = 4,
                                       SPD_DESCRIPCION = &amp;quot;DONANTES+REALES&amp;quot;,
                                       TIPO_DONANTE = &amp;quot;&amp;quot;,
                                       TIPOEST = &amp;quot;&amp;quot;,
                                       TOKEN = token))

segundo_paso &amp;lt;- POST(&amp;quot;https://cresi.incucai.gov.ar/reporte/resumenestadistico/EjecutarConsultaDonante.do&amp;quot;, 
                           query = list(`2` = &amp;quot;checked&amp;quot;,
                                        TOKEN = token))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La información está en lo que devuelve &lt;code&gt;segundo_paso&lt;/code&gt;. El texto de la página se lee usando &lt;code&gt;read_html()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(datos &amp;lt;- xml2::read_html(segundo_paso))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## {xml_document}
## &amp;lt;html&amp;gt;
## [1] &amp;lt;head&amp;gt;\n&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset= ...
## [2] &amp;lt;script language=&amp;quot;JavaScript&amp;quot; type=&amp;quot;text/JavaScript&amp;quot;&amp;gt; \r\n\r\nfuncti ...
## [3] &amp;lt;body onload=&amp;quot;&amp;quot;&amp;gt;\r\n&amp;lt;span class=&amp;quot;notranslate&amp;quot;&amp;gt; \r\n&amp;lt;form action=&amp;quot;Can ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La cuestión es ahora extraer la tabla que quiero. Para eso está la magia del &lt;a href=&#34;https://selectorgadget.com/&#34;&gt;Selector Gadget&lt;/a&gt;. Es una herramienta que permite crear reglas para filtrar elementos de una página web a partir de ejemplos positivos y negativos. En este caso, quiero leer toda la tabla.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../images/cresi_selector.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(Intenté filtros para eliminar el encabezado, pero no funcionaban bien y decidí que era más fácil eliminarlo en R)&lt;/p&gt;

&lt;p&gt;La parte que importa es ese &amp;ldquo;.textoTabla2&amp;rdquo;. Ahora uso el excelente paquete &lt;code&gt;rvest&lt;/code&gt; para filtrar ese &amp;ldquo;nodo&amp;rdquo; y luego convertirlo en un &lt;code&gt;data.frame&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tabla &amp;lt;- datos %&amp;gt;% 
    rvest::html_nodes(&amp;quot;.textoTabla2&amp;quot;) %&amp;gt;% 
    rvest::html_table(fill = TRUE)
head(tabla[[1]][-1, ])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##                  X1     X2     X3        X4     X5   X6     X7    X8
## 2         Provincia Reales    %Re Efectivos    %Ef Mono    %Mo Multi
## 3    2*BUENOS AIRES      8 100.0%         7  87.5%    -      -     8
## 4 1*CAPITAL FEDERAL      5 100.0%         3  60.0%    3  60.0%     2
## 5         6*CORDOBA      2 100.0%         2 100.0%    1  50.0%     1
## 6       21*SANTA FE      1 100.0%         1 100.0%    1 100.0%     -
## 7          5*CHUBUT      1 100.0%         1 100.0%    -      -     1
##       X9     X10 X11    X12     X13   X14 X15
## 2    %Mu Tejidos %Te %Total    DPMH TOTAL  NA
## 3 100.0%       -   -  42.1% 0.6 PMH     8  NA
## 4  40.0%       -   -  26.3% 1.7 PMH     5  NA
## 5  50.0%       -   -  10.5% 0.6 PMH     2  NA
## 6      -       -   -   5.3% 0.3 PMH     1  NA
## 7 100.0%       -   -   5.3% 2.4 PMH     1  NA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¡Y ya tengo lo que necesito! 🎉 Sólo le falta un poco de limpieza relativamente trivial.&lt;/p&gt;

&lt;p&gt;Lo que sí falta ahora es hacer conseguir los datos para todos los meses del período. El plan es hacer una función que devuelva el valor para un mes y luego iterarla sobre una lista de meses. Además voy a tener en cuenta un pequeño detalle y usar el paquete &lt;code&gt;memoise&lt;/code&gt; para guardar en caché el resultado de la función y no hacer dos veces el mismo request al servidor. Esto está bueno por so uno corre varias veces el código mientras debuggea cosas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;donaciones_por_provincia_ &amp;lt;- function(fecha, verbose = FALSE) {
  library(rvest)
  library(httr)
  library(lubridate)
  
  desde &amp;lt;- fecha
  hasta &amp;lt;- fecha
  day(hasta) &amp;lt;- days_in_month(desde)
  
  anio_0 &amp;lt;- year(desde)
  mes_0 &amp;lt;- month(desde)
  dia_0 &amp;lt;- day(desde)
  
  anio_f &amp;lt;- year(hasta)
  mes_f &amp;lt;- month(hasta)
  dia_f &amp;lt;- day(hasta)
  
  if (isTRUE(verbose)) {
    cat(paste0(&amp;quot;Leyendo mes: &amp;quot;, anio_0, &amp;quot;-&amp;quot;, mes_0), &amp;quot;\r&amp;quot;)
  }
  
  token &amp;lt;- get_token()
  
  # Scrapp web
  primer_paso &amp;lt;- POST(&amp;quot;https://cresi.incucai.gov.ar/reporte/resumenestadistico/DonantePaso2.do&amp;quot;,
                      query = list(`5406` = &amp;quot;&amp;quot;,
                                   `5407` = &amp;quot;&amp;quot;,
                                   `5415` = &amp;quot;&amp;quot;,
                                   `5416` = &amp;quot;&amp;quot;,
                                   `5418` = &amp;quot;&amp;quot;,
                                   `5419` = &amp;quot;&amp;quot;,
                                   `5420_anio` = anio_0,
                                   `5420_dia` = dia_0,
                                   `5420_mes` = mes_0,
                                   `5421_anio` = anio_f,
                                   `5421_dia` = dia_f,
                                   `5421_mes` = mes_0,
                                   ABLACION = &amp;quot;&amp;quot;,
                                   CMUERTE = &amp;quot;&amp;quot;,
                                   CORAZONPD = &amp;quot;&amp;quot;,
                                   DEPENDENCIA = &amp;quot;&amp;quot;,
                                   ENTREVISTADOR = &amp;quot;&amp;quot;,
                                   ENTREVISTADOR_DESCRIPCION = &amp;quot;&amp;quot;,
                                   ESTABLECIMIENTO = &amp;quot;&amp;quot;,
                                   ESTABLECIMIENTO_DESCRIPCION = &amp;quot;&amp;quot;,
                                   ESTABLECIMIENTO_ORIGEN = 1,
                                   FPROFESIONAL = &amp;quot;&amp;quot;,
                                   MMUERTE = &amp;quot;&amp;quot;,
                                   OPCIONES_AVANZADAS = &amp;quot;false&amp;quot;,
                                   ORIGENPD = &amp;quot;&amp;quot;,
                                   OTRO_ANIO = &amp;quot;&amp;quot;,
                                   PERIODO = 5,
                                   PERIODO_DESCRIPCION	= &amp;quot;ESPECIFICAR&amp;quot;,
                                   SERVICIO = &amp;quot;&amp;quot;,
                                   SPD = 4,
                                   TIPO_DONANTE = &amp;quot;&amp;quot;,
                                   TIPOEST = &amp;quot;&amp;quot;,
                                   TOKEN = token))
  
  segundo_paso &amp;lt;- POST(&amp;quot;https://cresi.incucai.gov.ar/reporte/resumenestadistico/EjecutarConsultaDonante.do&amp;quot;,
                       query = list(`2` = &amp;quot;checked&amp;quot;,
                                    TOKEN = token))
  
  
  table &amp;lt;- read_html(segundo_paso) %&amp;gt;% 
    html_nodes(&amp;quot;.textoTabla2&amp;quot;) %&amp;gt;% 
    html_table(fill = TRUE) %&amp;gt;% 
    .[[1]] %&amp;gt;% 
    .[-1, ]
  colnames(table) &amp;lt;- table[1, ]
  
  # Limpieza de columnas y filas inválidas
  table &amp;lt;- table[-1, ]
  table &amp;lt;- table[-nrow(table), ]
  table &amp;lt;- table[-nrow(table), ]
  table &amp;lt;- table[, -ncol(table)]
  
  # Elimino porcentajes
  porcentajes &amp;lt;- stringi::stri_detect(colnames(table), fixed = &amp;quot;%&amp;quot;)
  table &amp;lt;- table[, !porcentajes]
  
  # Limpio algunos datos
  table$Provincia &amp;lt;- stringi::stri_replace(table$Provincia, &amp;quot;&amp;quot;,
                                           regex = &amp;quot;\\d*\\*&amp;quot;)
  table$DPMH &amp;lt;- stringi::stri_replace(table$DPMH, &amp;quot;&amp;quot;,
                                      fixed = &amp;quot; PMH&amp;quot;)
  
  # Paso todo a numérico y los NA son ceros
  table[, -1] &amp;lt;- suppressWarnings(lapply(table[, -1], as.numeric))
  table[, -1] &amp;lt;- lapply(table[, -1], function(x) {
    x[is.na(x)] &amp;lt;- 0
    x })
  table
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Antes de hacer nada, voy a probar si funciona&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;donaciones_por_provincia_(as.Date(&amp;quot;2018-01-05&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;lubridate&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following object is masked from &#39;package:base&#39;:
## 
##     date
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##          Provincia Reales Efectivos Mono Multi Tejidos DPMH TOTAL
## 3     BUENOS AIRES      9         8    6     3       0  0.5     9
## 4         SANTA FE      7         7    2     5       0  2.0     7
## 5          TUCUMAN      6         6    3     3       0  3.6     6
## 6          CORDOBA      5         5    1     4       0  1.4     5
## 7  CAPITAL FEDERAL      4         4    2     2       0  1.3     4
## 8          MENDOZA      2         1    2     0       0  1.0     2
## 9            CHACO      1         1    0     1       0  0.8     1
## 10      CORRIENTES      1         1    1     0       0  0.9     1
## 11      ENTRE RIOS      1         1    1     0       0  0.7     1
## 12           SALTA      1         1    1     0       0  0.7     1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¡Bien! Todo lo anterior involucró una cantidad inimaginable de prueba y error y el resultado no es el código más robusto ni correcto. No sólo no tiene ninguna forma de informar sobre errores, sino que en el camino no me fijé si el &amp;ldquo;robots.txt&amp;rdquo; permite hacer este tipo de scrapping y no le puse un &amp;ldquo;sleep&amp;rdquo; para limitar la tasa de conecciones al servidor. Tengo pendiente aprender a hacer eso usando el paquete &lt;a href=&#34;https://github.com/dmi3kno/polite&#34;&gt;&lt;code&gt;polite&lt;/code&gt;&lt;/a&gt;. Pero bueno; si funciona, funciona. 😤&lt;/p&gt;

&lt;p&gt;Para terminar, guardo la versión con caché&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;donaciones_por_provincia &amp;lt;- memoise::memoise(donaciones_por_provincia_)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con esto ya estoy listo para bajar todos los datos. Que &lt;a href=&#34;https://twitter.com/jennybryan&#34;&gt;Jenny Bryan&lt;/a&gt; me perdone por no usar &lt;a href=&#34;https://purrr.tidyverse.org&#34;&gt;&lt;code&gt;purrr&lt;/code&gt;&lt;/a&gt;, pero todavía estoy acostumbrado al viejo y querido &lt;code&gt;lapply&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Vector con fechas desde enero de 1998 hasta agosto de 2018 de a un mes
fechas &amp;lt;- seq.Date(ymd(&amp;quot;1998-01-01&amp;quot;), ymd(&amp;quot;2018-08-01&amp;quot;), by = &amp;quot;1 month&amp;quot;)

# Para cada fecha, bajo las donaciones por provincia, les pongo nombre
# a los elementos de la lista y luego los combino por filas. 
donaciones &amp;lt;- lapply(fechas, donaciones_por_provincia, verbose = TRUE) %&amp;gt;% 
  setNames(fechas) %&amp;gt;% 
  data.table::rbindlist(idcol = &amp;quot;fecha&amp;quot;) 

donaciones$fecha &amp;lt;- as.Date(donaciones$fecha)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta parte del código tarda mucho y acá está la gracia del memoise. Podemos cancelar el proceso en cualquier momento y al reiniciarlo sólo se descargan los meses que no corrieron.&lt;/p&gt;

&lt;p&gt;No puedo terminar el post sin al menos la visualización de los datos que catalizaron todo esto. ¿Cómo varió la cantidad de transplantes con el tiempo?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(data.table)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;data.table&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:lubridate&#39;:
## 
##     hour, isoweek, mday, minute, month, quarter, second, wday,
##     week, yday, year
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:dplyr&#39;:
## 
##     between, first, last
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)

donaciones[, .(total = sum(TOTAL)), by = fecha] %&amp;gt;% 
ggplot(aes(fecha, total)) +
   geom_line() +
   labs(x = &amp;quot;Fecha&amp;quot;, y = &amp;quot;&amp;quot;, 
        title = &amp;quot;Cantidad de transplantes por mes&amp;quot;, 
        caption = &amp;quot;Fuente: INCUCAI&amp;quot;) +
   hrbrthemes::theme_ipsum_rc()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-10-02-leyendo-información-de-incucai_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ahí lo tienen. Agosto de este año fue un mes anómalo, con muchos más transplantes que meses anteriores. Esperemos que marque el quiebre de la tendencia a la baja que viene desde 2010.&lt;/p&gt;

&lt;h1 id=&#34;resumen&#34;&gt;Resumen&lt;/h1&gt;

&lt;p&gt;Usé &lt;code&gt;httr&lt;/code&gt; para obtener información de un servidor y &lt;code&gt;xml2&lt;/code&gt; para interpretarla. Luego, con &lt;code&gt;rvest&lt;/code&gt; y Selector Gadget seleccioné la tabla con la información relevante. Finalmente, usando &lt;code&gt;memoise&lt;/code&gt; me aseguré de no descargar los mismos datos dos veces.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Multiple color (and fill) scales with ggplot2</title>
      <link>/2018/09/multiple-color-and-fill-scales-with-ggplot2/</link>
      <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/09/multiple-color-and-fill-scales-with-ggplot2/</guid>
      <description>

&lt;p&gt;(&lt;a href=&#34;https://eliocamp.github.io/codigo-r/2018/09/multiples-escalas-colores-ggplot2/&#34;&gt;Versión en español&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;tl;dr: The functionality shown in this post is now on the &lt;a href=&#34;https://github.com/eliocamp/ggnewscale&#34;&gt;&lt;code&gt;ggnewscale&lt;/code&gt;&lt;/a&gt; package! 📦. You can find the original code &lt;a href=&#34;https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32&#34;&gt;in this gist&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A somewhat common annoyance for some &lt;code&gt;ggplot2&lt;/code&gt; users is the lack of support for multiple colour and fill scales. Perusing StackOverflow you can find many questions relating to this issue:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/search?q=ggplot2+two+color+scales&#34;&gt;&lt;img src=&#34;../images/ggplo2_twoscales_so_small.jpg&#34; alt=&#34;preguntas stack overflow&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, this deluge of questions is met with a shortage of conclusive answers, most of them being some variation of &amp;ldquo;you can&amp;rsquo;t, but here&amp;rsquo;s how to hack it or visualise the data differently&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Recently I came up with a way of tricking &lt;code&gt;ggplot2&lt;/code&gt; into displaying multiple scales. It relies on &lt;a href=&#34;https://github.com/tidyverse/ggplot2/pull/2555&#34;&gt;a recent addition&lt;/a&gt; by Claus Wilke that allows the usage of &amp;ldquo;non standard aesthetics&amp;rdquo; &amp;ndash;&lt;code&gt;scale_color_continuous(aesthetics = &amp;quot;fill&amp;quot;)&lt;/code&gt; sets a &lt;code&gt;fill&lt;/code&gt; scale&amp;ndash; and the use of &lt;code&gt;ggplot_add()&lt;/code&gt; that I learnt thanks to &lt;a href=&#34;https://yutani.rbind.io/post/2017-11-07-ggplot-add&#34;&gt;this post&lt;/a&gt; by Hiroaki Yutani.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s be serious for a moment and acknowledge that using multiple color scales is not for the faint of heart. There&amp;rsquo;s a very real risk of ending up with a plot with is at best confusing and at worst, misleading. But that doesn&amp;rsquo;t mean there are not situations that call for this kind of plot. Using very different scales allows you to condense more information in a single plot, letting you visualise more relationships between variables. In the Atmospheric Sciences, for example, plotting temperature and pressure in contour lines with different color scales is a common practice.&lt;/p&gt;

&lt;p&gt;But &lt;em&gt;res non verba&lt;/em&gt;; this is how it looks like in action (with an example taken from &lt;a href=&#34;https://stackoverflow.com/questions/16129876/ggplot2-multiple-scales-legends-per-aesthetic-revisited&#34;&gt;this&lt;/a&gt; StackOverlow question)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
   geom_tile(aes(fill  =score1)) +
   scale_fill_gradient2(&amp;quot;Score 1&amp;quot;, limits = c(0, 4), 
                        low = &amp;quot;#762A83&amp;quot;, mid = &amp;quot;white&amp;quot;, high = &amp;quot;#1B7837&amp;quot;) +
   
   new_scale(&amp;quot;fill&amp;quot;) +
   
   geom_tile(aes(fill = score2), data = subset(pd, score2 != 0)) +
   scale_fill_gradient2(&amp;quot;Score 2&amp;quot;, limits = c(0, 3), 
                        low = &amp;quot;#1B7837&amp;quot;, mid = &amp;quot;white&amp;quot;, high = &amp;quot;#762A83&amp;quot;) +
   
   geom_text(data=pd, aes(label = letters, color = factor(change))) +
   scale_color_manual(&amp;quot;Change&amp;quot;, values = c(&amp;quot;black&amp;quot;, &amp;quot;#F2A11F&amp;quot;), 
                      labels = c(&amp;quot;None&amp;quot;, &amp;quot;Some&amp;quot;)) +
   coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-09-18-multiple-color-and-fill-scales-with-ggplot2_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;

&lt;p&gt;The code is a bit too long and tedious to show in this article, but you can find it on &lt;a href=&#34;https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32&#34;&gt;this gist&lt;/a&gt;. Here are the important bits.&lt;/p&gt;

&lt;p&gt;First, the &lt;code&gt;new_scale()&lt;/code&gt; function does nothing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;new_scale &amp;lt;- function(new_aes) {
   structure(ggplot2::standardise_aes_names(new_aes), class = &amp;quot;new_aes&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It merely returns an object of class &lt;code&gt;new_aes&lt;/code&gt; with a character vector with the &amp;ldquo;new&amp;rdquo; scales. All the magic is in the &lt;code&gt;+&lt;/code&gt; operator. &lt;code&gt;ggplot2&lt;/code&gt; objects are &amp;ldquo;summed&amp;rdquo; with &lt;code&gt;ggplot_add()&lt;/code&gt; function which allows to define the &amp;ldquo;add&amp;rdquo; operation for any arbitrary object to a ggplot. For the case of &lt;code&gt;new_aes&lt;/code&gt; object, this is what happens:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot_add.new_aes &amp;lt;- function(object, plot, object_name) {
   plot$layers &amp;lt;- lapply(plot$layers, bump_aes, new_aes = object)
   plot$scales$scales &amp;lt;- lapply(plot$scales$scales, bump_aes, new_aes = object)
   plot$labels &amp;lt;- bump_aes(plot$labels, new_aes = object)
   plot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It modifies each layer, scale and label and renames the relevant aesthetic to something other than &amp;ldquo;fill&amp;rdquo; or &amp;ldquo;colour&amp;rdquo;. There&amp;rsquo;s also a bit of minimally invasive surgery to geoms so that they don&amp;rsquo;t reject the newly grafted aesthetic. Is somewhat ad-hoc, to be honest, and probably not very robuts, but it works!&lt;/p&gt;

&lt;p&gt;There are many other ways to implement this and I went through &lt;a href=&#34;https://twitter.com/d_olivaw/status/1040722632675610626&#34;&gt;some iterations&lt;/a&gt;. The current implementation is friendly and consistent with the main &lt;code&gt;ggplot2&lt;/code&gt; &amp;ldquo;adding&amp;rdquo; idea, but it has some limitations and annoyances that prevent me from being 100% on board with it. I would love to get some feedback from the community 🤞!&lt;/p&gt;

&lt;h2 id=&#34;a-more-real-ish-example&#34;&gt;A more real-ish example&lt;/h2&gt;

&lt;p&gt;Why is any of this useful to me, you say? As I wrote before, being able to plot temperature and pressure in the same map with two different scales is very neat.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(metR)
library(magrittr)
time &amp;lt;- as.POSIXct(&amp;quot;1998-01-01&amp;quot;)
# Temperature and sea level pressure for January 1st 1998
atmos &amp;lt;- ReadNetCDF(&amp;quot;~/DATOS/NCEP Reanalysis/air.mon.mean.nc&amp;quot;, 
                    subset = list(level = 850, 
                                  time = time)) %&amp;gt;% 
   .[, slp:= ReadNetCDF(&amp;quot;~/DATOS/NCEP Reanalysis/slp.mon.mean.nc&amp;quot;, 
                        subset = list(time = time), out = &amp;quot;vector&amp;quot;)] %&amp;gt;% 
   .[, lon := ConvertLongitude(lon)]

ggplot(atmos, aes(lon, lat)) +
   geom_world() +
   geom_contour(aes(z = slp, color = ..level..), binwidth = 4) +
   scale_color_viridis_c(&amp;quot;Sea level pressure&amp;quot;) +
   
   new_scale_color() +   # same as `new_scale(&amp;quot;color&amp;quot;)`
   
   geom_contour(aes(z = air, color = ..level..), binwidth = 4) +
   scale_color_distiller(&amp;quot;Air Temperature&amp;quot;, palette = &amp;quot;Spectral&amp;quot;)  +
   
   scale_x_longitude(limits = c(-150, 0)) +
   scale_y_latitude(ticks = 15) +
   ggalt::coord_proj(&amp;quot;+proj=moll +lon_0=-75&amp;quot;, 
                     ylim = c(-60, 0), xlim = c(-150, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-09-18-multiple-color-and-fill-scales-with-ggplot2_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Visualising the relationship between pressure and temperature is very important for the analysis of the growth of atmospheric perturbations.&lt;/p&gt;

&lt;p&gt;Of course, with great power comes great responsibility 🕸. Mixing multiple scales for the same aesthetic should be done sparingly and only if absolutely necessary. First always ask yourself if the same information cannot be shown in a better way.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ggplot2&lt;/code&gt; doesn&amp;rsquo;t cease to amaze me. Is not only a very powerful package to construct any kind of complex plots in a stupidly simple way, but it&amp;rsquo;s also exceptionally extensible by allowing this kind of deep user customisation. ¡Long live the &lt;code&gt;ggplo2&lt;/code&gt; ✊!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Múltiples escalas de colores en ggplot2</title>
      <link>/2018/09/multiples-escalas-colores-ggplot2/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/09/multiples-escalas-colores-ggplot2/</guid>
      <description>

&lt;p&gt;tl;dr: Esta funcionalidad está ahora en el paquete &lt;a href=&#34;https://github.com/eliocamp/ggnewscale&#34;&gt;&lt;code&gt;ggnewscale&lt;/code&gt;&lt;/a&gt;! 📦
En &lt;a href=&#34;https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32&#34;&gt;este gist&lt;/a&gt; está la versión origial del código.&lt;/p&gt;

&lt;p&gt;Un dolor importante para algunos usuarios de &lt;code&gt;ggplot2&lt;/code&gt; es la imposibilidad de usar más de una escala para cada tipo de parámetro estético. Una búsqueda en StackOverflow da como resultado múltiples preguntas:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/search?q=ggplot2+two+color+scales&#34;&gt;&lt;img src=&#34;../images/ggplo2_twoscales_so_small.jpg&#34; alt=&#34;preguntas stack overflow&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pero ninguna respuesta tiene una solución realmente satisfactoria; la mayoría son del tipo &amp;ldquo;no se puede, pero esta es otra forma de graficar tus datos&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Tener varias escalas distintas para el mismo parámetro estético tiene riesgos, pero también beneficios. Cuando las escalas son bien distintas, permiten condensar más información en un mismo gráfico, facilitando la visualización de interacciones entre distintas variables. En ciencias de la atmósfera, por ejemplo, es muy habitual graficar temperatura y presión con líneas de contorno usando distintas escalas de colores.&lt;/p&gt;

&lt;p&gt;Recientemente, gracias a &lt;a href=&#34;https://github.com/tidyverse/ggplot2/pull/2555&#34;&gt;un aporte&lt;/a&gt; de Claus Wilke, &lt;code&gt;ggplot2&lt;/code&gt; permite usar &amp;ldquo;parámetros estéticos no estándar&amp;rdquo;. Por ejemplo, se puede hacer &lt;code&gt;scale_color_continuous(aesthetics = &amp;quot;fill&amp;quot;)&lt;/code&gt; para especificar la escala del &lt;code&gt;fill&lt;/code&gt;. Esto, junto con el uso de &lt;code&gt;ggplot_add()&lt;/code&gt; para &amp;ldquo;sumarle&amp;rdquo; cualquier elemento a un objecto de ggplot2 (gracias a Hiroaki Yutani por &lt;a href=&#34;https://yutani.rbind.io/post/2017-11-07-ggplot-add&#34;&gt;su post&lt;/a&gt;!), permite hacer algunas triquiñuelas para agregar múltiples escalas de color (o fill, o lo que sea).&lt;/p&gt;

&lt;p&gt;Déjenme ilustrar con un ejemplo sacado de &lt;a href=&#34;https://stackoverflow.com/questions/16129876/ggplot2-multiple-scales-legends-per-aesthetic-revisited&#34;&gt;esta pregunta&lt;/a&gt; de StackOverflow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
   geom_tile(aes(fill  =score1)) +
   scale_fill_gradient2(&amp;quot;Score 1&amp;quot;, limits = c(0, 4), 
                        low = &amp;quot;#762A83&amp;quot;, mid = &amp;quot;white&amp;quot;, high = &amp;quot;#1B7837&amp;quot;) +
   
   new_scale(&amp;quot;fill&amp;quot;) +
   
   geom_tile(aes(fill = score2), data = subset(pd, score2 != 0)) +
   scale_fill_gradient2(&amp;quot;Score 2&amp;quot;, limits = c(0, 3), 
                        low = &amp;quot;#1B7837&amp;quot;, mid = &amp;quot;white&amp;quot;, high = &amp;quot;#762A83&amp;quot;) +
   
   geom_text(data=pd, aes(label = letters, color = factor(change))) +
   scale_color_manual(&amp;quot;Change&amp;quot;, values = c(&amp;quot;black&amp;quot;, &amp;quot;#F2A11F&amp;quot;), 
                      labels = c(&amp;quot;None&amp;quot;, &amp;quot;Some&amp;quot;)) +
     coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-09-17-multiples-escalas-de-colores-en-ggplot2_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;cómo-funciona&#34;&gt;Cómo funciona&lt;/h2&gt;

&lt;p&gt;El código es un tanto largo y tedioso para ponerlo en un artículo (pueden encontrarlo en &lt;a href=&#34;https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32&#34;&gt;este gist&lt;/a&gt;) así que acá voy a hablar de la parte más importante.&lt;/p&gt;

&lt;p&gt;Primero, la función &lt;code&gt;new_scale()&lt;/code&gt; no hace nada. Sólo crea un objeto de clase &lt;code&gt;new_aes&lt;/code&gt; que no es más que un vector de texto con las escalas &amp;ldquo;nuevas&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;new_scale &amp;lt;- function(new_aes) {
  structure(ggplot2::standardise_aes_names(new_aes), class = &amp;quot;new_aes&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La magia está en el &lt;code&gt;+&lt;/code&gt;. Al sumar objectos de ggplot, se usa la función genérica &lt;code&gt;ggplot_add()&lt;/code&gt;. Este es el método para los objectos de clase &lt;code&gt;new_aes&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot_add.new_aes &amp;lt;- function(object, plot, object_name) {
  plot$layers &amp;lt;- lapply(plot$layers, bump_aes, new_aes = object)
  plot$scales$scales &amp;lt;- lapply(plot$scales$scales, bump_aes, new_aes = object)
  plot$labels &amp;lt;- bump_aes(plot$labels, new_aes = object)
  plot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lo que hace es agarrar cada capa, escala y etiqueta y cambiarle el nombre de los parámetros estéticos; efectivamente les agrega la palabra &amp;ldquo;_new&amp;rdquo; de manera que el &amp;ldquo;color&amp;rdquo; pasa a ser &amp;ldquo;color_new&amp;rdquo;. Hay que hacer un poco de cirugía interna mínimamente invasiva (la laparoscopía de la programación) para que los geoms no se vuelvan locos al recibir un data frame con una columna llamada &amp;ldquo;color_new&amp;rdquo; en vez de &amp;ldquo;color&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Hay varias formas de hacer lo mismo y podrán ver que el proyecto pasó por &lt;a href=&#34;https://twitter.com/d_olivaw/status/1040722632675610626&#34;&gt;varias iteraciones&lt;/a&gt;. Todavía no estoy 100% de que esta forma sea totalmente amigable y sería genial recibir un poco de feedback de la comunidad 🤞.&lt;/p&gt;

&lt;h2 id=&#34;ejemplo-real&#34;&gt;Ejemplo real&lt;/h2&gt;

&lt;p&gt;¿Para qué sirve todo esto en definitiva? Bueno, como decía antes, una posibilidad es la de graficar temperatura y presión en un mismo mapa usando dos escalas distintas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(metR)
library(magrittr)
time &amp;lt;- &amp;quot;1998-01-01&amp;quot;
# Temperatura y presión a nivel del mar para el 1° de enero de 1998
atmos &amp;lt;- ReadNetCDF(&amp;quot;~/DATOS/NCEP Reanalysis/air.mon.mean.nc&amp;quot;, 
                          subset = list(level = 850, 
                                        time = time)) %&amp;gt;% 
   .[, slp:= ReadNetCDF(&amp;quot;~/DATOS/NCEP Reanalysis/slp.mon.mean.nc&amp;quot;, 
                  subset = list(time = time), out = &amp;quot;vector&amp;quot;)] %&amp;gt;% 
   .[, lon := ConvertLongitude(lon)]

ggplot(atmos, aes(lon, lat)) +
   geom_world() +
   geom_contour(aes(z = slp, color = ..level..), binwidth = 4) +
   scale_color_viridis_c(&amp;quot;Presión a nivel del mar&amp;quot;) +
   
   new_scale_color() +   # lo mismo que `new_scale(&amp;quot;color&amp;quot;)`
   
   geom_contour(aes(z = air, color = ..level..), binwidth = 4) +
   scale_color_distiller(&amp;quot;Temperatura del aire&amp;quot;, palette = &amp;quot;Spectral&amp;quot;)  +
   
   scale_x_longitude(limits = c(-150, 0)) +
   scale_y_latitude(ticks = 15) +
   ggalt::coord_proj(&amp;quot;+proj=moll +lon_0=-75&amp;quot;, 
                     ylim = c(-60, 0), xlim = c(-150, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-09-17-multiples-escalas-de-colores-en-ggplot2_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Observar la relación entre la presión y la temperatura permite analizar procesos del crecimiento de las perturbaciones de la atmósfera.&lt;/p&gt;

&lt;p&gt;Por supuesto, un gran poder conlleva una gran responsabilidad 🕸. Mezclar muchas escalas no es para cualquiera y debe ser usado bien y sólo si es absolutamente necesario. Siempre conviene pensar si no hay una mejor manera de mostrar lo mismo.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ggplot2&lt;/code&gt; nunca deja de maravillarme. No sólo es un paquete poderosísimo para hacer toda clase gráficos de una manera estúpidamente simple y amigable, sino que es excepcionalmente extensible permitiendo este tipo de modificación por parte de los usuarios. ¡Larga vida a &lt;code&gt;ggplot2&lt;/code&gt; ✊!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wrapping around ggplot2 with ggperiodic</title>
      <link>/2018/08/periodic-data-ggplot2-ggperiodic/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/08/periodic-data-ggplot2-ggperiodic/</guid>
      <description>

&lt;p&gt;As an atmospheric scientists, a lot of my research consists on plotting and looking at global fields of atmospheric variables like pressure, temperature and the like. Since our planet is a sphere (well, &lt;a href=&#34;https://chem.tufts.edu/answersinscience/relativityofwrong.htm&#34;&gt;almost&lt;/a&gt;), it is unbound and so longitude is a &lt;em&gt;periodic&lt;/em&gt; dimension. That is, to the right of 180°E you go back to 180°W. But ggplot2 and other plotting systems, for the most part, assume linear dimensions.&lt;/p&gt;

&lt;p&gt;To show why this is a problem, let us plot a fairly basic scalar field defined in a regular grid with 2.5° of resolution for the southern hemisphere.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data, aes(lon, lat)) +
   geom_contour_fill(aes(z = gh)) +
   map.SH +
   scale_fill_viridis_c(&amp;quot;Geopotential\nHeight&amp;quot;) +
   coord_polar()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-08-21-wrapping-around-ggplot2_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Did you spot it? The field is defined between 0° and 357.5°. Because 360° is the same as 0°, you would be double counting if you had a value at both extremes. But since ggplot2 only &amp;lsquo;sees&amp;rsquo; the data you feed to it, it fails to plot the implied data between 357.5° and 360°.&lt;/p&gt;

&lt;h2 id=&#34;defining-the-problem&#34;&gt;Defining the problem&lt;/h2&gt;

&lt;p&gt;The scope of the problem as I see it is much broader than global maps of atmospheric data.&lt;/p&gt;

&lt;p&gt;We have a periodic function defined at regular &lt;em&gt;or irregular&lt;/em&gt; locations inside one period. Since this finite number of locations actually define the infinite domain of the function, when we plot we want to &lt;em&gt;wrap&lt;/em&gt; these locations around any arbitrary domain we need. This should be fast and automatic.&lt;/p&gt;

&lt;p&gt;This translates, I think, to having two distinct domains. On the one hand there&amp;rsquo;s the &lt;em&gt;period&lt;/em&gt; defined by the sampled data, and on the other there&amp;rsquo;s the &lt;em&gt;range&lt;/em&gt; we want to &lt;em&gt;wrap&lt;/em&gt; this data around. The first is a property of the &lt;em&gt;data&lt;/em&gt;, the second one is a property of the &lt;em&gt;visualisation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Somewhere on the plotting process, then, &lt;code&gt;ggplot2&lt;/code&gt; must repeat the data so that it wraps it around the desired range.&lt;/p&gt;

&lt;h2 id=&#34;solving-the-problem&#34;&gt;Solving the problem&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/eliocamp/ggperiodic&#34;&gt;ggperiodic&lt;/a&gt; package embodies these ideas. First, we define the period of each of the periodic variables on our data. In this case, &lt;code&gt;lon&lt;/code&gt; is periodic between 0° and 306°&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggperiodic)
data &amp;lt;- periodic(data, lon = c(0, 360))
head(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##     lon lat level       gh       time
## 1:  0.0 -30   200 12333.66 2017-01-01
## 2:  2.5 -30   200 12333.17 2017-01-01
## 3:  5.0 -30   200 12335.23 2017-01-01
## 4:  7.5 -30   200 12339.44 2017-01-01
## 5: 10.0 -30   200 12344.92 2017-01-01
## 6: 12.5 -30   200 12351.60 2017-01-01
## lon = [0; 360]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;data&lt;/code&gt; is of a new class of &amp;ldquo;periodic_df&amp;rdquo;, but so far the actual content of &lt;code&gt;data&lt;/code&gt; has remain unchanged. The magic comes on the second step 🌟. Now we can &lt;code&gt;wrap&lt;/code&gt; the data in any arbitrary range. For example, lets change longitude to be between -180° and 180°&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;data180 &amp;lt;- wrap(data, lon = c(-180, 180))
head(data180)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##       lon lat level       gh       time
## 1: -180.0 -30   200 12311.90 2017-01-01
## 2: -177.5 -30   200 12310.48 2017-01-01
## 3: -175.0 -30   200 12311.84 2017-01-01
## 4: -172.5 -30   200 12316.52 2017-01-01
## 5: -170.0 -30   200 12324.02 2017-01-01
## 6: -167.5 -30   200 12333.00 2017-01-01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You &lt;em&gt;could&lt;/em&gt; do this manually every time you what to plot your data, but there&amp;rsquo;s a better way. When ggplot2 gets a &lt;code&gt;data&lt;/code&gt; argument, it doesn&amp;rsquo;t just pass it along. First, it feeds it to a function called &lt;code&gt;fortify()&lt;/code&gt;. ggperiodic implements &lt;code&gt;fortify.periodic_df()&lt;/code&gt; so that the wrapping can be performed automatically at plotting time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data, aes(lon, lat)) +
   geom_contour_fill(aes(z = gh)) +
   map.SH +
   scale_fill_viridis_c(&amp;quot;Geopotential\nHeight&amp;quot;) +
   coord_polar()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-08-21-wrapping-around-ggplot2_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is completely automatic 🤖, robust to transformations and very friendly to the user. By default the data is wrapped around the same range as the period, but that can be changed using the same syntax as with &lt;code&gt;wrap()&lt;/code&gt;. For example, it could be useful to show three whole periods so that any 360° range could be seen with no interruptions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data, aes(lon, lat), lon = c(0, 360)*3) +
   geom_contour_fill(aes(z = gh)) +
   scale_fill_viridis_c(&amp;quot;Geopotential\nHeight&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-08-21-wrapping-around-ggplot2_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Since ggplot2 also uses &lt;code&gt;fortify()&lt;/code&gt; for data passed to geoms, it also works there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot() +
   geom_contour_fill(data = data, aes(lon, lat, z = gh), lon = c(-180, 180)) +
   map.SH2 +
   scale_fill_viridis_c(&amp;quot;Geopotential\nHeight&amp;quot;) +
   coord_polar()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning: Ignoring unknown parameters: lon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-08-21-wrapping-around-ggplot2_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this case works well but there are some limitations related to the somewhat ugly hack I had to use to pass the extra parameters to &lt;code&gt;fortify.periodic_df()&lt;/code&gt;. If used on a layer, the name of the periodic dimension must not be the same as any possible aesthetic or any other arguments passed to the geom, i.e. having &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;binwidth&lt;/code&gt; as the periodic dimension is verboten. Also there&amp;rsquo;s an annoying warning 😤.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve tried to make the periodic information &lt;em&gt;sticky&lt;/em&gt; (thanks to the &lt;a href=&#34;https://github.com/decisionpatterns/sticky&#34;&gt;sticky&lt;/a&gt; 📦) across data manipulations, but I&amp;rsquo;ve still haven&amp;rsquo;t tested thoroughly. And since I mostly use data.table, I&amp;rsquo;m not familiar enough with dplyr to do know the whole range of possible transformations. &lt;a href=&#34;https://github.com/eliocamp/ggperiodic/issues&#34;&gt;Issues&lt;/a&gt; are welcome!&lt;/p&gt;

&lt;p&gt;In any case, if or when you get tired of all this nonsense, you can just remove all periodicity information and go on with your life.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;data &amp;lt;- unperiodic(data)
head(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##     lon lat level       gh       time
## 1:  0.0 -30   200 12333.66 2017-01-01
## 2:  2.5 -30   200 12333.17 2017-01-01
## 3:  5.0 -30   200 12335.23 2017-01-01
## 4:  7.5 -30   200 12339.44 2017-01-01
## 5: 10.0 -30   200 12344.92 2017-01-01
## 6: 12.5 -30   200 12351.60 2017-01-01
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Tu propio smooth en geom_smooth()</title>
      <link>/2018/06/tu-propio-geom-smooth/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/06/tu-propio-geom-smooth/</guid>
      <description>&lt;p&gt;Algo increíblemente satisfactorio de ggplot2 es la posibilidad de ajustar curvas a los datos de manera súper fácil con &lt;code&gt;geom_smooth()&lt;/code&gt;. Para mi investigación estaba mirando la relación entre dos ángulos y me di cuenta que la recta ajustada por cuadrados mínimos no estaba funcionando para ilustrar la obvia estructura que había en los datos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)

df &amp;lt;- readRDS(&amp;quot;data/smooth_example.Rds&amp;quot;)

ggplot(df, aes(pc.angle, phase)) +
   geom_point() +
   geom_smooth(method = &amp;quot;lm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Se me ocurrió que un mejor modelo podría ser usando el estimador de &lt;a href=&#34;https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator&#34;&gt;Theil-Sen&lt;/a&gt;, que es la mediana de todas las pendientes entre dos puntos distintos y está  implementado en el paquete mblm. El problema es que al usar esa función como método, me dio este críptico mensaje de error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(df, aes(pc.angle, phase)) +
   geom_point() +
   geom_smooth(method = &amp;quot;mblm::mblm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning: Computation failed in `stat_smooth()`:
## object &#39;mblm::mblm&#39; of mode &#39;function&#39; was not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;🤔&lt;/p&gt;

&lt;p&gt;Tuve que ponerme a leer el código de ggplot2 para entender de dónde venía el problema, pero gracias a eso aprendí más sobre cómo funciona &lt;code&gt;geom_smooth()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;geom_smooth()&lt;/code&gt; acepta cualquier método para hacer el modelo, pero con dos detalles importantes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;la función que hace el modelo debe aceptar una fórmula como primer argumento y tener argumentos &lt;code&gt;data&lt;/code&gt; y &lt;code&gt;weigths&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;el objeto que devuelve la función debe tener un método para &lt;code&gt;predictdf()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Lo primero es fácil de entender. Dentro de &lt;code&gt;geom_smooth()&lt;/code&gt;, ggplot2 básicamente llama algo así como &lt;code&gt;lm(formula, data, weights, ...)&lt;/code&gt;. Si la función no acepta alguno de esos argumentos, nos encontramos con un error. La función &lt;code&gt;mblm&lt;/code&gt; no entiende el argumento &lt;code&gt;weights&lt;/code&gt;. La solución en ese caso fue crear mi propia función que llame a &lt;code&gt;mblm::mblm()&lt;/code&gt; descartando ese argumento (y de paso le puse un nombre más inteligible).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;TheilSen &amp;lt;- function(..., weights = NULL) {
   mblm::mblm(...)
}

ggplot(df, aes(pc.angle, phase)) +
   geom_point() +
   geom_smooth(method = &amp;quot;TheilSen&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;¡Mucho mejor! 🕺&lt;/p&gt;

&lt;p&gt;El segundo requisito en este ejemplo viene &amp;ldquo;gratis&amp;rdquo; porque &lt;code&gt;mblm()&lt;/code&gt; es compatible con los métodos de &lt;code&gt;predict()&lt;/code&gt; de &lt;code&gt;lm()&lt;/code&gt;, pero no siempre es así. En este segundo ejemplo, quiero hacer un suavizado que se base en hacer la transformada de fourier y eliminar una determinada cantidad de frecuencias. Una función que hace eso sería esta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# n es la proporción de frecuencias que vamos a eliminar. 
# n = 0.5 significa sacar la mitad.
FFTSmooth &amp;lt;- function(formula, data, weights, n = 0.5) {
   f &amp;lt;- fft(data$y)
   keep &amp;lt;- c(0, seq_len(floor(length(f)/2*n)))
   keep &amp;lt;- c(keep + 1, length(f) - keep[keep != 0] + 1)
   f[-keep] &amp;lt;- 0 + 0i
   Re(fft(f, inverse = T))/length(f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notar que la función ignora por completo la formula y los pesos, pero hay que ponerlos para que funcione en &lt;code&gt;geom_smooth()&lt;/code&gt;. Esta función sirve en el sentido de que hace un suavizado correcto de los datos (¡siempre que estén definidos en intervalos de x regulares!), pero si usamos &lt;code&gt;geom_smooth(method = &amp;quot;FFTSmooth&amp;quot;)&lt;/code&gt; ggplot2 nos va a tirar un error:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Computation failed in &lt;code&gt;stat_smooth()&lt;/code&gt;: no applicable method for &amp;lsquo;predict&amp;rsquo; applied to an object of class &amp;ldquo;c(&amp;lsquo;double&amp;rsquo;, &amp;lsquo;numeric&amp;rsquo;)&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El problema es que &lt;code&gt;FTTSmooth()&lt;/code&gt; devuelve los valores suavizados, pero lo que tiene que devolver es un &amp;ldquo;modelo&amp;rdquo; que devuelva los valores suavizados al hacer &lt;code&gt;predictdf(model, xseq, se, level)&lt;/code&gt; (donde &lt;code&gt;xseq&lt;/code&gt; son los puntos de x donde se evalúa el modelo, &lt;code&gt;se&lt;/code&gt; es TRUE o FALSE según si queremos un intervalo de confianza y &lt;code&gt;level&lt;/code&gt; es el nivel de confianza de dicho intervalo). Esta segunda implementación del suavizado sí funciona.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;FFTSmooth &amp;lt;- function(formula, data, weights, n = 0.5) {
   f &amp;lt;- fft(data$y)
   keep &amp;lt;- c(0, seq_len(floor(length(f)/2*n)))
   keep &amp;lt;- c(keep + 1, length(f) - keep[keep != 0] + 1)
   f[-keep] &amp;lt;- 0 + 0i
   
   model &amp;lt;- list(x = data$x, pred = Re(fft(f, inverse = T))/length(f))
   class(model) &amp;lt;- &amp;quot;my_smooth&amp;quot;
   return(model)
}

predictdf.my_smooth &amp;lt;- function(model, xseq, se, level) {
   data.frame(x = model$x, y = model$pred)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La diferencia importante en &lt;code&gt;FFTSmooth()&lt;/code&gt; es que ahora devuelve una lista con los valores de &lt;code&gt;x&lt;/code&gt; y los de &lt;code&gt;y&lt;/code&gt; suavizados pero que tiene clase &amp;ldquo;my_smooth&amp;rdquo;. Cuando ggplot2 llame &lt;code&gt;predictdf(model, ...)&lt;/code&gt;, R va a buscar la función &lt;code&gt;predictdf.my_smooth()&lt;/code&gt; (así es básicamente cómo funcionan las &lt;a href=&#34;http://adv-r.had.co.nz/S3.html&#34;&gt;clases&lt;/a&gt; en R). &lt;code&gt;predictdf.my_smooth()&lt;/code&gt;, por su parte, ignora casi todos los inputs y simplemente devuelve un &lt;code&gt;data.frame&lt;/code&gt; con los valores de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; guardados en el modelo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(42)
df &amp;lt;- data.frame(x = seq(0, 360, length.out = 100))
df$y &amp;lt;- with(df, 5*cos(x*pi/180) + 3*sin(x*pi/180*3) + 1.6*rnorm(100))

ggplot(df, aes(x, y)) +
   geom_point() +
   geom_smooth(method = &amp;quot;FFTSmooth&amp;quot;, method.args = list(n = 0.2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;¡Y listo! 🍰&lt;/p&gt;

&lt;p&gt;Sólo hace falta definir &lt;code&gt;predictdf.my_smooth()&lt;/code&gt; una vez. Por ejemplo, si queremos usar una Spline.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;SplineSmooth &amp;lt;- function(formula, data, weights, span = 0.5, ...) {
   pred &amp;lt;- smooth.spline(data$x, data$y, df = length(data$y)*span,...)$y
   # print(pred[1:10])
   model &amp;lt;- list(x = data$x, pred = pred)
   class(model) &amp;lt;- &amp;quot;my_smooth&amp;quot;
   model
}

ggplot(df, aes(x, y)) +
   geom_point() +
   geom_smooth(method = &amp;quot;SplineSmooth&amp;quot;, method.args = list(span = 0.1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-06-01-tu-propio-smooth-en-geom-smooth_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Un resultado similar puede conseguirse de manera más directa con &lt;a href=&#34;../2018/05/como-hacer-un-stat-generico-en-ggplot2/&#34;&gt;&lt;code&gt;stat_rasa()&lt;/code&gt;&lt;/a&gt;, pero me pareció interesante urgar un poco dentro del funcionamiento de ggplot2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hacer una presentación de PowerPoint a partir de rmarkdown</title>
      <link>/2018/05/presentacion-powerpoint-rmarkdown/</link>
      <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/05/presentacion-powerpoint-rmarkdown/</guid>
      <description>&lt;p&gt;La interfaz entre usuarios de knitr/markdown y word/powerpoint no deja de ser áspera ya que es difícil cambiar el workflow propio para acomodar el de otras personas. En particular, es muy común tener que colaborar con personas que se sienten mucho más cómodas trabajando con presentaciones en PowerPoint que en las creadas con beamer o ioslides. Una forma de reducir la fricción sería la de generar un ppt automáticamente a partir de una archivo de markdown.&lt;/p&gt;

&lt;p&gt;La clave está en &amp;ldquo;secuestrar&amp;rdquo; la función que knitr ejecuta cuando se encuentra con un plot y agregar la imagen a un ppt con el paquete &lt;a href=&#34;https://davidgohel.github.io/officer/index.html&#34;&gt;&lt;code&gt;officer&lt;/code&gt;&lt;/a&gt;. Lo primero necesario es un archivo con un template. De este archivo va a salir el patrón para agregar distintas diapositivas según lo que queramos insertar. Esto se puede editar cambiando el &lt;a href=&#34;https://support.office.com/es-es/article/%C2%BFqu%C3%A9-es-un-patr%C3%B3n-de-diapositivas-b9abb2a0-7aef-4257-a14e-4329c904da54&#34;&gt;Patrón de Diapositivas&lt;/a&gt;. Como yo soy muy básico, creé uno que tiene una imagen con un texto abajo y nada más y lo llamé &amp;ldquo;figure&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Una vez hecho esto, hay que poner esto en el primer chunk de setup:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(officer)
library(magrittr)

## Opciones que hay que cambiar. 
ppt &amp;lt;- TRUE                        # ¿quiero que salga un ppt?
pptfile &amp;lt;- &amp;quot;figuras.pptx&amp;quot;          # nombre de archivo del ppt saliente
ppttemplate &amp;lt;- &amp;quot;ppttemplate.pptx&amp;quot;  # nombre del template

# Crea el archivo inicial
if (ppt == TRUE){
   my_pres &amp;lt;- read_pptx(ppttemplate)
   print(my_pres, pptfile)   
}

# Hay que apagar la cache en los chunks con figuras
knitr::opts_hooks$set(fig.cap = function(options) {
   if (ppt == TRUE) options$cache &amp;lt;- FALSE
   options
})

# Agrega un slide con el gráfico y el caption
# para cada chunk con figuras
knit_plot &amp;lt;- knitr::knit_hooks$get(&amp;quot;plot&amp;quot;)

knitr::knit_hooks$set(plot = function(x, options) {
   if (ppt == TRUE) {
      if (inherits(last_plot(), &amp;quot;gg&amp;quot;)) {
         read_pptx(pptfile)  %&amp;gt;%
            add_slide(layout = &amp;quot;figure&amp;quot;, master = &amp;quot;Office Theme&amp;quot;) %&amp;gt;%
            ph_with_gg(last_plot(), type = &amp;quot;pic&amp;quot;) %&amp;gt;%
            ph_with_text(options$fig.cap, type = &amp;quot;body&amp;quot;) %&amp;gt;%
            print(pptfile)
         set_last_plot(NULL)   # remove last_plot()
      } else {
         read_pptx(pptfile)  %&amp;gt;%
            add_slide(layout = &amp;quot;figure&amp;quot;, master = &amp;quot;Office Theme&amp;quot;) %&amp;gt;%
            rvg::ph_with_vg(code = eval(parse(text = options$code)), 
                            type = &amp;quot;pic&amp;quot;) %&amp;gt;%
            ph_with_text(options$fig.cap, type = &amp;quot;body&amp;quot;) %&amp;gt;% 
            print(pptfile)
      }
   }
   knit_plot(x, options)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hay dos cosas importantes. Primero es setear un &lt;code&gt;opts_hook&lt;/code&gt; que se ejecute siempre que la opción &lt;code&gt;fig.cap&lt;/code&gt; no sea &lt;code&gt;NULL&lt;/code&gt; que desactive la cache. Esto es porque sino knitr no ejecuta nada de lo que sigue y entonces no agrega la figura al ppt.&lt;/p&gt;

&lt;p&gt;Luego está la parte más jugosa. Cambiamos el &lt;code&gt;knit_hook&lt;/code&gt; para el &lt;code&gt;plot&lt;/code&gt; para que antes de hacer lo que hace siempre (que primero guardamos con &lt;code&gt;knitr::knit_hooks$get(&amp;quot;plot&amp;quot;)&lt;/code&gt;) le decimos que guarde el plot en una nueva diapositiva. El código es ligeramente distinto si se trata de un gráfico de &lt;code&gt;ggplot2&lt;/code&gt; o uno de &lt;code&gt;base&lt;/code&gt;. En el caso de &lt;code&gt;ggplot2&lt;/code&gt;, usamos la función &lt;code&gt;last_plot()&lt;/code&gt; para guardar el último plot generado en la nueva diapositiva y luego seteamos que el &lt;code&gt;last_plot&lt;/code&gt; sea &lt;code&gt;NULL&lt;/code&gt; (por si el siguiente gráfico que hay que guardar es uno en base). Si es base, hay que pasarle el código del chunk evaluado a la función &lt;code&gt;ph_with_vg()&lt;/code&gt;, que crea un gráfico de vectores a partir de un gráfico base.&lt;/p&gt;

&lt;p&gt;Y listo. Al &lt;em&gt;knitear&lt;/em&gt; el documento se va a generar el pdf o html y, además, el ppt.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../images/ppt.jpg#center&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Así como está es una versión mínima que cubre mis necesidades. Sólo tiene en cuenta los gráficos con epígrafe, no funciona sin un chunk genera varias figuras, el proceso de renderizar todo es lento (porque desactiva la cache) y peor aún si los chunks que generan figuras también tienen código que manipula datos. Además, no guarda tablas ni texto plano.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Arte reproducible del Subte de Buenos Aires</title>
      <link>/2018/05/arte-reproducible-del-subte-de-buenos-aires/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/05/arte-reproducible-del-subte-de-buenos-aires/</guid>
      <description>&lt;p&gt;El sábado pasado estábamos en el subte con mi novia y pasamos por la estación Ángel Gallardo de la Línea B y notamos que tenía &lt;a href=&#34;http://www.buenosaires.gob.ar/noticias/arte-urbano-en-la-estacion-angel-gallardo&#34;&gt;unas ilustraciones&lt;/a&gt; en las paredes hechas a partir de líneas de distinto grosor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../images/subte.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Charlamos un poco sobre ese estilo y cómo se podía replicar con &lt;code&gt;ggplot2&lt;/code&gt; usando el paquete &lt;a href=&#34;https://github.com/clauswilke/ggridges&#34;&gt;&lt;code&gt;ggridges&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lo primero que hago es leer la imagen. Este paso depende del formato (a menos que haya alguna forma de seleccionar el formato correcto automáticamente, pero no conozco). La función &lt;code&gt;readJPEG&lt;/code&gt; del paquete &lt;code&gt;jpeg&lt;/code&gt; convierte una imagen en un array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;im &amp;lt;- jpeg::readJPEG(&amp;quot;../../static/images/example.jpg&amp;quot;)
str(im)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  num [1:400, 1:400, 1:3] 1 1 1 1 1 1 1 1 1 1 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La imagen es de 400x400 y tiene 3 canales (rojo, verde y azul). Lo que voy a hacer es pasarla a escala de grises y luego transformar los datos en un data.frame para poder graficarlo con &lt;code&gt;ggplot2&lt;/code&gt;. El &amp;ldquo;algoritmo&amp;rdquo; que uso acá para pasar de color a grises es simplemente sumar la intensidad de cada color y luego dividir por 3. No sé si es la manera más correcta, pero funciona. Notar que al nombrar las dimensiones del array, revierto el orden de las coordenadas y con &lt;code&gt;rev&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;im &amp;lt;- apply(im, c(1, 2), sum)   # para cada valor de las primeras 2 dimensiones, suma
im &amp;lt;- im/3

ys &amp;lt;- nrow(im)
xs &amp;lt;- ncol(im)
dimnames(im) &amp;lt;- list(y = rev(seq_len(nrow(im))), x = seq_len(ncol(im)))
im &amp;lt;- reshape2::melt(im)
str(im)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## &#39;data.frame&#39;:	160000 obs. of  3 variables:
##  $ y    : int  400 399 398 397 396 395 394 393 392 391 ...
##  $ x    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ value: num  1 1 1 1 1 1 1 1 1 1 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora que tengo un lindo data.frame, puedo graficarlo. La idea es, para cada línea horizontal (es decir, cada valor de y), graficar un área blanca cuya altura sea proporcional al valor de gris. Además, sólo voy a graficar cada 10 líneas para bajar un poco la resolución y se note más el efecto.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
library(ggridges)
plotim &amp;lt;- subset(im, y  %in% seq(1, ys, by = 10))
ggplot(plotim, aes(x, y)) +
   geom_ridgeline(aes(height = value*9, group = y), 
                  fill = &amp;quot;white&amp;quot;, color = NA) +
   theme(panel.background = element_rect(fill = &amp;quot;black&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-20-arte-reproducible-del-subte-de-buenos-aires_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Le falta pulir algunas cosas, pero va bien!&lt;/p&gt;

&lt;p&gt;La imagen del subte que quiero reproducir en realidad no usa líneas rectas sino sinusoidales. No estoy seguro si eso se puede reproducir con &lt;code&gt;geom_ridgeline()&lt;/code&gt; pero a esta altura decidí meterme con un geom de más bajo nivel. Usando &lt;code&gt;geom_ribbon()&lt;/code&gt; puedo poner directamente cuál es el máximo y el mínimo del área, entonces puedo meter un coseno con la amplitud, período y fase que quiera. Además, como esto es Arte&lt;sup&gt;&amp;trade;&lt;/sup&gt;, conviene sacar las leyendas y los ejes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;scale &amp;lt;- 10
per  &amp;lt;- 6
phase &amp;lt;- 0.001
ampl &amp;lt;- scale/5
forecolor &amp;lt;- &amp;quot;white&amp;quot;
backcolor &amp;lt;- &amp;quot;#110C0E&amp;quot;

ggplot(subset(im, y %in% seq(1, ys, by = scale - 1)), aes(x)) +
   geom_ribbon(aes(ymin = y + ampl*cos(x/max(x)*2*pi*per - phase*y) - value*scale/2, 
                   ymax = y + ampl*cos(x/max(x)*2*pi*per - phase*y) + value*scale/2,
                   group = y), fill = forecolor) +
   scale_x_continuous(expand = c(0, 0)) +
   scale_y_continuous(expand = c(0, 0)) +
   coord_equal() +
   theme_void() +
   theme(plot.background = element_rect(fill = backcolor))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-20-arte-reproducible-del-subte-de-buenos-aires_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sólo para que sea más divertido, acá abajo está el código completo, armado en una función y que además permite hacer un efecto medio warholiano si se usan los 3 colores en vez de una escala de grises.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Ridgefy &amp;lt;- function(file, scale = 10, ampl = 1/5, per = 6, phase = 0,
                    forecolor = &amp;quot;white&amp;quot;, backcolor = &amp;quot;black&amp;quot;, ncol = 3) {
   im &amp;lt;- jpeg::readJPEG(file)
   ys &amp;lt;- nrow(im)
   xs &amp;lt;- ncol(im)
   if (length(forecolor) == 3) {
      dimnames(im) &amp;lt;- list(y = rev(seq_len(ys)),
                           x = seq_len(xs),
                           forecolor = forecolor)
      im &amp;lt;- reshape2::melt(im)
   } else {
      im &amp;lt;- apply(im, c(1, 2), sum)
      im &amp;lt;- im/max(im)
      
      dimnames(im) &amp;lt;- list(y = rev(seq_len(ys)), 
                           x = seq_len(xs))
      im &amp;lt;- reshape2::melt(im)
      im$forecolor = forecolor
   }

   ampl &amp;lt;- scale*ampl
   
   ggplot(subset(im, y %in% seq(1, ys, by = scale - 1)), aes(x)) +
      geom_ribbon(aes(ymin = y + ampl*cos(x/max(x)*2*pi*per - phase*y) - value*scale/2, 
                      ymax = y + ampl*cos(x/max(x)*2*pi*per - phase*y) + value*scale/2,
                      group = y,
                      fill = forecolor)) +
      scale_fill_manual(values = forecolor, guide = FALSE) +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      coord_equal() +
      theme_void() +
      facet_wrap(~forecolor, ncol = ncol) +
      theme(plot.background = element_rect(fill = backcolor), 
            panel.spacing = unit(0, &amp;quot;lines&amp;quot;),
            strip.text = element_blank(),
            strip.background = element_blank())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para terminar, por qué no hacer una imagen bien meta y usar este estilo para transformar la imagen original que me dio la idea.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Ridgefy(&amp;quot;../../static/images/subte.jpg&amp;quot;, scale = 4, ampl = 0.1,
        forecolor = &amp;quot;#EE0000&amp;quot;, 
        backcolor = &amp;quot;#6E1414&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-20-arte-reproducible-del-subte-de-buenos-aires_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Como hacer un stat genérico en ggplot2</title>
      <link>/2018/05/como-hacer-un-stat-generico-en-ggplot2/</link>
      <pubDate>Wed, 16 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/05/como-hacer-un-stat-generico-en-ggplot2/</guid>
      <description>&lt;p&gt;Hace un tiempo que venía pensando que si bien &lt;code&gt;ggplot2&lt;/code&gt; es genial y tiene un montón de geoms y stats, le faltaba la opción de extenderlo a stats y geoms creados por el usuario. Luego, aprendí que &lt;code&gt;ggplot2&lt;/code&gt; tiene un excelente sistema para extenderlo y empecé a crear mis propios stats. Pero aún así, hacer un &lt;code&gt;stat&lt;/code&gt; específico cada vez que uno quiere hacer un plot en particular es demasiado complicado.&lt;/p&gt;

&lt;p&gt;Entonces se me ocurrió una posible solución. Hacer un &lt;code&gt;stat&lt;/code&gt; &lt;em&gt;genérico&lt;/em&gt;; una tabula rasa que acepte una función creada por el usuario. Nativamente &lt;code&gt;ggplot2&lt;/code&gt; viene con &lt;code&gt;stat_summary()&lt;/code&gt; que hace algo similar, pero sólo acepta funciones que (como su nombre lo indica) sumaricen los datos de alguna manera. Lo que yo quería era algo totalmente genérico y este es mi primer intento.&lt;/p&gt;

&lt;p&gt;Debajo, es el código de &lt;code&gt;stat_rasa()&lt;/code&gt;, que toma los datos y una función que devuelva un data.frame interpretable por el &lt;code&gt;geom&lt;/code&gt; elegido.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# ggproto object
StatRasa &amp;lt;- ggplot2::ggproto(&amp;quot;StatRasa&amp;quot;, ggplot2::Stat,
  compute_group = function(data, scales, fun, fun.args) {
     # Change default arguments of the function to the 
     # values in fun.args
     args &amp;lt;- formals(fun)
     for (i in seq_along(fun.args)) {
        if (names(fun.args[i]) %in% names(fun.args)) {
           args[[names(fun.args[i])]] &amp;lt;- fun.args[[i]]
        } 
     }
     formals(fun) &amp;lt;- args
     
     # Apply function to data
     fun(data)
})

# stat function used in ggplot
stat_rasa &amp;lt;- function(mapping = NULL, data = NULL,
                      geom = &amp;quot;point&amp;quot;, 
                      position = &amp;quot;identity&amp;quot;,
                      fun = NULL,
                      ...,
                      show.legend = NA,
                      inherit.aes = TRUE) {
   # Check arguments 
   if (!is.function(fun)) stop(&amp;quot;fun must be a function&amp;quot;)
   
   # Pass dotted arguments to a list
   fun.args &amp;lt;- match.call(expand.dots = FALSE)$`...`
   
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = StatRasa,
      geom = geom,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      check.aes = FALSE,
      check.param = FALSE,
      params = list(
         fun = fun, 
         fun.args = fun.args,
         na.rm = FALSE,
         ...
      )
   )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por ejemplo, si queremos rápidamente visualizar los datos menos sin la tendencia, podemos crear una función relativamente simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Detrend &amp;lt;- function(data, method = &amp;quot;lm&amp;quot;, span = 0.2) {
   if (method == &amp;quot;lm&amp;quot;) {
      data$y &amp;lt;- resid(lm(y ~ x, data = data))
   } else {
      data$y &amp;lt;- resid(loess(y ~ x, span = span, data = data))
   }
   as.data.frame(data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y luego obtener los residuos en una sola línea.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
set.seed(42)
x &amp;lt;- seq(-1, 3, length.out = 30)
y &amp;lt;- x^2 + rnorm(30)*0.5
df &amp;lt;- data.frame(x = x, y = y)
ggplot(df, aes(x, y)) +
   geom_line() +
   stat_rasa(geom = &amp;quot;line&amp;quot;, fun = Detrend, method = &amp;quot;smooth&amp;quot;,
             color = &amp;quot;steelblue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Si queremos un poco más de legibilidad, podemos hacer una función con un nombre más informativo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;stat_detrend &amp;lt;- function(...) {
   stat_rasa(fun = Detrend, ...)
}

ggplot(df, aes(x, y)) +
   geom_line() +
   stat_detrend(method = &amp;quot;lm&amp;quot;, color = &amp;quot;blue&amp;quot;, geom = &amp;quot;line&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Otro caso es el de calcular contornos a partir de una grilla irregular. &lt;code&gt;ggplot2::stat_contour()&lt;/code&gt; usa &lt;code&gt;grDevices::contourLines()&lt;/code&gt; para computar los contornos y requiere una grilla regular y el paquete &lt;code&gt;contoureR&lt;/code&gt; tiene una función que acepta una grilla irregular. Para usarla sin problemas lo único que tenemos que hacer es armar una pequeña función y usar &lt;code&gt;geom = &amp;quot;path&amp;quot;&lt;/code&gt; en &lt;code&gt;stat_rasa()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;IrregularContour &amp;lt;- function(data, breaks = scales::fullseq, 
                             binwidth = NULL,
                             bins = 10) {
   if (is.function(breaks)) {
      # If no parameters set, use pretty bins to calculate binwidth
      if (is.null(binwidth)) {
         binwidth &amp;lt;- diff(range(data$z)) / bins
      }
      
      breaks &amp;lt;- breaks(range(data$z), binwidth)
   }
   
   cl &amp;lt;- contoureR::getContourLines(x = data$x, y = data$y, z = data$z, 
                                    levels = breaks)
   
   if (length(cl) == 0) {
      warning(&amp;quot;Not possible to generate contour data&amp;quot;, call. = FALSE)
      return(data.frame())
   }
   cl &amp;lt;- cl[, 3:7]
   colnames(cl) &amp;lt;- c(&amp;quot;piece&amp;quot;, &amp;quot;group&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;level&amp;quot;)
   return(cl)
}

stat_contour_irregular &amp;lt;- function(...) {
   stat_rasa(fun = IrregularContour, geom = &amp;quot;path&amp;quot;, ...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(42)
df &amp;lt;- data.frame(x = rnorm(500),
                 y = rnorm(500))
df$z &amp;lt;- with(df, -x*y*exp(-x^2 - y^2))

ggplot(df, aes(x, y)) +
   geom_point(aes(color = z)) +
   stat_contour_irregular(aes(z = z, color = ..level..), bins = 15) +
   scale_color_viridis_c()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Y voilà.&lt;/p&gt;

&lt;p&gt;Quedan algunos detalles para mejorar, como por ejemplo la posibilidad de utilizar una función para decidir los parámetros a usar de acuerdo a los datos, pero creo que así como está sirve para el 80% de las aplicaciones simples. También debería ponerle un mejor nombre, pero nombrar cosas es muy difícil.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to make a generic stat in ggplot2</title>
      <link>/2018/05/how-to-make-a-generic-stat-in-ggplot2/</link>
      <pubDate>Wed, 16 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/05/how-to-make-a-generic-stat-in-ggplot2/</guid>
      <description>&lt;p&gt;For a while now I&amp;rsquo;ve been thinking that, yes, &lt;code&gt;ggplot2&lt;/code&gt; is awesome and offers a lot of &lt;code&gt;geoms&lt;/code&gt; and &lt;code&gt;stats&lt;/code&gt;, but it would be great if it could be extended with new user-generated &lt;code&gt;geoms&lt;/code&gt; and &lt;code&gt;stats&lt;/code&gt;. Then I learnt that &lt;code&gt;ggplot2&lt;/code&gt; actually has a pretty great extension system so I could create my own geoms I needed for my work or &lt;a href=&#34;https://twitter.com/d_olivaw/status/993669229810503680&#34;&gt;just for fun&lt;/a&gt;. But still, creating a geom from scratch is an involved process that doesn&amp;rsquo;t lend itself to simple transformations.&lt;/p&gt;

&lt;p&gt;Finally, I thought of a possible solution: create a &lt;em&gt;generic&lt;/em&gt; &lt;code&gt;stat&lt;/code&gt; &amp;ndash;a tabula rasa, if you will&amp;ndash; that can work on the data with any function. Natively &lt;code&gt;ggplot2&lt;/code&gt; offers &lt;code&gt;stat_summary()&lt;/code&gt;, but it&amp;rsquo;s only meant to be used with, well, summary statistics. What I wanted was something completely generic and this is my first try.&lt;/p&gt;

&lt;p&gt;Below is the code for &lt;code&gt;stat_rasa()&lt;/code&gt; (better name pending). It works just like any other &lt;code&gt;stat&lt;/code&gt; except that it works with any function that takes a data.frame and returns a transformed data.frame that can be interpreted by the chosen &lt;code&gt;geom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# ggproto object
StatRasa &amp;lt;- ggplot2::ggproto(&amp;quot;StatRasa&amp;quot;, ggplot2::Stat,
  compute_group = function(data, scales, fun, fun.args) {
     # Change default arguments of the function to the 
     # values in fun.args
     args &amp;lt;- formals(fun)
     for (i in seq_along(fun.args)) {
        if (names(fun.args[i]) %in% names(fun.args)) {
           args[[names(fun.args[i])]] &amp;lt;- fun.args[[i]]
        } 
     }
     formals(fun) &amp;lt;- args
     
     # Apply function to data
     fun(data)
})

# stat function used in ggplot
stat_rasa &amp;lt;- function(mapping = NULL, data = NULL,
                      geom = &amp;quot;point&amp;quot;, 
                      position = &amp;quot;identity&amp;quot;,
                      fun = NULL,
                      ...,
                      show.legend = NA,
                      inherit.aes = TRUE) {
   # Check arguments 
   if (!is.function(fun)) stop(&amp;quot;fun must be a function&amp;quot;)
   
   # Pass dotted arguments to a list
   fun.args &amp;lt;- match.call(expand.dots = FALSE)$`...`
   
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = StatRasa,
      geom = geom,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      check.aes = FALSE,
      check.param = FALSE,
      params = list(
         fun = fun, 
         fun.args = fun.args,
         na.rm = FALSE,
         ...
      )
   )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, let&amp;rsquo;s say we want to quickly glance at detrended data. We then create a very simple function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Detrend &amp;lt;- function(data, method = &amp;quot;lm&amp;quot;, span = 0.2) {
   if (method == &amp;quot;lm&amp;quot;) {
      data$y &amp;lt;- resid(lm(y ~ x, data = data))
   } else {
      data$y &amp;lt;- resid(loess(y ~ x, span = span, data = data))
   }
   as.data.frame(data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and pass it to &lt;code&gt;stat_rasa()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
set.seed(42)
x &amp;lt;- seq(-1, 3, length.out = 30)
y &amp;lt;- x^2 + rnorm(30)*0.5
df &amp;lt;- data.frame(x = x, y = y)
ggplot(df, aes(x, y)) +
   geom_line() +
   stat_rasa(geom = &amp;quot;line&amp;quot;, fun = Detrend, method = &amp;quot;smooth&amp;quot;,
             color = &amp;quot;steelblue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2.en_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can get better legibility and less typing by creating a wrapper function with a more descriptive name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;stat_detrend &amp;lt;- function(...) {
   stat_rasa(fun = Detrend, ...)
}

ggplot(df, aes(x, y)) +
   geom_line() +
   stat_detrend(method = &amp;quot;lm&amp;quot;, color = &amp;quot;blue&amp;quot;, geom = &amp;quot;line&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2.en_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Another case could be calculating contours from an irregular grid. Since &lt;code&gt;ggplot2::stat_contour()&lt;/code&gt; uses &lt;code&gt;grDevices::contourLines()&lt;/code&gt;, it needs values defined in a regular grid, but there&amp;rsquo;s a package called &lt;code&gt;contoureR&lt;/code&gt; that can compute contours from irregularly spaced observations. With &lt;code&gt;stat_rasa()&lt;/code&gt; we can integrate it with &lt;code&gt;ggplot2&lt;/code&gt; effortlessly by creating a small function and using &lt;code&gt;geom = &amp;quot;path&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;IrregularContour &amp;lt;- function(data, breaks = scales::fullseq, 
                             binwidth = NULL,
                             bins = 10) {
   if (is.function(breaks)) {
      # If no parameters set, use pretty bins to calculate binwidth
      if (is.null(binwidth)) {
         binwidth &amp;lt;- diff(range(data$z)) / bins
      }
      
      breaks &amp;lt;- breaks(range(data$z), binwidth)
   }
   
   cl &amp;lt;- contoureR::getContourLines(x = data$x, y = data$y, z = data$z, 
                                    levels = breaks)
   
   if (length(cl) == 0) {
      warning(&amp;quot;Not possible to generate contour data&amp;quot;, call. = FALSE)
      return(data.frame())
   }
   cl &amp;lt;- cl[, 3:7]
   colnames(cl) &amp;lt;- c(&amp;quot;piece&amp;quot;, &amp;quot;group&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;level&amp;quot;)
   return(cl)
}

stat_contour_irregular &amp;lt;- function(...) {
   stat_rasa(fun = IrregularContour, geom = &amp;quot;path&amp;quot;, ...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(42)
df &amp;lt;- data.frame(x = rnorm(500),
                 y = rnorm(500))
df$z &amp;lt;- with(df, -x*y*exp(-x^2 - y^2))

ggplot(df, aes(x, y)) +
   geom_point(aes(color = z)) +
   stat_contour_irregular(aes(z = z, color = ..level..), bins = 15) +
   scale_color_viridis_c()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2.en_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And voilà.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s always things to improve. For example, the possibility of using a custom function to compute parameters that depend on the data, but I believe that as it stands covers 80% of simple applications. I should also use a better name, but naming things is hard work.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to make a shaded relief in R</title>
      <link>/2018/02/how-to-make-shaded-relief-in-r/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/02/how-to-make-shaded-relief-in-r/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../2018/02/como-hacer-efecto-de-relieve-en-r&#34;&gt;Spanish version of this post&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;While trying to build a circular colour scale to plot angles and wind direction, I stumbled upon an easy way to make shaded reliefs in R. You known, when you look at cool maps of mountain areas where peaks and valleys are easily distinguishable from their shadows like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../images/shading.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;What I accidentally discovered is that one way of approximating this look is by taking the directional derivatives of height and then plotting the cosine of its angle from the sun. After some further research I learned that this is actually done in cartography and is called &lt;a href=&#34;http://www.reliefshading.com/analytical/shading-methods/&#34;&gt;&lt;em&gt;aspect-based shading&lt;/em&gt;&lt;/a&gt;. I also learned that it&amp;rsquo;s not the best method, and I&amp;rsquo;m itching to try others. But for now, let&amp;rsquo;s keep things simple and &lt;a href=&#34;https://kkulma.github.io/2017-12-29-end-of-year-thoughts/&#34;&gt;get stuff actually done&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Just as an example, I will be using our old friend, the &lt;code&gt;volcano&lt;/code&gt; database. I will be also using &lt;code&gt;data.table&lt;/code&gt; syntax because that how I roll. Deal with it, &lt;code&gt;dplyr&lt;/code&gt; lovers 😎.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(data.table)
library(ggplot2)
data(volcano)
volcano &amp;lt;- as.data.table(melt(volcano, varnames = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;),
                              value.name = &amp;quot;h&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So then I take the derivative (this is a function I made in my personal package, but bear with me 🙏) and take the angle. The minus sign are there&amp;hellip; well, because it works &amp;ndash;I&amp;rsquo;m not sure about the exact maths here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;volcano[, c(&amp;quot;dx&amp;quot;, &amp;quot;dy&amp;quot;) := metR::Derivate(h ~ x + y)]
volcano[, angle := atan2(-dy, -dx)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with that, we can set the angle from which the Sun is shinning (usually from the top left) and with a little bit of code, we get an acceptable result.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sun.angle &amp;lt;- pi/3
ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = cos(angle + sun.angle)), alpha = 1, interpolate = TRUE) +
   scale_fill_gradient2(low = &amp;quot;white&amp;quot;, high = &amp;quot;white&amp;quot;, mid = &amp;quot;gray20&amp;quot;, 
                        midpoint = sun.angle, guide = &amp;quot;none&amp;quot;) +
   coord_fixed() +
   theme_void() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-02-04-how-to-make-a-shaded-relief-in-r_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Excellent! 💜&lt;/p&gt;

&lt;p&gt;But hey, don&amp;rsquo;t leave, there&amp;rsquo;s more. What if you want to use this &lt;em&gt;gorgeous&lt;/em&gt; shading as a background to map &lt;em&gt;other&lt;/em&gt; data? For example, let&amp;rsquo;s say you had surface temperature readings, or sulphur concentration data. Since our &lt;code&gt;scale_fill&lt;/code&gt; is being taken by the shading and &lt;code&gt;ggplot2&lt;/code&gt; does not allow for more than one scale per aesthetic, you couldn&amp;rsquo;t use another &lt;code&gt;geom_raster()&lt;/code&gt; to &amp;ldquo;paint&amp;rdquo; the data over this background.&lt;/p&gt;

&lt;p&gt;One solution is to take the plot we made above, extract the raster grob (GRaphical OBject) and put it over another plot as an annotation. This is akin to a plot transplant and &amp;ndash;just as organ transplants&amp;ndash; it&amp;rsquo;s an ugly mess that will become a forgotten practice of a less civilized age once we master 3D printing of organs. But it works and is the best we&amp;rsquo;ve got so far.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;shade &amp;lt;- ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = cos(angle + sun.angle)), alpha = 0.5, interpolate = TRUE) +
   scale_fill_gradient2(low = &amp;quot;white&amp;quot;, high = &amp;quot;white&amp;quot;, mid = &amp;quot;black&amp;quot;, 
                        midpoint = sun.angle, guide = &amp;quot;none&amp;quot;)

grob.shade &amp;lt;- ggplotGrob(shade)
grob.shade &amp;lt;- grob.shade$grobs[[6]]$children[[3]]

ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = h), alpha = 1, interpolate = TRUE) +
   annotation_custom(grob = grob.shade) +
   scale_fill_viridis_c(guide = &amp;quot;none&amp;quot;, option = &amp;quot;A&amp;quot;) +
   coord_fixed() +
   theme_void() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-02-04-how-to-make-a-shaded-relief-in-r_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lucky for us, at least for this kind of plot transplant, there&amp;rsquo;s already a better way: just make a &lt;code&gt;geom&lt;/code&gt;! Once we are inside the guts of &lt;code&gt;ggplot2&lt;/code&gt; we are no longer bound by the tyranny of scales can do the craziest things. In this case, we use a modified version of &lt;code&gt;geom_tile()&lt;/code&gt; that performs all the calculations we need and builds the grayscale pattern (modifiable by the user via the &lt;code&gt;light&lt;/code&gt; and &lt;code&gt;dark&lt;/code&gt; aesthetics). It allows changing &lt;code&gt;sun.angle&lt;/code&gt; and decide whether to use &lt;code&gt;raster&lt;/code&gt; or &lt;code&gt;rect&lt;/code&gt; and whether to interpolate for a smoother finish. I give to you &lt;code&gt;geom_relief()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_relief &amp;lt;- function(mapping = NULL, data = NULL,
                        stat = &amp;quot;identity&amp;quot;, position = &amp;quot;identity&amp;quot;,
                        ...,
                        raster = TRUE,
                        interpolate = TRUE,
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE) {
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = stat,
      geom = GeomRelief,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      params = list(
         raster = raster,
         interpolate = interpolate,
         na.rm = na.rm,
         ...
      )
   )
}

GeomRelief &amp;lt;- ggplot2::ggproto(&amp;quot;GeomRelief&amp;quot;, GeomTile,
  required_aes = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;),
  default_aes = ggplot2::aes(color = NA, fill = &amp;quot;grey35&amp;quot;, size = 0.5, linetype = 1,
                             alpha = NA, light = &amp;quot;white&amp;quot;, dark = &amp;quot;gray20&amp;quot;, sun.angle = 60),
  draw_panel = function(data, panel_scales, coord, raster, interpolate) {
     if (!coord$is_linear()) {
        stop(&amp;quot;non lineal coordinates are not implemented in GeomRelief&amp;quot;, call. = FALSE)
     } else {
        coords &amp;lt;- as.data.table(coord$transform(data, panel_scales))
        
        # This is the only part that&#39;s actually new. The rest is essentially 
        # copy-pasted from geom_raster and geom_tile
        coords[, sun.angle := (sun.angle + 90)*pi/180]
        coords[, dx := .derv(z, x), by = y]
        coords[, dy := .derv(z, y), by = x]
        coords[, shade := (cos(atan2(-dy, -dx) - sun.angle) + 1)/2]
        coords[is.na(shade), shade := 0]
        coords[, fill := .rgb2hex(colorRamp(c(dark, light), space = &amp;quot;Lab&amp;quot;)(shade)),
               by = .(dark, light)]
        
        # From geom_raster and geom_tile
        if (raster == TRUE){
           if (!inherits(coord, &amp;quot;CoordCartesian&amp;quot;)) {
              stop(&amp;quot;geom_raster only works with Cartesian coordinates&amp;quot;, call. = FALSE)
           }
           # Convert vector of data to raster
           x_pos &amp;lt;- as.integer((coords$x - min(coords$x)) / resolution(coords$x, FALSE))
           y_pos &amp;lt;- as.integer((coords$y - min(coords$y)) / resolution(coords$y, FALSE))
           
           nrow &amp;lt;- max(y_pos) + 1
           ncol &amp;lt;- max(x_pos) + 1
           
           raster &amp;lt;- matrix(NA_character_, nrow = nrow, ncol = ncol)
           raster[cbind(nrow - y_pos, x_pos + 1)] &amp;lt;- alpha(coords$fill, coords$alpha)
           
           # Figure out dimensions of raster on plot
           x_rng &amp;lt;- c(min(coords$xmin, na.rm = TRUE), max(coords$xmax, na.rm = TRUE))
           y_rng &amp;lt;- c(min(coords$ymin, na.rm = TRUE), max(coords$ymax, na.rm = TRUE))
           
           grid::rasterGrob(raster,
                            x = mean(x_rng), y = mean(y_rng),
                            width = diff(x_rng), height = diff(y_rng),
                            default.units = &amp;quot;native&amp;quot;, interpolate = interpolate
           )
           
        } else {
           ggplot2:::ggname(&amp;quot;geom_rect&amp;quot;, grid::rectGrob(
              coords$xmin, coords$ymax,
              width = coords$xmax - coords$xmin,
              height = coords$ymax - coords$ymin,
              default.units = &amp;quot;native&amp;quot;,
              just = c(&amp;quot;left&amp;quot;, &amp;quot;top&amp;quot;),
              gp = grid::gpar(
                 col = coords$fill,
                 fill = alpha(coords$fill, coords$alpha),
                 lwd = coords$size * .pt,
                 lty = coords$linetype,
                 lineend = &amp;quot;butt&amp;quot;
              )
           ))
           
        }
     }
  }
)

rect_to_poly &amp;lt;- function(xmin, xmax, ymin, ymax) {
   data.frame(
      y = c(ymax, ymax, ymin, ymin, ymax),
      x = c(xmin, xmax, xmax, xmin, xmin)
   )
}

.rgb2hex &amp;lt;- function(array) {
   rgb(array[, 1], array[, 2], array[, 3], maxColorValue = 255)
}


.derv &amp;lt;- function(x, y, order = 1, cyclical = FALSE, fill = FALSE) {
   N &amp;lt;- length(x)
   d &amp;lt;- y[2] - y[1]
   if (order &amp;gt;= 3) {
      dxdy &amp;lt;- .derv(.derv(x, y, order = 2, cyclical = cyclical, fill = fill),
                    y, order = order - 2, cyclical = cyclical, fill = fill)
   } else {
      if (order == 1) {
         dxdy &amp;lt;- (x[c(2:N, 1)] - x[c(N, 1:(N-1))])/(2*d)
      } else if (order == 2) {
         dxdy &amp;lt;- (x[c(2:N, 1)] + x[c(N, 1:(N-1))] - 2*x)/d^2
      }
      if (!cyclical) {
         if (!fill) {
            dxdy[c(1, N)] &amp;lt;- NA
         }
         if (fill) {
            dxdy[1] &amp;lt;- (-11/6*x[1] + 3*x[2] - 3/2*x[3] + 1/3*x[4])/d
            dxdy[N] &amp;lt;- (11/6*x[N] - 3*x[N-1] + 3/2*x[N-2] - 1/3*x[N-3])/d
         }
      }
      
   }
   return(dxdy)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s use it to show real topographic data from The Andes near the Aconcagua, courtesy of &lt;a href=&#34;https://www.ngdc.noaa.gov/mgg/global/&#34;&gt;NOAA&amp;rsquo;s ETOPO1&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;aconcagua &amp;lt;- metR::GetTopography(-70.0196223 - 3 + 360, -70.0196223 + 3 + 360,
                                 -32.6531782 + 2, -32.6531782 - 2, 
                                 resolution = 1/60)
aconcagua[, c(&amp;quot;light&amp;quot;, &amp;quot;dark&amp;quot;) := .(ifelse(h &amp;gt; 0, &amp;quot;white&amp;quot;, &amp;quot;slategray2&amp;quot;),
                                ifelse(h &amp;gt; 0, &amp;quot;gray20&amp;quot;, &amp;quot;midnightblue&amp;quot;))] 
ggplot(aconcagua, aes(lon, lat)) +
   geom_relief(aes(z = h, light = light, dark = dark), 
               raster = TRUE, interpolate = TRUE, sun.angle = 60) +
   coord_fixed(expand = FALSE) +
   theme_void()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-02-04-how-to-make-a-shaded-relief-in-r_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The result, if you ask me: delicious  👌&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cómo hacer un efecto de relieve en R</title>
      <link>/2018/01/como-hacer-efecto-de-relieve-en-r/</link>
      <pubDate>Wed, 24 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/01/como-hacer-efecto-de-relieve-en-r/</guid>
      <description>&lt;p&gt;Estaba tratando de hacer una guía de colores circular (que los extremos tengan el mismo color) para hacer gráficos de ángulos o direcciones del viento, cuando descubrí una forma interesante de crear un efecto de relieve en mapas de topografía.&lt;/p&gt;

&lt;p&gt;Digamos que tenemos datos de altura del suelo sobre el nivel del mar en una grilla regular. Como ejemplo vamos a usar la vieja y querida &lt;code&gt;volcano&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(data.table)
library(ggplot2)
data(volcano)
volcano &amp;lt;- as.data.table(melt(volcano, varnames = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;),
                              value.name = &amp;quot;h&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La forma más básica de visualizarlos (en &lt;code&gt;ggplot2&lt;/code&gt;) es con un &lt;code&gt;geom_raster()&lt;/code&gt; (o &lt;code&gt;geom_tile()&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(volcano, aes(x, y)) + 
   geom_raster(aes(fill = h), interpolate = TRUE) +
   scale_fill_viridis_c(option = &amp;quot;A&amp;quot;, guide = &amp;quot;none&amp;quot;) +
   coord_fixed() +
   theme_void()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-01-24-como-hacer-efecto-de-relieve-en-r_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Y está bien. Grafica los datos correctamente y encima elegimos una escala de colores uniforme y no asquerosa. Pero si uno quiere que tenga un poco más de &lt;em&gt;punch&lt;/em&gt;, y quizás está dispuesto a perder un poco de exactitud en la representación en favor de una impresión más instintiva de la forma de este volcán, podría preferir que tuviera algún sombreado que de una idea del relieve. Algo llamativo como esto:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../images/shading.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lindo, ¿no? En R podemos hacer algo aproximado. Lo que vamos a hacer es calcular la pendiente en cada punto de grilla y luego pensar que la intensidad de las luces y sombras son proporcionales al producto escalar entre ésta y el ángulo con el que llega el Sol.&lt;/p&gt;

&lt;p&gt;Tomando que el Sol brilla desde arriba a la izquierda, si una región tiene pendiente hacia arriba a la derecha, el producto escalar es negativo y tenemos una región de sombra. Lo mismo pasa al contrario&amp;hellip; creo. En realidad no pensé esta parte demasiado bien, ¡pero el resultado en el gráfico es bueno y creo que que &lt;a href=&#34;http://www.reliefshading.com/analytical/shading-methods/&#34;&gt;coincide con métodos existentes&lt;/a&gt;! (Créanme 🙏).&lt;/p&gt;

&lt;p&gt;Primero, tenemos que calcular el gradiente de la altura en cada punto. Acá estoy usando una función de mi paquete personal (que ustedes pueden adquirir en el puesto instalado en el hall del teatro&amp;hellip; digo, &lt;a href=&#34;https://github.com/eliocamp/metR&#34;&gt;en github&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;volcano[, c(&amp;quot;dx&amp;quot;, &amp;quot;dy&amp;quot;) := metR::Derivate(h ~ x + y)]
volcano[, angle := atan2(-dy, -dx)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ya con esto simplemente mapeamos el coseno del ángulo (por el producto vectorial) a una escala de grises que empiece y termine en el mismo color.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sun.angle &amp;lt;- pi/3
ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = cos(angle + sun.angle)), alpha = 1, interpolate = TRUE) +
   scale_fill_gradient2(low = &amp;quot;white&amp;quot;, high = &amp;quot;white&amp;quot;, mid = &amp;quot;gray20&amp;quot;, 
                        midpoint = sun.angle, guide = &amp;quot;none&amp;quot;) +
   coord_fixed() +
   theme_void() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-01-24-como-hacer-efecto-de-relieve-en-r_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;¡Hermoso! 💜 Si queremos cambiar la hora del día, sólo basta con cambiar el ángulo del sol. Esas áreas horribles en gris llano son regiones con errores, donde los datos son constantes, la derivada es nula y el ángulo entonces es cero. Por ahora dejémoslas ser porque todavía hay una última cosa que hacer.&lt;/p&gt;

&lt;p&gt;¿Qué tal si además de este sombreado genial queremos de alguna mantera mostrar la altura? ¿U otra variable como la temperatura o el uso del terreno o lo que sea? Como nuestra &lt;code&gt;scale_fill()&lt;/code&gt; está siendo usada por el relieve, no podemos mapear otras variables a ese parámetro. Es decir, no podemos usar un &lt;code&gt;geom_tile()&lt;/code&gt; con transparencia, por ejemplo. Que yo sepa hay dos formas de solucionar esto. Una fácil y una difícil.&lt;/p&gt;

&lt;p&gt;La primera implica hacer un poco de cirugía de plots. Primero, creamos un plot similar al anterior pero con transparencia y sin tanta fanfarria y más contraste. Después lo convertimos en un grob (GRaphical OBject) y luego le extraemos la parte que nos interesa. Esto acá está hecho manual pero podría automatizarse. Hay que buscar primero el grob que sea &lt;code&gt;gTree&lt;/code&gt; (el 5, en este caso) y luego, entre sus &lt;code&gt;children&lt;/code&gt;, encontrar el que sea un &lt;code&gt;rect&lt;/code&gt; (el 3).&lt;/p&gt;

&lt;p&gt;Finalmente, con el grob del sombreado ya en nuestras manos, hacemos el gráfico que queremos, con las escalas que se nos ocurra, pero le agregamos el sombreado como una anotación con &lt;code&gt;annotation_custom()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;shade &amp;lt;- ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = cos(angle + sun.angle)), alpha = 0.5, interpolate = TRUE) +
   scale_fill_gradient2(low = &amp;quot;white&amp;quot;, high = &amp;quot;white&amp;quot;, mid = &amp;quot;black&amp;quot;, 
                        midpoint = sun.angle, guide = &amp;quot;none&amp;quot;)

grob.shade &amp;lt;- ggplotGrob(shade)
grob.shade &amp;lt;- grob.shade$grobs[[6]]$children[[3]]

ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = h), alpha = 1, interpolate = TRUE) +
   annotation_custom(grob = grob.shade) +
   scale_fill_viridis_c(guide = &amp;quot;none&amp;quot;, option = &amp;quot;A&amp;quot;) +
   coord_fixed() +
   theme_void() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-01-24-como-hacer-efecto-de-relieve-en-r_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;La forma más difícil en realidad es difícil para quien escribe, pero mucho más fácil para quien lee: hacer un &lt;code&gt;geom&lt;/code&gt; propio. Una vez que uno se mete en las entrañas de &lt;code&gt;ggplot2&lt;/code&gt;, puede liberarse de las cadenas de las escalas y hacer &lt;code&gt;geoms&lt;/code&gt; que dibujen las cosas como uno quiera. En este caso, creamos una versión de &lt;code&gt;geom_tile()&lt;/code&gt; que, además de hacer los cálculos de derivadas internamente, genera el degradé (que puede ser modificado por el usuario mediante los parámetros &lt;code&gt;light&lt;/code&gt; y &lt;code&gt;dark&lt;/code&gt;) sin tocar ninguna escala. Además, se puede cambiar el ángulo del sol con &lt;code&gt;sun.angle&lt;/code&gt;, decidir si se usa &lt;code&gt;raster&lt;/code&gt; (rápido y permite interpolación, pero sólo en coordenadas cartesianas) o &lt;code&gt;rect&lt;/code&gt; (más lento) y si interpola para un efecto más lindo. Les presento a &lt;code&gt;geom_relief()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_relief &amp;lt;- function(mapping = NULL, data = NULL,
                        stat = &amp;quot;identity&amp;quot;, position = &amp;quot;identity&amp;quot;,
                        ...,
                        raster = TRUE,
                        interpolate = TRUE,
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE) {
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = stat,
      geom = GeomRelief,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      params = list(
         raster = raster,
         interpolate = interpolate,
         na.rm = na.rm,
         ...
      )
   )
}

GeomRelief &amp;lt;- ggplot2::ggproto(&amp;quot;GeomRelief&amp;quot;, GeomTile,
  required_aes = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;),
  default_aes = ggplot2::aes(color = NA, fill = &amp;quot;grey35&amp;quot;, size = 0.5, linetype = 1,
                             alpha = NA, light = &amp;quot;white&amp;quot;, dark = &amp;quot;gray20&amp;quot;, sun.angle = 60),
  draw_panel = function(data, panel_scales, coord, raster, interpolate) {
     if (!coord$is_linear()) {
        stop(&amp;quot;non lineal coordinates are not implemented in GeomRelief&amp;quot;, call. = FALSE)
     } else {
        coords &amp;lt;- as.data.table(coord$transform(data, panel_scales))
        
        # Esto es lo único que es nuevo. El resto es básicamente copy-paste
        # de geom_raster y geom_tile.
        coords[, sun.angle := (sun.angle + 90)*pi/180]
        coords[, dx := .derv(z, x), by = y]
        coords[, dy := .derv(z, y), by = x]
        coords[, shade := (cos(atan2(-dy, -dx) - sun.angle) + 1)/2]
        coords[is.na(shade), shade := 0]
        coords[, fill := .rgb2hex(colorRamp(c(dark, light), space = &amp;quot;Lab&amp;quot;)(shade)),
               by = .(dark, light)]
        
        # Desde geom_raster y geom_tile
        if (raster == TRUE){
           if (!inherits(coord, &amp;quot;CoordCartesian&amp;quot;)) {
              stop(&amp;quot;geom_raster only works with Cartesian coordinates&amp;quot;, call. = FALSE)
           }
           # Convert vector of data to raster
           x_pos &amp;lt;- as.integer((coords$x - min(coords$x)) / resolution(coords$x, FALSE))
           y_pos &amp;lt;- as.integer((coords$y - min(coords$y)) / resolution(coords$y, FALSE))
           
           nrow &amp;lt;- max(y_pos) + 1
           ncol &amp;lt;- max(x_pos) + 1
           
           raster &amp;lt;- matrix(NA_character_, nrow = nrow, ncol = ncol)
           raster[cbind(nrow - y_pos, x_pos + 1)] &amp;lt;- alpha(coords$fill, coords$alpha)
           
           # Figure out dimensions of raster on plot
           x_rng &amp;lt;- c(min(coords$xmin, na.rm = TRUE), max(coords$xmax, na.rm = TRUE))
           y_rng &amp;lt;- c(min(coords$ymin, na.rm = TRUE), max(coords$ymax, na.rm = TRUE))
           
           grid::rasterGrob(raster,
                            x = mean(x_rng), y = mean(y_rng),
                            width = diff(x_rng), height = diff(y_rng),
                            default.units = &amp;quot;native&amp;quot;, interpolate = interpolate
           )
           
        } else {
           ggplot2:::ggname(&amp;quot;geom_rect&amp;quot;, grid::rectGrob(
              coords$xmin, coords$ymax,
              width = coords$xmax - coords$xmin,
              height = coords$ymax - coords$ymin,
              default.units = &amp;quot;native&amp;quot;,
              just = c(&amp;quot;left&amp;quot;, &amp;quot;top&amp;quot;),
              gp = grid::gpar(
                 col = coords$fill,
                 fill = alpha(coords$fill, coords$alpha),
                 lwd = coords$size * .pt,
                 lty = coords$linetype,
                 lineend = &amp;quot;butt&amp;quot;
              )
           ))
           
        }
     }
  }
)

rect_to_poly &amp;lt;- function(xmin, xmax, ymin, ymax) {
   data.frame(
      y = c(ymax, ymax, ymin, ymin, ymax),
      x = c(xmin, xmax, xmax, xmin, xmin)
   )
}

.rgb2hex &amp;lt;- function(array) {
   rgb(array[, 1], array[, 2], array[, 3], maxColorValue = 255)
}


.derv &amp;lt;- function(x, y, order = 1, cyclical = FALSE, fill = FALSE) {
   N &amp;lt;- length(x)
   d &amp;lt;- y[2] - y[1]
   if (order &amp;gt;= 3) {
      dxdy &amp;lt;- .derv(.derv(x, y, order = 2, cyclical = cyclical, fill = fill),
                    y, order = order - 2, cyclical = cyclical, fill = fill)
   } else {
      if (order == 1) {
         dxdy &amp;lt;- (x[c(2:N, 1)] - x[c(N, 1:(N-1))])/(2*d)
      } else if (order == 2) {
         dxdy &amp;lt;- (x[c(2:N, 1)] + x[c(N, 1:(N-1))] - 2*x)/d^2
      }
      if (!cyclical) {
         if (!fill) {
            dxdy[c(1, N)] &amp;lt;- NA
         }
         if (fill) {
            dxdy[1] &amp;lt;- (-11/6*x[1] + 3*x[2] - 3/2*x[3] + 1/3*x[4])/d
            dxdy[N] &amp;lt;- (11/6*x[N] - 3*x[N-1] + 3/2*x[N-2] - 1/3*x[N-3])/d
         }
      }
      
   }
   return(dxdy)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De yapa, apliquemos esta técnica a datos topográficos reales de la Cordillera de los Andes cerca del Aconcagua, provistos por &lt;a href=&#34;https://www.ngdc.noaa.gov/mgg/global/&#34;&gt;ETOPO1 de la NOAA&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;aconcagua &amp;lt;- metR::GetTopography(-70.0196223 - 3 + 360, -70.0196223 + 3 + 360,
                                 -32.6531782 + 2, -32.6531782 - 2, 
                                 resolution = 1/60)
aconcagua[, c(&amp;quot;light&amp;quot;, &amp;quot;dark&amp;quot;) := .(ifelse(h &amp;gt; 0, &amp;quot;white&amp;quot;, &amp;quot;slategray2&amp;quot;),
                                ifelse(h &amp;gt; 0, &amp;quot;gray20&amp;quot;, &amp;quot;midnightblue&amp;quot;))] 
ggplot(aconcagua, aes(lon, lat)) +
   geom_relief(aes(z = h, light = light, dark = dark), 
               raster = TRUE, interpolate = TRUE, sun.angle = 60) +
   coord_fixed(expand = FALSE) +
   theme_void()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../post/2018-01-24-como-hacer-efecto-de-relieve-en-r_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;El resultado, para chuparse los dedos. 👌&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cómo hacer un buen ejemplo reproducible en R</title>
      <link>/2018/01/buen-ejemplo-reproducible-en-r/</link>
      <pubDate>Sat, 06 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/01/buen-ejemplo-reproducible-en-r/</guid>
      <description>


&lt;p&gt;Es muy difícil dar ayuda si no se sabe cuál es el problema. Un buen ejemplo de lo que está mal que cualquiera pueda correr en sus computadoras es casi esencial para recibir ayuda.&lt;/p&gt;
&lt;p&gt;Un buen ejemplo reproducible (o reprex) es básicamente el feliz matrimonio entre un set de datos &lt;strong&gt;mínimo&lt;/strong&gt; y un código &lt;strong&gt;mínimo&lt;/strong&gt; que ilustre el problema y que cualquiera pueda copiar, pegar en un script y obtener &lt;strong&gt;exactamente los mismos resultados&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Obtener un reprex mínimo no es una tarea trivial. A veces puede tomar más de media hora y dar maś de un dolor de cabeza. Pero en el proceso uno aprende mucho sobre las características específicas de su problema y a veces incluso termina por resolverlo solo. Aún si no se resuelve, el tiempo que uno invierte en hacer el ejemplo reproducible implican más chances de que algún usuario responda, más rápido y con más claridad.&lt;/p&gt;
&lt;div id=&#34;datos-minimos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Datos mínimos&lt;/h2&gt;
&lt;p&gt;Hay dos formas principales de obtener sets de datos para ejemplos reproducibles, creándolos uno mismo o usando datos que vienen en distintos paquetes. La cantidad de sets de datos a los que cualquier usuario de R puede tener acceso sin salir de casa &lt;a href=&#34;http://vincentarelbundock.github.io/Rdatasets/datasets.html&#34;&gt;es inmensa&lt;/a&gt;. Distintos datos sirven para ilustrar distintos problemas.&lt;/p&gt;
&lt;p&gt;Por ejemplo, yo trabajo mucho con datos espaciales en grillas regulares y si quiero probar algo uso mucho el dataset &lt;code&gt;volcano&lt;/code&gt;, que tiene información topográfica del volcán Maunga Whau en Auckland con una resolución de 10m. Como es una matriz y en general prefiero trabajar con data.frames, para usarla tengo que usar &lt;code&gt;reshape2::melt()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
   geom_contour(aes(z = value, color = ..level..)) +
   coord_equal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2018-01-06-buen-ejemplo-reproducible_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Para datos más puntales, &lt;code&gt;ggplot2&lt;/code&gt; tiene el dataset &lt;code&gt;diamonds&lt;/code&gt; que contiene más de 50.000 filas de datos numéricos y factores&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(diamonds, aes(carat, price)) +
   geom_point(aes(color = clarity)) +
   facet_grid(color ~ cut)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2018-01-06-buen-ejemplo-reproducible_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Y para el que prefiera autos de lujo a anillos de diamantes, está &lt;code&gt;mtcars&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Si uno prefiere usar datos ficticios, siempre puede generar números aleatorios con &lt;code&gt;rnorm&lt;/code&gt;, &lt;code&gt;runif&lt;/code&gt;, &lt;code&gt;rgamma&lt;/code&gt; o cualquier otra distribución (ver &lt;code&gt;?distributions&lt;/code&gt; para una lista). &lt;strong&gt;Siempre&lt;/strong&gt; que uno use alguna de estas funciones tiene que setear la semilla del generador de números aleatorios con &lt;code&gt;set.seed()&lt;/code&gt;. De esta forma uno se asegura que todo aquel que ejecute el código obtenga exactamente los mismos números (pero aleatorios 🤔).&lt;/p&gt;
&lt;p&gt;Una función que a mí me resolvió muchísimos problemas es &lt;code&gt;expand.grid&lt;/code&gt;. Devuelve un data.frame con todas las combinaciones de los elementos de distintos vectores. Es una función muy flexible que puede ser usada para generar una grilla regular&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- expand.grid(x = 1:10, y = 1:10)
df$z &amp;lt;- with(df, x*y)
ggplot(df, aes(x, y)) +
   geom_tile(aes(fill = z))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2018-01-06-buen-ejemplo-reproducible_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;o para asignar valores a distintos factores&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
df &amp;lt;- expand.grid(tiempo = 1:30, sujeto = factor(letters[1:3]))
set.seed(42)
df$valor &amp;lt;- with(df, tiempo*0.1*as.numeric(sujeto) + rnorm(nrow(df)))
ggplot(df, aes(tiempo, valor, color = sujeto)) +
   geom_line()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2018-01-06-buen-ejemplo-reproducible_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;A veces los problemas dependen de los datos utilizados. Si resulta imposible reproducir un problema con datos públicos o artificiales, la última opción es compartir los datos propios. En ese caso, lo que uno debe hacer es minimizar los datos para que puedan ser compartidos fácilmente. Por ejemplo, yo estaba teniendo unos problemas con unos datos de &lt;a href=&#34;https://en.wikipedia.org/wiki/Stream_function&#34;&gt;función corriente&lt;/a&gt; para distintos modelos climáticos y distintas estaciones. Parte de resolverlo implicó reducirlo a sólo un campo.&lt;/p&gt;
&lt;p&gt;Si los datos reducidos quedan bastante chicos, la manera más fácil de compartirlos es con la función &lt;code&gt;dput&lt;/code&gt;, que convierte un objeto de R en un código que lo reproduce:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dput(cars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## structure(list(speed = c(4, 4, 7, 7, 8, 9, 10, 10, 10, 11, 11, 
## 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 16, 
## 16, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 20, 20, 
## 22, 23, 24, 24, 24, 24, 25), dist = c(2, 10, 4, 22, 16, 10, 18, 
## 26, 34, 17, 28, 14, 20, 24, 28, 26, 34, 34, 46, 26, 36, 60, 80, 
## 20, 26, 54, 32, 40, 32, 40, 50, 42, 56, 76, 84, 36, 46, 68, 32, 
## 48, 52, 56, 64, 66, 54, 70, 92, 93, 120, 85)), class = &amp;quot;data.frame&amp;quot;, row.names = c(NA, 
## -50L))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si aún reduciéndolo al mínimo los datos son demasiado grandes o complicados para compartirlos como texto, la mejor opción es guardarlo como un archivo .Rds&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;saveRDS(diamonds, file = &amp;quot;diamonds.Rds&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;y luego subir el archivo a algún sitio de intercambio.&lt;/p&gt;
&lt;p&gt;En el código de ejemplo, leer los archivos con&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds &amp;lt;- readRDS(&amp;quot;diamonds.Rds&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;codigo-minimo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Código mínimo&lt;/h2&gt;
&lt;p&gt;Una vez que se tiene la menor cantidad de datos que reproducen un problema, lo que sigue es minimizar el código. A veces puede ser complicado, pero a grandes rasgos son cuestiones obvias.&lt;/p&gt;
&lt;p&gt;Cargar la menor cantidad de paquetes posibles. No crear variables innecesariamente. Si es una cuestión con gráficos, sacar la mayor cantidad de personalización posible (usar las escalas default en &lt;code&gt;ggplot2&lt;/code&gt;, por ejemplo).&lt;/p&gt;
&lt;p&gt;Personalmente, si el código original usa sintaxis de &lt;code&gt;dplyr&lt;/code&gt; o &lt;code&gt;data.table&lt;/code&gt; (mi favorita 💜), trato de reducir todo a R base. Casi seguro que el problema no está ahí y no está bueno obligar a otros a instalar paquetes nuevos para ayudar.&lt;/p&gt;
&lt;p&gt;Todo esto requiere una intuición de dónde podría estar el error pero en caso de no tenerla, ayuda a desarrollarla. Ir sacando pedazos de código y chequeando si el problema continua es una buena forma de encontrar la causa del problema. Como dijo Sherlock:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Una vez descartado lo imposible, el código que queda, por improbable que parezca, debe ser la causa del error.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(o algo así)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;finalmente&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Finalmente&lt;/h2&gt;
&lt;p&gt;Una vez que están los datos mínimos y el código mínimo, hay que compartir todo eso. Uno de mis paquetes favoritos y que uso constantemente es &lt;a href=&#34;https://github.com/tidyverse/reprex&#34;&gt;&lt;code&gt;reprex&lt;/code&gt;&lt;/a&gt;. Es un paquete pensado especialmente para hacer desaparecer todas las dificultades de compartir código y es increíblemente fácil de usar.&lt;/p&gt;
&lt;p&gt;Una vez que se tiene el código escrito, lo único que hay que hacer es copiarlo todo al portapapeles y correr &lt;code&gt;reprex::reprex()&lt;/code&gt; para que lo corra y copie el resultado en el portapapeles. Si hay gráficos, los sube automáticamente a imgur y genera los tags correctos para que se vean bien. Muestra los mensajes de error que aparezcan y permite elegir distintas convenciones de código según si queremos compartir nuestro ejemplo en GitHub, StackOverflow o un script de R.&lt;/p&gt;
&lt;p&gt;Por ejemplo, dándole el código anterior, &lt;code&gt;reprex&lt;/code&gt; devuelve esto:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```r
library(ggplot2)
df &amp;lt;- expand.grid(tiempo = 1:30, sujeto = factor(letters[1:3]))
dfset.seed(42)
$valor &amp;lt;- with(df, tiempo*0.1*as.numeric(sujeto) + rnorm(nrow(df)))
ggplot(df, aes(tiempo, valor, color = sujeto)) +
   geom_line()
```

![](https://i.imgur.com/51BdMze.png)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Que está listo para pegar en GitHub y que salga todo perfecto.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;buen-reprex-mata-galan&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Buen reprex mata galán&lt;/h2&gt;
&lt;p&gt;Pedir ayuda o reportar bugs con un buen ejemplo mínimo reproducible mejora la calidad de las consultas, ayuda a los que quieren ayudar, te hace ganar amigos y bajar 7 libras en 2 semanas. Sea bueno, haga un reprex.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Cómo calcular el Índice de Precipitación Estandarizado en R</title>
      <link>/2017/12/calcular-ipe-r/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/12/calcular-ipe-r/</guid>
      <description>


&lt;p&gt;El Índice de Precipitación Estandarizado (SPI por Standarized Precipitation Index) es un índice para evaluar el estado de sequía o exceso de lluvia. La idea del SPI es tener una idea de qué tan probable es tener una cantidad de lluvia igual o menor. Valores altos del SPI están asociados con épocas muy húmedas mientras que valores bajos indican sequía.&lt;/p&gt;
&lt;p&gt;En la práctica lo que se hace es la función de probabilidad acumulada a partir de los registros históricos y luego estimar la probabilidad para la cantidad observada en cada mes. Luego, esa probabildiad se convierte a su cuantil apropiado según una distribución normal estándar. De manera que, al final, el SPI indica cuántos desvíos estándar lejos de la media es la precipitación en cada mes.&lt;/p&gt;
&lt;p&gt;En otras palabras, a grandes razgos:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spi &amp;lt;- qnorm(ecdf(precipitacion)(precipitacion))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Algunos detalles extra:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;antes se suele aplica un promedio móvil para capturar las variaciones de precipitación en determinadas escalas temporales.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;el SPI calculado de esta manera da casos con precipitación tan extrema que R tira &lt;span class=&#34;math inline&#34;&gt;\(\pm \infty\)&lt;/span&gt;. Entonces hay que rellenar esos datos de manera que el desvío etándar de toda la serie siga siendo 1 y luego restar la media para que quede centrado en 0.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En R existe un paquete llamado &lt;code&gt;spi&lt;/code&gt;, pero analizando el código fuente de &lt;code&gt;spi::spi&lt;/code&gt;, me parece que tiene algunos bugs importantes que hacen que su resultado no sea fiable. Aparentemente una traducción de un código de FORTRAN o algún otro lenguaje de bajo nivel, en un bloque &lt;code&gt;if&lt;/code&gt; en el que debería transponer la matriz de datos, en realidad resulta una matriz con sólo 3 columnas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for (i in 2:ncolumn) {
   if (i == 2) {
      data_aux1 = rbind(t(data[i - 1, ]), t(data[i, ]))
   }
   else {
      data_aux = rbind(data_aux1, t(data[i, ]))    # acá está el problema
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Siguiendo lo que hace el &lt;code&gt;for&lt;/code&gt;, se ve que al final el &lt;code&gt;data_aux&lt;/code&gt; es una matriz transpuesta pero sólo de las columnas de &lt;code&gt;data&lt;/code&gt; 1, 2 y &lt;code&gt;ncolum&lt;/code&gt;. La matriz &lt;code&gt;data_aux&lt;/code&gt; es la que luego se usa para estimar la función de probabilidad acumulada; en vez de hacerse sobre toda la serie, se hace sobre 3 años.&lt;/p&gt;
&lt;p&gt;Además, el SPI debe estimarse &lt;strong&gt;para cada mes por separado&lt;/strong&gt; de manera de filtrar cualquier ciclo estacional. Pero &lt;code&gt;spi::spi&lt;/code&gt; hace el cálculo sobre todo junto. Esto explica por qué en el gráfico de ejemplo se ve un claro ciclo estacional que no debería estar ahí.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(spi)
data(spi_data)
write.table(spi_data,file=&amp;quot;spi.txt&amp;quot;,quote=FALSE,row.names=TRUE)
spi::spi(7,&amp;quot;spi.txt&amp;quot;,1963,2010,&amp;quot;Standardized Precipitation Index - Rio Grande do Norte State&amp;quot;,1,&amp;quot;years&amp;quot;,&amp;quot;months&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2017-12-21-como-calcular-spi-r_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Existe otro paquete, &lt;a href=&#34;https://cran.r-project.org/web/packages/precintcon/index.html&#34;&gt;&lt;code&gt;precintcon&lt;/code&gt;&lt;/a&gt;, que no parece tener esos problemas y además en vez de estimar la distribución de probabilidad acumulada, le ajusta una distribución Gamma, que es bastante usada para modelar precipitación. El problema, para mí, es que las funciones relacionadas con PSI sólo se pueden aplicar sobre data.frames enteros y con clases especiales. Yo prefiero trabajar con clases primitivas que sé lo que hacen y qué son y que brinden más libertad al usuario. En particular, prefiero datos que estén en formato &lt;em&gt;tidy&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Pero entonces hay que armarse la función propia:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Media movil
rollmean &amp;lt;- function(x, k = 3, na.rm = TRUE) {
   lapply(k, function(e) .rollmean(x, e, na.rm = na.rm))
}

.rollmean &amp;lt;- function(x, k, na.rm ) {
   i &amp;lt;- seq_along(x)
   j &amp;lt;- i - k + 1
   j &amp;lt;- ifelse(j &amp;lt;= 0, 1, j)
   pp &amp;lt;- sapply(i, function (e)  mean(x[j[e]:e], na.rm = na.rm))
}

# SPI
spi &amp;lt;- function(pp) {
   norm &amp;lt;- qnorm(ecdf(pp)(pp))
   
   # de http://www.cmc.org.ve/mediawiki/index.php?title=Herramienta_en_R_para_diagn%C3%B3stico
   norm.fin &amp;lt;- norm[norm != Inf &amp;amp; norm != -Inf]
   minimize &amp;lt;- function(x) (1 - sd(c(x, norm.fin)))^2
   norm[norm == Inf] &amp;lt;- optimize(minimize, lower=0, upper=100)$minimum
   return(norm - mean(norm))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La razón por la cual hay 2 funciones de media móvil es que la primera está vectorizada en &lt;code&gt;k&lt;/code&gt;, lo que significa que se puede hacer &lt;code&gt;roll &amp;lt;- rollmean(x, 1:3)&lt;/code&gt; para obtener una lista con 3 medias móviles con distinto &lt;code&gt;k&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Y listo. Para probar la función con los datos de &lt;code&gt;spi&lt;/code&gt;, primero hay que tenerlos en un formato razonable.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(data.table)
pp &amp;lt;- setDT(melt(spi_data, id.vars = &amp;quot;Months&amp;quot;, variable.name = &amp;quot;year&amp;quot;, value.name = &amp;quot;pp&amp;quot;))
pp[, year := as.numeric(substr(year, 2, 5))]
pp[, month.n := 1:7, by = year]
pp[, date := lubridate::ymd(paste0(year, &amp;quot;-&amp;quot;, month.n, &amp;quot;-15&amp;quot;))]

pp &amp;lt;- pp[, .(date, pp)]
knitr::kable(head(pp))&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;date&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;pp&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;1963-01-15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;74.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;1963-02-15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;155.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;1963-03-15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;226.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;1963-04-15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;186.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;1963-05-15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;37.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;1963-06-15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23.6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Así, con una observación de precipitación para cada fecha, podemos calcular el SPI en una sola línea:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pp[, pp.roll := rollmean(pp, k = 3)]
pp[, SPI := spi(pp.roll), by = month(date)]

meses &amp;lt;- c(&amp;quot;Ene&amp;quot;, &amp;quot;Feb&amp;quot;, &amp;quot;Mar&amp;quot;, &amp;quot;Abr&amp;quot;, &amp;quot;May&amp;quot;, &amp;quot;Jun&amp;quot;, 
           &amp;quot;Jul&amp;quot;, &amp;quot;Ago&amp;quot;, &amp;quot;Sep&amp;quot;, &amp;quot;Oct&amp;quot;, &amp;quot;Nov&amp;quot;, &amp;quot;Dic&amp;quot;)
spi.breaks &amp;lt;- c(-2.4, -2, -1.6, -1.3, -0.8, -0.5, 0.5, 0.8, 1.3, 1.6, 2, 2.4)
library(ggplot2)
ggplot(pp, aes(month(date), year(date))) +
   geom_contour(aes(z = SPI, color = ..level..), breaks = spi.breaks) +
   scale_color_distiller(name = &amp;quot;SPI&amp;quot;, 
                         palette = &amp;quot;BrBG&amp;quot;, direction = 1) +
   scale_x_continuous(name = &amp;quot;Mes&amp;quot;, expand = c(0, 0), 
                      breaks = 1:7, 
                      labels = meses[1:7]) +
   scale_y_continuous(name = &amp;quot;Año&amp;quot;, expand = c(0, 0), trans = &amp;quot;reverse&amp;quot;) +
   theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2017-12-21-como-calcular-spi-r_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Cabe aclarar que como los datos no cubren todo el año, en realidad el promedio movil no tiene sentido. Para probarlo voy a primero crear una serie de datos sintética con un ciclo anual.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pp2 &amp;lt;- data.table(date = seq.Date(as.Date(&amp;quot;1985-01-01&amp;quot;), as.Date(&amp;quot;2015-12-01&amp;quot;), 
                                  by = &amp;quot;1 month&amp;quot;))
set.seed(42)    # ¡reproducible!
pp2[, pp := rgamma(.N, shape = 1, scale = 10*(cos((month(date) - 1)/11*pi*2) + 1))]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y ahora sí, calcular el SPI como se debe y para todas las escalas de tiempo que queramos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pp2[, as.character(1:12) := rollmean(pp, 1:12)]
pp.long &amp;lt;- melt(pp2[, -&amp;quot;pp&amp;quot;], id.vars = &amp;quot;date&amp;quot;, variable.name = &amp;quot;k&amp;quot;, value.name = &amp;quot;pp&amp;quot;)
pp.long[, k := as.numeric(as.character(k))]
pp.long[, SPI := spi(pp), by = .(month(date), k)]

ggplot(pp.long, aes(date, k)) +
   geom_tile(aes(fill = SPI, color = SPI)) +
   scale_fill_distiller(name = &amp;quot;SPI&amp;quot;, 
                         palette = &amp;quot;BrBG&amp;quot;, direction = 1) +
      scale_color_distiller(name = &amp;quot;SPI&amp;quot;, 
                         palette = &amp;quot;BrBG&amp;quot;, direction = 1) +
   scale_x_date(name = &amp;quot;Fecha&amp;quot;, expand = c(0, 0)) +
   scale_y_continuous(name = &amp;quot;Escala temporal&amp;quot;, expand = c(0, 0), 
                      breaks = 1:12) +
   theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../post/2017-12-21-como-calcular-spi-r_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>