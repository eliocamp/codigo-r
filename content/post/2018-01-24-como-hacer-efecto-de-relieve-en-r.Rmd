---
title: C칩mo hacer un efecto de relieve en R
author: Elio Campitelli
date: '2018-01-24'
slug: como-hacer-efecto-de-relieve-en-r
categories:
  - R
tags: []
---

Estaba tratando de hacer una gu칤a de colores circular (que los extremos tengan el mismo color) para hacer gr치ficos de 치ngulos o direcciones del viento, cuando descubr칤 una forma interesante de crear un efecto de relieve en mapas de topograf칤a. 

Digamos que tenemos datos de altura del suelo sobre el nivel del mar en una grilla regular. Como ejemplo vamos a usar la vieja y querida `volcano`.

```{r}
library(data.table)
library(ggplot2)
data(volcano)
volcano <- as.data.table(melt(volcano, varnames = c("x", "y"),
                              value.name = "h"))
```

La forma m치s b치sica de visualizarlos (en `ggplot2`) es con un `geom_raster()` (o `geom_tile()`):

```{r}
ggplot(volcano, aes(x, y)) + 
   geom_raster(aes(fill = h), interpolate = TRUE) +
   scale_fill_viridis_c(option = "A", guide = "none") +
   coord_fixed() +
   theme_void()
```

Y est치 bien. Grafica los datos correctamente y encima elegimos una escala de colores uniforme y no asquerosa. Pero si uno quiere que tenga un poco m치s de *punch*, y quiz치s est치 dispuesto a perder un poco de exactitud en la representaci칩n en favor de una impresi칩n m치s instintiva de la forma de este volc치n, podr칤a preferir que tuviera alg칰n sombreado que de una idea del relieve. Algo llamativo como esto: 

<p align = "center">![](/images/shading.jpg)</p>

Lindo, 쯡o? En R podemos hacer algo aproximado. Lo que vamos a hacer es calcular la pendiente en cada punto de grilla y luego pensar que la intensidad de las luces y sombras son proporcionales al producto escalar entre 칠sta y el 치ngulo con el que llega el Sol. 

Tomando que el Sol brilla desde arriba a la izquierda, si una regi칩n tiene pendiente hacia arriba a la derecha, el producto escalar es negativo y tenemos una regi칩n de sombra. Lo mismo pasa al contrario... creo. En realidad no pens칠 esta parte demasiado bien, 춰pero el resultado en el gr치fico es bueno! (Cr칠anme 游똂).

Primero, tenemos que calcular el gradiente de la altura en cada punto. Ac치 estoy usando una funci칩n de mi paquete personal (que ustedes pueden adquirir en el puesto instalado en el hall del teatro... digo, [en github](https://github.com/eliocamp/metR)).

```{r}
volcano[, c("dx", "dy") := metR::Derivate(h ~ x + y)]
volcano[, angle := atan2(-dy, -dx)]
```

Ya con esto simplemente mapeamos el coseno del 치ngulo (por el producto vectorial) a una escala de grises que empiece y termine en el mismo color.  

```{r}
sun.angle <- pi/3
ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = cos(angle + sun.angle)), alpha = 1, interpolate = TRUE) +
   scale_fill_gradient2(low = "white", high = "white", mid = "gray20", 
                        midpoint = sun.angle, guide = "none") +
   coord_fixed() +
   theme_void() 
```

춰Hermoso!游눛 Si queremos cambiar la hora del d칤a, s칩lo basta con cambiar el 치ngulo del sol. Esas 치reas horribles en gris llano son regiones con errores, donde los datos son constantes, la derivada es nula y el 치ngulo entonces es cero. Por ahora dej칠moslas ser porque todav칤a hay una 칰ltima cosa que hacer. 

쯈u칠 tal si adem치s de este sombreado genial queremos de alguna mantera mostrar la altura? 쯋 otra variable como la temperatura o el uso del terreno o lo que sea? Como nuestra `scale_fill()` est치 siendo usada por el relieve, no podemos mapear otras variables a ese par치metro. Es decir, no podemos usar un `geom_tile()` con transparencia, por ejemplo. Que yo sepa hay dos formas de solucionar esto. Una f치cil y una dif칤cil. 

La primera implica hacer un poco de cirug칤a de plots. Primero, creamos un plot similar al anterior pero con transparencia y sin tanta fanfarria y m치s contraste. Despu칠s lo convertimos en un grob (GRaphical OBject) y luego le extraemos la parte que nos interesa. Esto ac치 est치 hecho manual pero podr칤a automatizarse. Hay que buscar primero el grob que sea `gTree` (el 5, en este caso) y luego, entre sus `children`, encontrar el que sea un `rect` (el 3). 

Finalmente, con el grob del sombreado ya en nuestras manos, hacemos el gr치fico que queremos, con las escalas que se nos ocurra, pero le agregamos el sombreado como una anotaci칩n con `annotation_custom()`. 

```{r}
shade <- ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = cos(angle + sun.angle)), alpha = 0.5, interpolate = TRUE) +
   scale_fill_gradient2(low = "white", high = "white", mid = "black", 
                        midpoint = sun.angle, guide = "none")

grob.shade <- ggplotGrob(shade)
grob.shade <- grob.shade$grobs[[6]]$children[[3]]

ggplot(volcano, aes(x, y)) +
   geom_raster(aes(fill = h), alpha = 1, interpolate = TRUE) +
   annotation_custom(grob = grob.shade) +
   scale_fill_viridis_c(guide = "none", option = "A") +
   coord_fixed() +
   theme_void() 

```

La forma m치s dif칤cil en realidad es dif칤cil para quien escribe, pero mucho m치s f치cil para quien lee: hacer un `geom` propio. Una vez que uno se mete en las entra침as de `ggplot2`, puede liberarse de las cadenas de las escalas y hacer `geoms` que dibujen las cosas como uno quiera. En este caso, cramos una versi칩n de `geom_tile()` que, adem치s de hacer los c치lculos de derivadas internamente, genera el degrad칠 (que puede ser modificado por el usuario mediante los par치metros `light` y `dark`) sin tocar ninguna escala. Adem치s, se puede cambiar el 치ngulo del sol con `sun.angle`, decidir si se usa `raster` (r치pido y permite interpolaci칩n, pero s칩lo en coordenadas cartesianas) o `rect` (m치s lento) y si interpola para un efecto m치s lindo. Les presento a `geom_relief()`: 

```{r include=TRUE}
geom_relief <- function(mapping = NULL, data = NULL,
                        stat = "identity", position = "identity",
                        ...,
                        raster = TRUE,
                        interpolate = TRUE,
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE) {
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = stat,
      geom = GeomRelief,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      params = list(
         raster = raster,
         interpolate = interpolate,
         na.rm = na.rm,
         ...
      )
   )
}

GeomRelief <- ggplot2::ggproto("GeomRelief", GeomTile,
  required_aes = c("x", "y", "z"),
  default_aes = ggplot2::aes(color = NA, fill = "grey35", size = 0.5, linetype = 1,
                             alpha = NA, light = "white", dark = "gray20", sun.angle = 60),
  draw_panel = function(data, panel_scales, coord, raster, interpolate) {
     if (!coord$is_linear()) {
        stop("non lineal coordinates are not implemented in GeomRelief", call. = FALSE)
     } else {
        coords <- as.data.table(coord$transform(data, panel_scales))
        
        # Esto es lo 칰nico que es nuevo. El resto es b치sicamente copy-paste
        # de geom_raster y geom_tile.
        coords[, sun.angle := (sun.angle + 90)*pi/180]
        coords[, dx := .derv(z, x), by = y]
        coords[, dy := .derv(z, y), by = x]
        coords[, shade := (cos(atan2(-dy, -dx) - sun.angle) + 1)/2]
        coords[is.na(shade), shade := 0]
        coords[, fill := .rgb2hex(colorRamp(c(dark, light), space = "Lab")(shade)),
               by = .(dark, light)]
        
        # Desde geom_raster y geom_tile
        if (raster == TRUE){
           if (!inherits(coord, "CoordCartesian")) {
              stop("geom_raster only works with Cartesian coordinates", call. = FALSE)
           }
           # Convert vector of data to raster
           x_pos <- as.integer((coords$x - min(coords$x)) / resolution(coords$x, FALSE))
           y_pos <- as.integer((coords$y - min(coords$y)) / resolution(coords$y, FALSE))
           
           nrow <- max(y_pos) + 1
           ncol <- max(x_pos) + 1
           
           raster <- matrix(NA_character_, nrow = nrow, ncol = ncol)
           raster[cbind(nrow - y_pos, x_pos + 1)] <- alpha(coords$fill, coords$alpha)
           
           # Figure out dimensions of raster on plot
           x_rng <- c(min(coords$xmin, na.rm = TRUE), max(coords$xmax, na.rm = TRUE))
           y_rng <- c(min(coords$ymin, na.rm = TRUE), max(coords$ymax, na.rm = TRUE))
           
           grid::rasterGrob(raster,
                            x = mean(x_rng), y = mean(y_rng),
                            width = diff(x_rng), height = diff(y_rng),
                            default.units = "native", interpolate = interpolate
           )
           
        } else {
           ggplot2:::ggname("geom_rect", grid::rectGrob(
              coords$xmin, coords$ymax,
              width = coords$xmax - coords$xmin,
              height = coords$ymax - coords$ymin,
              default.units = "native",
              just = c("left", "top"),
              gp = grid::gpar(
                 col = coords$fill,
                 fill = alpha(coords$fill, coords$alpha),
                 lwd = coords$size * .pt,
                 lty = coords$linetype,
                 lineend = "butt"
              )
           ))
           
        }
     }
  }
)

rect_to_poly <- function(xmin, xmax, ymin, ymax) {
   data.frame(
      y = c(ymax, ymax, ymin, ymin, ymax),
      x = c(xmin, xmax, xmax, xmin, xmin)
   )
}


.rgb2hex <- function(array) {
   rgb(array[, 1], array[, 3], array[, 3], maxColorValue = 255)
}

.derv <- function(x, y, order = 1, cyclical = FALSE, fill = FALSE) {
   N <- length(x)
   d <- y[2] - y[1]
   if (order >= 3) {
      dxdy <- .derv(.derv(x, y, order = 2, cyclical = cyclical, fill = fill),
                    y, order = order - 2, cyclical = cyclical, fill = fill)
   } else {
      if (order == 1) {
         dxdy <- (x[c(2:N, 1)] - x[c(N, 1:(N-1))])/(2*d)
      } else if (order == 2) {
         dxdy <- (x[c(2:N, 1)] + x[c(N, 1:(N-1))] - 2*x)/d^2
      }
      if (!cyclical) {
         if (!fill) {
            dxdy[c(1, N)] <- NA
         }
         if (fill) {
            dxdy[1] <- (-11/6*x[1] + 3*x[2] - 3/2*x[3] + 1/3*x[4])/d
            dxdy[N] <- (11/6*x[N] - 3*x[N-1] + 3/2*x[N-2] - 1/3*x[N-3])/d
         }
      }
      
   }
   return(dxdy)
}


```

De yapa, apliquemos esta t칠cnica a datos topogr치ficos reales de la Coordillera de los Andes cerca del Aconcagua, provistos por [ETOPO1 de la NOAA](https://www.ngdc.noaa.gov/mgg/global/).

```{r}
aconcagua <- metR::GetTopography(-70.0196223 - 3 + 360, -70.0196223 + 3 + 360,
                                 -32.6531782 + 2, -32.6531782 - 2, 
                                 resolution = 1/60)
aconcagua[, c("light", "dark") := .(ifelse(h > 0, "white", "slategray2"),
                                ifelse(h > 0, "gray20", "midnightblue"))] 
ggplot(aconcagua, aes(lon, lat)) +
   geom_relief(aes(z = h, light = light, dark = dark), 
               raster = TRUE, interpolate = TRUE, sun.angle = 60) +
   coord_fixed(expand = FALSE) +
   theme_void()
```

El resultado, para chuparse los dedos. 游녧