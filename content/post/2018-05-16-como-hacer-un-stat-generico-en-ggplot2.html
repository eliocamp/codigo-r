---
title: Como hacer un stat genérico en ggplot2
author: Elio Campitelli
date: '2018-05-16'
slug: como-hacer-un-stat-generico-en-ggplot2
categories:
  - R
tags:
  - ggplot2
---



<p>Hace un tiempo que venía pensando que si bien <code>ggplot2</code> es genial y tiene un montón de geoms y stats, le faltaba la opción de extenderlo a stats y geoms creados por el usuario. Luego, aprendí que <code>ggplot2</code> tiene un excelente sistema para extenderlo y empecé a crear mis propios stats. Pero aún así, hacer un <code>stat</code> específico cada vez que uno quiere hacer un plot en particular es demasiado complicado.</p>
<p>Entonces se me ocurrió una posible solución. Hacer un <code>stat</code> <em>genérico</em>; una tabula rasa que acepte una función creada por el usuario. Nativamente <code>ggplot2</code> viene con <code>stat_summary()</code> que hace algo similar, pero sólo acepta funciones que (como su nombre lo indica) sumaricen los datos de alguna manera. Lo que yo quería era algo totalmente genérico y este es mi primer intento.</p>
<p>Debajo, es el código de <code>stat_rasa()</code>, que toma los datos y una función que devuelva un data.frame interpretable por el <code>geom</code> elegido.</p>
<pre class="r"><code># ggproto object
StatRasa &lt;- ggplot2::ggproto(&quot;StatRasa&quot;, ggplot2::Stat,
  compute_group = function(data, scales, fun, fun.args) {
     # Change default arguments of the function to the 
     # values in fun.args
     args &lt;- formals(fun)
     for (i in seq_along(fun.args)) {
        if (names(fun.args[i]) %in% names(fun.args)) {
           args[[names(fun.args[i])]] &lt;- fun.args[[i]]
        } 
     }
     formals(fun) &lt;- args
     
     # Apply function to data
     fun(data)
})

# stat function used in ggplot
stat_rasa &lt;- function(mapping = NULL, data = NULL,
                      geom = &quot;point&quot;, 
                      position = &quot;identity&quot;,
                      fun = NULL,
                      ...,
                      show.legend = NA,
                      inherit.aes = TRUE) {
   # Check arguments 
   if (!is.function(fun)) stop(&quot;fun must be a function&quot;)
   
   # Pass dotted arguments to a list
   fun.args &lt;- match.call(expand.dots = FALSE)$`...`
   
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = StatRasa,
      geom = geom,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      check.aes = FALSE,
      check.param = FALSE,
      params = list(
         fun = fun, 
         fun.args = fun.args,
         na.rm = FALSE,
         ...
      )
   )
}</code></pre>
<p>Por ejemplo, si queremos rápidamente visualizar los datos menos sin la tendencia, podemos crear una función relativamente simple:</p>
<pre class="r"><code>Detrend &lt;- function(data, method = &quot;lm&quot;, span = 0.2) {
   if (method == &quot;lm&quot;) {
      data$y &lt;- resid(lm(y ~ x, data = data))
   } else {
      data$y &lt;- resid(loess(y ~ x, span = span, data = data))
   }
   as.data.frame(data)
}</code></pre>
<p>Y luego obtener los residuos en una sola línea.</p>
<pre class="r"><code>library(ggplot2)
set.seed(42)
x &lt;- seq(-1, 3, length.out = 30)
y &lt;- x^2 + rnorm(30)*0.5
df &lt;- data.frame(x = x, y = y)
ggplot(df, aes(x, y)) +
   geom_line() +
   stat_rasa(geom = &quot;line&quot;, fun = Detrend, method = &quot;smooth&quot;,
             color = &quot;steelblue&quot;)</code></pre>
<p><img src="/post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>Si queremos un poco más de legibilidad, podemos hacer una función con un nombre más informativo:</p>
<pre class="r"><code>stat_detrend &lt;- function(...) {
   stat_rasa(fun = Detrend, ...)
}

ggplot(df, aes(x, y)) +
   geom_line() +
   stat_detrend(method = &quot;lm&quot;, color = &quot;blue&quot;, geom = &quot;line&quot;)</code></pre>
<p><img src="/post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Otro caso es el de calcular contornos a partir de una grilla irregular. <code>ggplot2::stat_contour()</code> usa <code>grDevices::contourLines()</code> para computar los contornos y requiere una grilla regular y el paquete <code>contoureR</code> tiene una función que acepta una grilla irregular. Para usarla sin problemas lo único que tenemos que hacer es armar una pequeña función y usar <code>geom = &quot;path&quot;</code> en <code>stat_rasa()</code></p>
<pre class="r"><code>IrregularContour &lt;- function(data, breaks = scales::fullseq, 
                             binwidth = NULL,
                             bins = 10) {
   if (is.function(breaks)) {
      # If no parameters set, use pretty bins to calculate binwidth
      if (is.null(binwidth)) {
         binwidth &lt;- diff(range(data$z)) / bins
      }
      
      breaks &lt;- breaks(range(data$z), binwidth)
   }
   
   cl &lt;- contoureR::getContourLines(x = data$x, y = data$y, z = data$z, 
                                    levels = breaks)
   
   if (length(cl) == 0) {
      warning(&quot;Not possible to generate contour data&quot;, call. = FALSE)
      return(data.frame())
   }
   cl &lt;- cl[, 3:7]
   colnames(cl) &lt;- c(&quot;piece&quot;, &quot;group&quot;, &quot;x&quot;, &quot;y&quot;, &quot;level&quot;)
   return(cl)
}

stat_contour_irregular &lt;- function(...) {
   stat_rasa(fun = IrregularContour, geom = &quot;path&quot;, ...)
}</code></pre>
<pre class="r"><code>set.seed(42)
df &lt;- data.frame(x = rnorm(500),
                 y = rnorm(500))
df$z &lt;- with(df, -x*y*exp(-x^2 - y^2))

ggplot(df, aes(x, y)) +
   geom_point(aes(color = z)) +
   stat_contour_irregular(aes(z = z, color = ..level..), bins = 15) +
   scale_color_viridis_c()</code></pre>
<p><img src="/post/2018-05-16-como-hacer-un-stat-generico-en-ggplot2_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Y voilà.</p>
<p>Quedan algunos detalles para mejorar, como por ejemplo la posibilidad de utilizar una función para decidir los parámetros a usar de acuerdo a los datos, pero creo que así como está sirve para el 80% de las aplicaciones simples. También debería ponerle un mejor nombre, pero nombrar cosas es muy difícil.</p>
