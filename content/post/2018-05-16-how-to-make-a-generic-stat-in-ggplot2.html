---
title: How to make a generic stat in ggplot2
author: Elio Campitelli
date: '2018-05-16'
slug: how-to-make-a-generic-stat-in-ggplot2
categories:
  - R
tags:
  - ggplot2
---



<p>For a while now I’ve been thinking that, yes, <code>ggplot2</code> is awesome and offers a lot of <code>geoms</code> and <code>stats</code>, but it would be great if it could be extended with new user-generated <code>geoms</code> and <code>stats</code>. Then I learnt that <code>ggplot2</code> actually has a pretty great extension system so I could create my own geoms I needed for my work or <a href="https://twitter.com/d_olivaw/status/993669229810503680">just for fun</a>. But still, creating a geom from scratch is an involved process that doesn’t lend itself to simple transformations.</p>
<p>Finally, I thought of a possible solution: create a <em>generic</em> <code>stat</code> –a tabula rasa, if you will– that can work on the data with any function. Natively <code>ggplot2</code> offers <code>stat_summary()</code>, but it’s only meant to be used with, well, summary statistics. What I wanted was something completely generic and this is my first try.</p>
<p>Below is the code for <code>stat_rasa()</code> (better name pending). It works just like any other <code>stat</code> except that it works with any function that takes a data.frame and returns a transformed data.frame that can be interpreted by the chosen <code>geom</code>.</p>
<pre class="r"><code># ggproto object
StatRasa &lt;- ggplot2::ggproto(&quot;StatRasa&quot;, ggplot2::Stat,
  compute_group = function(data, scales, fun, fun.args) {
     # Change default arguments of the function to the 
     # values in fun.args
     args &lt;- formals(fun)
     for (i in seq_along(fun.args)) {
        if (names(fun.args[i]) %in% names(fun.args)) {
           args[[names(fun.args[i])]] &lt;- fun.args[[i]]
        } 
     }
     formals(fun) &lt;- args
     
     # Apply function to data
     fun(data)
})

# stat function used in ggplot
stat_rasa &lt;- function(mapping = NULL, data = NULL,
                      geom = &quot;point&quot;, 
                      position = &quot;identity&quot;,
                      fun = NULL,
                      ...,
                      show.legend = NA,
                      inherit.aes = TRUE) {
   # Check arguments 
   if (!is.function(fun)) stop(&quot;fun must be a function&quot;)
   
   # Pass dotted arguments to a list
   fun.args &lt;- match.call(expand.dots = FALSE)$`...`
   
   ggplot2::layer(
      data = data,
      mapping = mapping,
      stat = StatRasa,
      geom = geom,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      check.aes = FALSE,
      check.param = FALSE,
      params = list(
         fun = fun, 
         fun.args = fun.args,
         na.rm = FALSE,
         ...
      )
   )
}</code></pre>
<p>For example, let’s say we want to quickly glance at detrended data. We then create a very simple function</p>
<pre class="r"><code>Detrend &lt;- function(data, method = &quot;lm&quot;, span = 0.2) {
   if (method == &quot;lm&quot;) {
      data$y &lt;- resid(lm(y ~ x, data = data))
   } else {
      data$y &lt;- resid(loess(y ~ x, span = span, data = data))
   }
   as.data.frame(data)
}</code></pre>
<p>and pass it to <code>stat_rasa()</code></p>
<pre class="r"><code>library(ggplot2)
set.seed(42)
x &lt;- seq(-1, 3, length.out = 30)
y &lt;- x^2 + rnorm(30)*0.5
df &lt;- data.frame(x = x, y = y)
ggplot(df, aes(x, y)) +
   geom_line() +
   stat_rasa(geom = &quot;line&quot;, fun = Detrend, method = &quot;smooth&quot;,
             color = &quot;steelblue&quot;)</code></pre>
<p><img src="/post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>We can get better legibility and less typing by creating a wrapper function with a more descriptive name.</p>
<pre class="r"><code>stat_detrend &lt;- function(...) {
   stat_rasa(fun = Detrend, ...)
}

ggplot(df, aes(x, y)) +
   geom_line() +
   stat_detrend(method = &quot;lm&quot;, color = &quot;blue&quot;, geom = &quot;line&quot;)</code></pre>
<p><img src="/post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Another case could be calculating contours from an irregular grid. Since <code>ggplot2::stat_contour()</code> uses <code>grDevices::contourLines()</code>, it needs values defined in a regular grid, but there’s a package called <code>contoureR</code> that can compute contours from irregularly spaced observations. With <code>stat_rasa()</code> we can integrate it with <code>ggplot2</code> effortlessly by creating a small function and using <code>geom = &quot;path&quot;</code>.</p>
<pre class="r"><code>IrregularContour &lt;- function(data, breaks = scales::fullseq, 
                             binwidth = NULL,
                             bins = 10) {
   if (is.function(breaks)) {
      # If no parameters set, use pretty bins to calculate binwidth
      if (is.null(binwidth)) {
         binwidth &lt;- diff(range(data$z)) / bins
      }
      
      breaks &lt;- breaks(range(data$z), binwidth)
   }
   
   cl &lt;- contoureR::getContourLines(x = data$x, y = data$y, z = data$z, 
                                    levels = breaks)
   
   if (length(cl) == 0) {
      warning(&quot;Not possible to generate contour data&quot;, call. = FALSE)
      return(data.frame())
   }
   cl &lt;- cl[, 3:7]
   colnames(cl) &lt;- c(&quot;piece&quot;, &quot;group&quot;, &quot;x&quot;, &quot;y&quot;, &quot;level&quot;)
   return(cl)
}

stat_contour_irregular &lt;- function(...) {
   stat_rasa(fun = IrregularContour, geom = &quot;path&quot;, ...)
}</code></pre>
<pre class="r"><code>set.seed(42)
df &lt;- data.frame(x = rnorm(500),
                 y = rnorm(500))
df$z &lt;- with(df, -x*y*exp(-x^2 - y^2))

ggplot(df, aes(x, y)) +
   geom_point(aes(color = z)) +
   stat_contour_irregular(aes(z = z, color = ..level..), bins = 15) +
   scale_color_viridis_c()</code></pre>
<p><img src="/post/2018-05-16-how-to-make-a-generic-stat-in-ggplot2_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>And voilà.</p>
<p>There’s always things to improve. For example, the possibility of using a custom function to compute parameters that depend on the data, but I believe that as it stands covers 80% of simple applications. I should also use a better name, but naming things is hard work.</p>
